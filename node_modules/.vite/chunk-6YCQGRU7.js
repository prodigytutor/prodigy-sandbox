import {
  $,
  Action,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  AriaLabelProvider,
  BareFontInfo,
  BaseActionViewItem,
  BrowserFeatures,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CancellationToken,
  CancellationTokenSource,
  CharacterClassifier,
  CodeActionProviderRegistry,
  CodeEditorWidget,
  CodeLensProviderRegistry,
  Codicon,
  Color,
  ColorProviderRegistry,
  ColorScheme,
  CommandsRegistry,
  CompletionProviderRegistry,
  Configuration,
  ConfigurationChangedEvent,
  ConsoleLogger,
  ContextKeyExpr,
  DebounceEmitter,
  DeclarationProviderRegistry,
  DefaultKeyboardNavigationDelegate,
  DefaultStyleController,
  DefinitionProviderRegistry,
  Dimension,
  Disposable,
  DisposableStore,
  DocumentFormattingEditProviderRegistry,
  DocumentHighlightProviderRegistry,
  DocumentRangeFormattingEditProviderRegistry,
  DocumentRangeSemanticTokensProviderRegistry,
  DocumentSemanticTokensProviderRegistry,
  DocumentSymbolProviderRegistry,
  DomEmitter,
  DomScrollableElement,
  DragAndDropData,
  EDITOR_MODEL_DEFAULTS,
  EditOperation,
  EditorAction,
  EditorExtensionsRegistry,
  EditorFontLigatures,
  EditorOptions,
  EditorType,
  ElementSizeObserver,
  ElementsDragAndDropData,
  Emitter,
  EmptySubmenuAction,
  Event,
  EventBufferer,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  Extensions2,
  Extensions3,
  FindMatch,
  FoldingRangeKind,
  FoldingRangeProviderRegistry,
  FontInfo,
  FuzzyScore,
  Gesture,
  HighlightedLabel,
  HoverProviderRegistry,
  IAccessibilityService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IEditorWorkerService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  ILogService,
  IMarkerDecorationsService,
  IMenuService,
  IModeService,
  IModelService,
  INotificationService,
  IOpenerService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  IThemeService,
  IWorkspaceContextService,
  IconLabel,
  IdGenerator,
  IdleValue,
  ImmortalReference,
  ImplementationProviderRegistry,
  InMemoryStorageService,
  InlayHintsProviderRegistry,
  InlineCompletionsProviderRegistry,
  InlineDecoration,
  InternalEditorAction,
  IntervalTimer,
  Iterable,
  KeyChord,
  KeyCodeUtils,
  KeybindingsRegistry,
  LanguageConfigurationRegistry,
  LanguageIdentifier,
  LcsDiff,
  LineDecoration,
  LineTokens,
  LinkProviderRegistry,
  LinkedEditingRangeProviderRegistry,
  LinkedList,
  List,
  LogLevel,
  LogService,
  MOUSE_CURSOR_TEXT_CSS_CLASS_NAME,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  Mimes,
  MinimapPosition,
  ModelDecorationOptions,
  ModesRegistry,
  ModifierKeyEmitter,
  MouseController,
  MultilineTokens2,
  MutableDisposable,
  NULL_LANGUAGE_IDENTIFIER,
  NULL_MODE_ID,
  NULL_STATE,
  NoOpNotification,
  OS,
  OVERRIDE_PROPERTY_PATTERN,
  OnTypeFormattingEditProviderRegistry,
  OverviewRulerLane,
  OverviewRulerZone,
  PLAINTEXT_LANGUAGE_IDENTIFIER,
  PauseableEmitter,
  Position,
  PrefixSumComputer,
  Promises,
  Range,
  Range2,
  RawContextKey,
  ReferenceProviderRegistry,
  Registry,
  Relay,
  RenameProviderRegistry,
  RenderLineInput,
  ResolvedKeybinding,
  ResolvedKeybindingPart,
  ResourceMap,
  RunOnceScheduler,
  SET_CONTEXT_COMMAND_ID,
  Sash,
  Schemas,
  Scrollable,
  ScrollableElement,
  Selection,
  SelectionRangeRegistry,
  Separator,
  ServiceCollection,
  SetMap,
  SignatureHelpProviderRegistry,
  SimpleKeybinding,
  SmoothScrollableElement,
  SparseEncodedTokens,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StaticDND,
  StopWatch,
  StringSHA1,
  SubmenuAction,
  SubmenuItemAction,
  SyncDescriptor,
  TernarySearchTree,
  TextModel,
  TextModelResolvedOptions,
  Themable,
  ThemeIcon,
  TimeoutTimer,
  Token,
  TokenMetadata,
  TokenizationRegistry,
  TokenizationResult,
  TokenizationResult2,
  TypeDefinitionProviderRegistry,
  UILabelProvider,
  URI,
  VSBuffer,
  ViewLineRenderingData,
  Widget,
  WorkspaceFolder,
  _util,
  activeContrastBorder,
  addDisposableListener,
  addMatchMediaChangeListener,
  addStandardDisposableListener,
  addToValueTree,
  alert,
  append,
  asCSSPropertyValue,
  asCSSUrl,
  assertType,
  attachListStyler,
  attachMenuStyler,
  badgeBackground,
  badgeForeground,
  boolean,
  buttonBackground,
  buttonForeground,
  buttonHoverBackground,
  canceled,
  clamp,
  clearAllFontInfos,
  clearNode,
  coalesce,
  combinedDisposable,
  computeStyles,
  contrastBorder,
  createCSSRule,
  createCancelablePromise,
  createDecorator,
  createFastDomNode,
  createKeybinding,
  createProxyObject,
  createStringBuilder,
  createStyleSheet,
  deepClone,
  deepFreeze,
  defaultInsertColor,
  defaultListStyles,
  defaultRemoveColor,
  diffBorder,
  diffDiagonalFill,
  diffInserted,
  diffInsertedOutline,
  diffRemoved,
  diffRemovedOutline,
  disposableTimeout,
  dispose,
  distinct,
  distinctES6,
  editorActiveIndentGuides,
  editorBackground,
  editorForeground,
  editorInactiveSelection,
  editorIndentGuides,
  editorLineNumbers,
  editorSelectionHighlight,
  ensureValidWordDefinition,
  equals,
  equals2,
  escape,
  findParentWithClass,
  firstNonWhitespaceIndex,
  firstOrDefault,
  format,
  formatRule,
  fuzzyScore,
  getActiveElement,
  getAllMethodNames,
  getClientArea,
  getCodiconAriaLabel,
  getConfigurationKeys,
  getConfigurationValue,
  getDefaultValues,
  getDomNodePagePosition,
  getIconRegistry,
  getSingletonServiceDescriptors,
  getThemeTypeSelector,
  getTotalHeight,
  getTotalWidth,
  getWordAtText,
  globals,
  guessMimeTypes,
  hasParentWithClass,
  hide,
  illegalArgument,
  illegalState,
  inputBackground,
  inputBorder,
  inputForeground,
  inputValidationErrorBackground,
  inputValidationErrorBorder,
  inputValidationErrorForeground,
  inputValidationInfoBackground,
  inputValidationInfoBorder,
  inputValidationInfoForeground,
  inputValidationWarningBackground,
  inputValidationWarningBorder,
  inputValidationWarningForeground,
  isAncestor,
  isDiffEditorConfigurationKey,
  isDisposable,
  isEditStackElement,
  isEditorConfigurationKey,
  isFalsyOrEmpty,
  isFirefox,
  isHTMLElement,
  isIMenuItem,
  isIOS,
  isInShadowDOM,
  isInputElement,
  isLinux,
  isLittleEndian,
  isMacintosh,
  isMonacoEditor,
  isNonEmptyArray,
  isObject,
  isPromiseCanceledError,
  isSelectionRangeChangeEvent,
  isSelectionSingleChangeEvent,
  isThemeColor,
  isUndefined,
  isWeb,
  isWindows,
  keybindingLabelBackground,
  keybindingLabelBorder,
  keybindingLabelBottomBorder,
  keybindingLabelForeground,
  lastNonWhitespaceIndex,
  localize,
  ltrim,
  matchesFuzzyIconAware,
  matchesScheme,
  memoize,
  minimapError,
  minimapWarning,
  mixin,
  normalizePath,
  nullTokenize,
  ok,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  optional,
  overrideIdentifierFromKey,
  overviewRulerError,
  overviewRulerInfo,
  overviewRulerWarning,
  parse,
  parseLabelWithIcons,
  pickerGroupBorder,
  pickerGroupForeground,
  progressBarBackground,
  pushToEnd,
  pushToStart,
  quickInputBackground,
  quickInputForeground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickInputTitleBackground,
  range,
  regExpFlags,
  regExpLeadsToEndlessLoop,
  registerCodicon,
  registerEditorAction,
  registerEditorContribution,
  registerIcon,
  registerSingleton,
  registerTextMime,
  registerThemingParticipant,
  removeCSSRulesContainingSelector,
  removeFromValueTree,
  renderFormattedText,
  renderLabelWithIcons,
  renderText,
  renderViewLine,
  renderViewLine2,
  reset,
  rtrim,
  scheduleAtNextAnimationFrame,
  scrollbarShadow,
  scrollbarSliderActiveBackground,
  scrollbarSliderBackground,
  scrollbarSliderHoverBackground,
  setARIAContainer,
  severity_default,
  show,
  splice,
  splitLines,
  startsWithUTF8BOM,
  stringDiff,
  stringSet,
  stripIcons,
  tail2,
  themeColorFromId,
  timeout,
  toDisposable,
  toValuesTree,
  trackFocus,
  transformErrorForSerialization,
  widgetShadow,
  windowOpenNoOpener,
  withNullAsUndefined
} from "./chunk-YXUDLFWZ.js";

// node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
  CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
  CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
  CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
  CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
  CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
  CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
  CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
  CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
  CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
  CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
  CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
  CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
  CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
  CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
  CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
  CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
  CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
  CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
  CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
  CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
  CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
  CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
  CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
  CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind2) {
  CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var ContentWidgetPositionPreference;
(function(ContentWidgetPositionPreference2) {
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
var CursorChangeReason;
(function(CursorChangeReason2) {
  CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
  CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
  CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
  CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
  CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
  CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
  CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2[DocumentHighlightKind2["Text"] = 0] = "Text";
  DocumentHighlightKind2[DocumentHighlightKind2["Read"] = 1] = "Read";
  DocumentHighlightKind2[DocumentHighlightKind2["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingDelete"] = 6] = "autoClosingDelete";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 7] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 8] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 9] = "autoIndent";
  EditorOption2[EditorOption2["automaticLayout"] = 10] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 11] = "autoSurround";
  EditorOption2[EditorOption2["codeLens"] = 12] = "codeLens";
  EditorOption2[EditorOption2["codeLensFontFamily"] = 13] = "codeLensFontFamily";
  EditorOption2[EditorOption2["codeLensFontSize"] = 14] = "codeLensFontSize";
  EditorOption2[EditorOption2["colorDecorators"] = 15] = "colorDecorators";
  EditorOption2[EditorOption2["columnSelection"] = 16] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 17] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 18] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 19] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 20] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 21] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 22] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 23] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 24] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 25] = "cursorWidth";
  EditorOption2[EditorOption2["disableLayerHinting"] = 26] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 27] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["domReadOnly"] = 28] = "domReadOnly";
  EditorOption2[EditorOption2["dragAndDrop"] = 29] = "dragAndDrop";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 30] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["extraEditorClassName"] = 31] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 32] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 33] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 34] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 35] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 36] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 37] = "foldingHighlight";
  EditorOption2[EditorOption2["foldingImportsByDefault"] = 38] = "foldingImportsByDefault";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 39] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 40] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 41] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 42] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 43] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 44] = "fontWeight";
  EditorOption2[EditorOption2["formatOnPaste"] = 45] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 46] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 47] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 48] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 49] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["highlightActiveIndentGuide"] = 50] = "highlightActiveIndentGuide";
  EditorOption2[EditorOption2["hover"] = 51] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 52] = "inDiffEditor";
  EditorOption2[EditorOption2["inlineSuggest"] = 53] = "inlineSuggest";
  EditorOption2[EditorOption2["letterSpacing"] = 54] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 55] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 56] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 57] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 58] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 59] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["linkedEditing"] = 60] = "linkedEditing";
  EditorOption2[EditorOption2["links"] = 61] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 62] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 63] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 64] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 65] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 66] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 67] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 68] = "multiCursorModifier";
  EditorOption2[EditorOption2["multiCursorPaste"] = 69] = "multiCursorPaste";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 70] = "occurrencesHighlight";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 71] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 72] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 73] = "padding";
  EditorOption2[EditorOption2["parameterHints"] = 74] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 75] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 76] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 77] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 78] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 79] = "readOnly";
  EditorOption2[EditorOption2["renameOnType"] = 80] = "renameOnType";
  EditorOption2[EditorOption2["renderControlCharacters"] = 81] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderIndentGuides"] = 82] = "renderIndentGuides";
  EditorOption2[EditorOption2["renderFinalNewline"] = 83] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 84] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 85] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 86] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 87] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 88] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 89] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 90] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 91] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 92] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 93] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 94] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 95] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 96] = "selectionHighlight";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 97] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 98] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 99] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 100] = "snippetSuggestions";
  EditorOption2[EditorOption2["smartSelect"] = 101] = "smartSelect";
  EditorOption2[EditorOption2["smoothScrolling"] = 102] = "smoothScrolling";
  EditorOption2[EditorOption2["stickyTabStops"] = 103] = "stickyTabStops";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 104] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 105] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 106] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 107] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 108] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 109] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 110] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 111] = "tabIndex";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 112] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useShadowDOM"] = 113] = "useShadowDOM";
  EditorOption2[EditorOption2["useTabStops"] = 114] = "useTabStops";
  EditorOption2[EditorOption2["wordSeparators"] = 115] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 116] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 117] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 118] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 119] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapOverride1"] = 120] = "wordWrapOverride1";
  EditorOption2[EditorOption2["wordWrapOverride2"] = 121] = "wordWrapOverride2";
  EditorOption2[EditorOption2["wrappingIndent"] = 122] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 123] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 124] = "showDeprecated";
  EditorOption2[EditorOption2["inlayHints"] = 125] = "inlayHints";
  EditorOption2[EditorOption2["editorClassName"] = 126] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 127] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 128] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 129] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 130] = "wrappingInfo";
})(EditorOption || (EditorOption = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var IndentAction;
(function(IndentAction2) {
  IndentAction2[IndentAction2["None"] = 0] = "None";
  IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
  IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2[InlayHintKind2["Other"] = 0] = "Other";
  InlayHintKind2[InlayHintKind2["Type"] = 1] = "Type";
  InlayHintKind2[InlayHintKind2["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind2) {
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var KeyCode;
(function(KeyCode3) {
  KeyCode3[KeyCode3["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  KeyCode3[KeyCode3["Unknown"] = 0] = "Unknown";
  KeyCode3[KeyCode3["Backspace"] = 1] = "Backspace";
  KeyCode3[KeyCode3["Tab"] = 2] = "Tab";
  KeyCode3[KeyCode3["Enter"] = 3] = "Enter";
  KeyCode3[KeyCode3["Shift"] = 4] = "Shift";
  KeyCode3[KeyCode3["Ctrl"] = 5] = "Ctrl";
  KeyCode3[KeyCode3["Alt"] = 6] = "Alt";
  KeyCode3[KeyCode3["PauseBreak"] = 7] = "PauseBreak";
  KeyCode3[KeyCode3["CapsLock"] = 8] = "CapsLock";
  KeyCode3[KeyCode3["Escape"] = 9] = "Escape";
  KeyCode3[KeyCode3["Space"] = 10] = "Space";
  KeyCode3[KeyCode3["PageUp"] = 11] = "PageUp";
  KeyCode3[KeyCode3["PageDown"] = 12] = "PageDown";
  KeyCode3[KeyCode3["End"] = 13] = "End";
  KeyCode3[KeyCode3["Home"] = 14] = "Home";
  KeyCode3[KeyCode3["LeftArrow"] = 15] = "LeftArrow";
  KeyCode3[KeyCode3["UpArrow"] = 16] = "UpArrow";
  KeyCode3[KeyCode3["RightArrow"] = 17] = "RightArrow";
  KeyCode3[KeyCode3["DownArrow"] = 18] = "DownArrow";
  KeyCode3[KeyCode3["Insert"] = 19] = "Insert";
  KeyCode3[KeyCode3["Delete"] = 20] = "Delete";
  KeyCode3[KeyCode3["KEY_0"] = 21] = "KEY_0";
  KeyCode3[KeyCode3["KEY_1"] = 22] = "KEY_1";
  KeyCode3[KeyCode3["KEY_2"] = 23] = "KEY_2";
  KeyCode3[KeyCode3["KEY_3"] = 24] = "KEY_3";
  KeyCode3[KeyCode3["KEY_4"] = 25] = "KEY_4";
  KeyCode3[KeyCode3["KEY_5"] = 26] = "KEY_5";
  KeyCode3[KeyCode3["KEY_6"] = 27] = "KEY_6";
  KeyCode3[KeyCode3["KEY_7"] = 28] = "KEY_7";
  KeyCode3[KeyCode3["KEY_8"] = 29] = "KEY_8";
  KeyCode3[KeyCode3["KEY_9"] = 30] = "KEY_9";
  KeyCode3[KeyCode3["KEY_A"] = 31] = "KEY_A";
  KeyCode3[KeyCode3["KEY_B"] = 32] = "KEY_B";
  KeyCode3[KeyCode3["KEY_C"] = 33] = "KEY_C";
  KeyCode3[KeyCode3["KEY_D"] = 34] = "KEY_D";
  KeyCode3[KeyCode3["KEY_E"] = 35] = "KEY_E";
  KeyCode3[KeyCode3["KEY_F"] = 36] = "KEY_F";
  KeyCode3[KeyCode3["KEY_G"] = 37] = "KEY_G";
  KeyCode3[KeyCode3["KEY_H"] = 38] = "KEY_H";
  KeyCode3[KeyCode3["KEY_I"] = 39] = "KEY_I";
  KeyCode3[KeyCode3["KEY_J"] = 40] = "KEY_J";
  KeyCode3[KeyCode3["KEY_K"] = 41] = "KEY_K";
  KeyCode3[KeyCode3["KEY_L"] = 42] = "KEY_L";
  KeyCode3[KeyCode3["KEY_M"] = 43] = "KEY_M";
  KeyCode3[KeyCode3["KEY_N"] = 44] = "KEY_N";
  KeyCode3[KeyCode3["KEY_O"] = 45] = "KEY_O";
  KeyCode3[KeyCode3["KEY_P"] = 46] = "KEY_P";
  KeyCode3[KeyCode3["KEY_Q"] = 47] = "KEY_Q";
  KeyCode3[KeyCode3["KEY_R"] = 48] = "KEY_R";
  KeyCode3[KeyCode3["KEY_S"] = 49] = "KEY_S";
  KeyCode3[KeyCode3["KEY_T"] = 50] = "KEY_T";
  KeyCode3[KeyCode3["KEY_U"] = 51] = "KEY_U";
  KeyCode3[KeyCode3["KEY_V"] = 52] = "KEY_V";
  KeyCode3[KeyCode3["KEY_W"] = 53] = "KEY_W";
  KeyCode3[KeyCode3["KEY_X"] = 54] = "KEY_X";
  KeyCode3[KeyCode3["KEY_Y"] = 55] = "KEY_Y";
  KeyCode3[KeyCode3["KEY_Z"] = 56] = "KEY_Z";
  KeyCode3[KeyCode3["Meta"] = 57] = "Meta";
  KeyCode3[KeyCode3["ContextMenu"] = 58] = "ContextMenu";
  KeyCode3[KeyCode3["F1"] = 59] = "F1";
  KeyCode3[KeyCode3["F2"] = 60] = "F2";
  KeyCode3[KeyCode3["F3"] = 61] = "F3";
  KeyCode3[KeyCode3["F4"] = 62] = "F4";
  KeyCode3[KeyCode3["F5"] = 63] = "F5";
  KeyCode3[KeyCode3["F6"] = 64] = "F6";
  KeyCode3[KeyCode3["F7"] = 65] = "F7";
  KeyCode3[KeyCode3["F8"] = 66] = "F8";
  KeyCode3[KeyCode3["F9"] = 67] = "F9";
  KeyCode3[KeyCode3["F10"] = 68] = "F10";
  KeyCode3[KeyCode3["F11"] = 69] = "F11";
  KeyCode3[KeyCode3["F12"] = 70] = "F12";
  KeyCode3[KeyCode3["F13"] = 71] = "F13";
  KeyCode3[KeyCode3["F14"] = 72] = "F14";
  KeyCode3[KeyCode3["F15"] = 73] = "F15";
  KeyCode3[KeyCode3["F16"] = 74] = "F16";
  KeyCode3[KeyCode3["F17"] = 75] = "F17";
  KeyCode3[KeyCode3["F18"] = 76] = "F18";
  KeyCode3[KeyCode3["F19"] = 77] = "F19";
  KeyCode3[KeyCode3["NumLock"] = 78] = "NumLock";
  KeyCode3[KeyCode3["ScrollLock"] = 79] = "ScrollLock";
  KeyCode3[KeyCode3["US_SEMICOLON"] = 80] = "US_SEMICOLON";
  KeyCode3[KeyCode3["US_EQUAL"] = 81] = "US_EQUAL";
  KeyCode3[KeyCode3["US_COMMA"] = 82] = "US_COMMA";
  KeyCode3[KeyCode3["US_MINUS"] = 83] = "US_MINUS";
  KeyCode3[KeyCode3["US_DOT"] = 84] = "US_DOT";
  KeyCode3[KeyCode3["US_SLASH"] = 85] = "US_SLASH";
  KeyCode3[KeyCode3["US_BACKTICK"] = 86] = "US_BACKTICK";
  KeyCode3[KeyCode3["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
  KeyCode3[KeyCode3["US_BACKSLASH"] = 88] = "US_BACKSLASH";
  KeyCode3[KeyCode3["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
  KeyCode3[KeyCode3["US_QUOTE"] = 90] = "US_QUOTE";
  KeyCode3[KeyCode3["OEM_8"] = 91] = "OEM_8";
  KeyCode3[KeyCode3["OEM_102"] = 92] = "OEM_102";
  KeyCode3[KeyCode3["NUMPAD_0"] = 93] = "NUMPAD_0";
  KeyCode3[KeyCode3["NUMPAD_1"] = 94] = "NUMPAD_1";
  KeyCode3[KeyCode3["NUMPAD_2"] = 95] = "NUMPAD_2";
  KeyCode3[KeyCode3["NUMPAD_3"] = 96] = "NUMPAD_3";
  KeyCode3[KeyCode3["NUMPAD_4"] = 97] = "NUMPAD_4";
  KeyCode3[KeyCode3["NUMPAD_5"] = 98] = "NUMPAD_5";
  KeyCode3[KeyCode3["NUMPAD_6"] = 99] = "NUMPAD_6";
  KeyCode3[KeyCode3["NUMPAD_7"] = 100] = "NUMPAD_7";
  KeyCode3[KeyCode3["NUMPAD_8"] = 101] = "NUMPAD_8";
  KeyCode3[KeyCode3["NUMPAD_9"] = 102] = "NUMPAD_9";
  KeyCode3[KeyCode3["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
  KeyCode3[KeyCode3["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
  KeyCode3[KeyCode3["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
  KeyCode3[KeyCode3["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
  KeyCode3[KeyCode3["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
  KeyCode3[KeyCode3["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
  KeyCode3[KeyCode3["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
  KeyCode3[KeyCode3["ABNT_C1"] = 110] = "ABNT_C1";
  KeyCode3[KeyCode3["ABNT_C2"] = 111] = "ABNT_C2";
  KeyCode3[KeyCode3["MAX_VALUE"] = 112] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function(MarkerSeverity4) {
  MarkerSeverity4[MarkerSeverity4["Hint"] = 1] = "Hint";
  MarkerSeverity4[MarkerSeverity4["Info"] = 2] = "Info";
  MarkerSeverity4[MarkerSeverity4["Warning"] = 4] = "Warning";
  MarkerSeverity4[MarkerSeverity4["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function(MarkerTag3) {
  MarkerTag3[MarkerTag3["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag3[MarkerTag3["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MinimapPosition2;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition2 || (MinimapPosition2 = {}));
var MouseTargetType;
(function(MouseTargetType2) {
  MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
  MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
  MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
  MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
  MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
  MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
  MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
  MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
  MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
  MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var OverlayWidgetPositionPreference;
(function(OverlayWidgetPositionPreference2) {
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
var OverviewRulerLane2;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
  ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function(ScrollbarVisibility2) {
  ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
  ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var SelectionDirection;
(function(SelectionDirection3) {
  SelectionDirection3[SelectionDirection3["LTR"] = 0] = "LTR";
  SelectionDirection3[SelectionDirection3["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind2) {
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2[SymbolKind2["File"] = 0] = "File";
  SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
  SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
  SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
  SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
  SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
  SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
  SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
  SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
  SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
  SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
  SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
  SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
  SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
  SymbolKind2[SymbolKind2["String"] = 14] = "String";
  SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
  SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
  SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
  SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
  SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
  SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
  SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
  SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
  SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
  SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
  SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
var TextEditorCursorStyle;
(function(TextEditorCursorStyle2) {
  TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js
var KeyMod = class {
  static chord(firstPart, secondPart) {
    return KeyChord(firstPart, secondPart);
  }
};
KeyMod.CtrlCmd = 2048;
KeyMod.Shift = 1024;
KeyMod.Alt = 512;
KeyMod.WinCtrl = 256;
function createMonacoBaseAPI() {
  return {
    editor: void 0,
    languages: void 0,
    CancellationTokenSource,
    Emitter,
    KeyCode,
    KeyMod,
    Position,
    Range,
    Selection,
    SelectionDirection,
    MarkerSeverity,
    MarkerTag,
    Uri: URI,
    Token
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/editor/standalone/browser/standalone-tokens.css";

// node_modules/monaco-editor/esm/vs/platform/editor/common/editor.js
var EditorOpenContext;
(function(EditorOpenContext2) {
  EditorOpenContext2[EditorOpenContext2["API"] = 0] = "API";
  EditorOpenContext2[EditorOpenContext2["USER"] = 1] = "USER";
})(EditorOpenContext || (EditorOpenContext = {}));

// node_modules/monaco-editor/esm/vs/editor/browser/services/openerService.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CommandOpener = class CommandOpener2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  open(target, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!matchesScheme(target, Schemas.command)) {
        return false;
      }
      if (!(options === null || options === void 0 ? void 0 : options.allowCommands)) {
        return true;
      }
      if (typeof target === "string") {
        target = URI.parse(target);
      }
      let args = [];
      try {
        args = parse(decodeURIComponent(target.query));
      } catch (_a6) {
        try {
          args = parse(target.query);
        } catch (_b) {
        }
      }
      if (!Array.isArray(args)) {
        args = [args];
      }
      yield this._commandService.executeCommand(target.path, ...args);
      return true;
    });
  }
};
CommandOpener = __decorate([
  __param(0, ICommandService)
], CommandOpener);
var EditorOpener = class EditorOpener2 {
  constructor(_editorService) {
    this._editorService = _editorService;
  }
  open(target, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof target === "string") {
        target = URI.parse(target);
      }
      let selection = void 0;
      const match = /^L?(\d+)(?:,(\d+))?/.exec(target.fragment);
      if (match) {
        selection = {
          startLineNumber: parseInt(match[1]),
          startColumn: match[2] ? parseInt(match[2]) : 1
        };
        target = target.with({ fragment: "" });
      }
      if (target.scheme === Schemas.file) {
        target = normalizePath(target);
      }
      yield this._editorService.openCodeEditor({
        resource: target,
        options: Object.assign({ selection, context: (options === null || options === void 0 ? void 0 : options.fromUserGesture) ? EditorOpenContext.USER : EditorOpenContext.API }, options === null || options === void 0 ? void 0 : options.editorOptions)
      }, this._editorService.getFocusedCodeEditor(), options === null || options === void 0 ? void 0 : options.openToSide);
      return true;
    });
  }
};
EditorOpener = __decorate([
  __param(0, ICodeEditorService)
], EditorOpener);
var OpenerService = class OpenerService2 {
  constructor(editorService, commandService) {
    this._openers = new LinkedList();
    this._validators = new LinkedList();
    this._resolvers = new LinkedList();
    this._resolvedUriTargets = new ResourceMap((uri) => uri.with({ path: null, fragment: null, query: null }).toString());
    this._externalOpeners = new LinkedList();
    this._defaultExternalOpener = {
      openExternal: (href) => __awaiter(this, void 0, void 0, function* () {
        if (matchesScheme(href, Schemas.http) || matchesScheme(href, Schemas.https)) {
          windowOpenNoOpener(href);
        } else {
          window.location.href = href;
        }
        return true;
      })
    };
    this._openers.push({
      open: (target, options) => __awaiter(this, void 0, void 0, function* () {
        if ((options === null || options === void 0 ? void 0 : options.openExternal) || matchesScheme(target, Schemas.mailto) || matchesScheme(target, Schemas.http) || matchesScheme(target, Schemas.https)) {
          yield this._doOpenExternal(target, options);
          return true;
        }
        return false;
      })
    });
    this._openers.push(new CommandOpener(commandService));
    this._openers.push(new EditorOpener(editorService));
  }
  registerOpener(opener) {
    const remove = this._openers.unshift(opener);
    return { dispose: remove };
  }
  registerValidator(validator) {
    const remove = this._validators.push(validator);
    return { dispose: remove };
  }
  registerExternalUriResolver(resolver) {
    const remove = this._resolvers.push(resolver);
    return { dispose: remove };
  }
  setDefaultExternalOpener(externalOpener) {
    this._defaultExternalOpener = externalOpener;
  }
  registerExternalOpener(opener) {
    const remove = this._externalOpeners.push(opener);
    return { dispose: remove };
  }
  open(target, options) {
    var _a6;
    return __awaiter(this, void 0, void 0, function* () {
      const targetURI = typeof target === "string" ? URI.parse(target) : target;
      const validationTarget = (_a6 = this._resolvedUriTargets.get(targetURI)) !== null && _a6 !== void 0 ? _a6 : target;
      for (const validator of this._validators) {
        if (!(yield validator.shouldOpen(validationTarget))) {
          return false;
        }
      }
      for (const opener of this._openers) {
        const handled = yield opener.open(target, options);
        if (handled) {
          return true;
        }
      }
      return false;
    });
  }
  resolveExternalUri(resource, options) {
    return __awaiter(this, void 0, void 0, function* () {
      for (const resolver of this._resolvers) {
        try {
          const result = yield resolver.resolveExternalUri(resource, options);
          if (result) {
            if (!this._resolvedUriTargets.has(result.resolved)) {
              this._resolvedUriTargets.set(result.resolved, resource);
            }
            return result;
          }
        } catch (_a6) {
        }
      }
      throw new Error("Could not resolve external URI: " + resource.toString());
    });
  }
  _doOpenExternal(resource, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const uri = typeof resource === "string" ? URI.parse(resource) : resource;
      let externalUri;
      try {
        externalUri = (yield this.resolveExternalUri(uri, options)).resolved;
      } catch (_a6) {
        externalUri = uri;
      }
      let href;
      if (typeof resource === "string" && uri.toString() === externalUri.toString()) {
        href = resource;
      } else {
        href = encodeURI(externalUri.toString(true));
      }
      if (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) {
        const preferredOpenerId = typeof (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) === "string" ? options === null || options === void 0 ? void 0 : options.allowContributedOpeners : void 0;
        for (const opener of this._externalOpeners) {
          const didOpen = yield opener.openExternal(href, {
            sourceUri: uri,
            preferredOpenerId
          }, CancellationToken.None);
          if (didOpen) {
            return true;
          }
        }
      }
      return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);
    });
  }
  dispose() {
    this._validators.clear();
  }
};
OpenerService = __decorate([
  __param(0, ICodeEditorService),
  __param(1, ICommandService)
], OpenerService);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffNavigator.js
var defaultOptions = {
  followsCaret: true,
  ignoreCharChanges: true,
  alwaysRevealFirst: true
};
var DiffNavigator = class extends Disposable {
  constructor(editor2, options = {}) {
    super();
    this._onDidUpdate = this._register(new Emitter());
    this._editor = editor2;
    this._options = mixin(options, defaultOptions, false);
    this.disposed = false;
    this.nextIdx = -1;
    this.ranges = [];
    this.ignoreSelectionChange = false;
    this.revealFirst = Boolean(this._options.alwaysRevealFirst);
    this._register(this._editor.onDidDispose(() => this.dispose()));
    this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated()));
    if (this._options.followsCaret) {
      this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((e) => {
        if (this.ignoreSelectionChange) {
          return;
        }
        this.nextIdx = -1;
      }));
    }
    if (this._options.alwaysRevealFirst) {
      this._register(this._editor.getModifiedEditor().onDidChangeModel((e) => {
        this.revealFirst = true;
      }));
    }
    this._init();
  }
  _init() {
    let changes = this._editor.getLineChanges();
    if (!changes) {
      return;
    }
  }
  _onDiffUpdated() {
    this._init();
    this._compute(this._editor.getLineChanges());
    if (this.revealFirst) {
      if (this._editor.getLineChanges() !== null) {
        this.revealFirst = false;
        this.nextIdx = -1;
        this.next(1);
      }
    }
  }
  _compute(lineChanges) {
    this.ranges = [];
    if (lineChanges) {
      lineChanges.forEach((lineChange) => {
        if (!this._options.ignoreCharChanges && lineChange.charChanges) {
          lineChange.charChanges.forEach((charChange) => {
            this.ranges.push({
              rhs: true,
              range: new Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)
            });
          });
        } else {
          this.ranges.push({
            rhs: true,
            range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)
          });
        }
      });
    }
    this.ranges.sort((left, right) => {
      if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {
        return -1;
      } else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {
        return 1;
      } else {
        return 0;
      }
    });
    this._onDidUpdate.fire(this);
  }
  _initIdx(fwd) {
    let found = false;
    let position = this._editor.getPosition();
    if (!position) {
      this.nextIdx = 0;
      return;
    }
    for (let i = 0, len = this.ranges.length; i < len && !found; i++) {
      let range2 = this.ranges[i].range;
      if (position.isBeforeOrEqual(range2.getStartPosition())) {
        this.nextIdx = i + (fwd ? 0 : -1);
        found = true;
      }
    }
    if (!found) {
      this.nextIdx = fwd ? 0 : this.ranges.length - 1;
    }
    if (this.nextIdx < 0) {
      this.nextIdx = this.ranges.length - 1;
    }
  }
  _move(fwd, scrollType) {
    ok(!this.disposed, "Illegal State - diff navigator has been disposed");
    if (!this.canNavigate()) {
      return;
    }
    if (this.nextIdx === -1) {
      this._initIdx(fwd);
    } else if (fwd) {
      this.nextIdx += 1;
      if (this.nextIdx >= this.ranges.length) {
        this.nextIdx = 0;
      }
    } else {
      this.nextIdx -= 1;
      if (this.nextIdx < 0) {
        this.nextIdx = this.ranges.length - 1;
      }
    }
    let info = this.ranges[this.nextIdx];
    this.ignoreSelectionChange = true;
    try {
      let pos = info.range.getStartPosition();
      this._editor.setPosition(pos);
      this._editor.revealPositionInCenter(pos, scrollType);
    } finally {
      this.ignoreSelectionChange = false;
    }
  }
  canNavigate() {
    return this.ranges && this.ranges.length > 0;
  }
  next(scrollType = 0) {
    this._move(true, scrollType);
  }
  previous(scrollType = 0) {
    this._move(false, scrollType);
  }
  dispose() {
    super.dispose();
    this.ranges = [];
    this.disposed = true;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
var INITIALIZE = "$initialize";
var webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
  if (!isWeb) {
    return;
  }
  if (!webWorkerWarningLogged) {
    webWorkerWarningLogged = true;
    console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq");
  }
  console.warn(err.message);
}
var SimpleWorkerProtocol = class {
  constructor(handler) {
    this._workerId = -1;
    this._handler = handler;
    this._lastSentReq = 0;
    this._pendingReplies = Object.create(null);
  }
  setWorkerId(workerId) {
    this._workerId = workerId;
  }
  sendMessage(method, args) {
    let req = String(++this._lastSentReq);
    return new Promise((resolve, reject) => {
      this._pendingReplies[req] = {
        resolve,
        reject
      };
      this._send({
        vsWorker: this._workerId,
        req,
        method,
        args
      });
    });
  }
  handleMessage(message) {
    if (!message || !message.vsWorker) {
      return;
    }
    if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
      return;
    }
    this._handleMessage(message);
  }
  _handleMessage(msg) {
    if (msg.seq) {
      let replyMessage = msg;
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      let reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
      return;
    }
    let requestMessage = msg;
    let req = requestMessage.req;
    let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
    result.then((r) => {
      this._send({
        vsWorker: this._workerId,
        seq: req,
        res: r,
        err: void 0
      });
    }, (e) => {
      if (e.detail instanceof Error) {
        e.detail = transformErrorForSerialization(e.detail);
      }
      this._send({
        vsWorker: this._workerId,
        seq: req,
        res: void 0,
        err: transformErrorForSerialization(e)
      });
    });
  }
  _send(msg) {
    let transfer = [];
    if (msg.req) {
      const m = msg;
      for (let i = 0; i < m.args.length; i++) {
        if (m.args[i] instanceof ArrayBuffer) {
          transfer.push(m.args[i]);
        }
      }
    } else {
      const m = msg;
      if (m.res instanceof ArrayBuffer) {
        transfer.push(m.res);
      }
    }
    this._handler.sendMessage(msg, transfer);
  }
};
var SimpleWorkerClient = class extends Disposable {
  constructor(workerFactory, moduleId, host) {
    super();
    let lazyProxyReject = null;
    this._worker = this._register(workerFactory.create("vs/base/common/worker/simpleWorker", (msg) => {
      this._protocol.handleMessage(msg);
    }, (err) => {
      if (lazyProxyReject) {
        lazyProxyReject(err);
      }
    }));
    this._protocol = new SimpleWorkerProtocol({
      sendMessage: (msg, transfer) => {
        this._worker.postMessage(msg, transfer);
      },
      handleMessage: (method, args) => {
        if (typeof host[method] !== "function") {
          return Promise.reject(new Error("Missing method " + method + " on main thread host."));
        }
        try {
          return Promise.resolve(host[method].apply(host, args));
        } catch (e) {
          return Promise.reject(e);
        }
      }
    });
    this._protocol.setWorkerId(this._worker.getId());
    let loaderConfiguration = null;
    if (typeof self.require !== "undefined" && typeof self.require.getConfig === "function") {
      loaderConfiguration = self.require.getConfig();
    } else if (typeof self.requirejs !== "undefined") {
      loaderConfiguration = self.requirejs.s.contexts._.config;
    }
    const hostMethods = getAllMethodNames(host);
    this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(loaderConfiguration)),
      moduleId,
      hostMethods
    ]);
    const proxyMethodRequest = (method, args) => {
      return this._request(method, args);
    };
    this._lazyProxy = new Promise((resolve, reject) => {
      lazyProxyReject = reject;
      this._onModuleLoaded.then((availableMethods) => {
        resolve(createProxyObject(availableMethods, proxyMethodRequest));
      }, (e) => {
        reject(e);
        this._onError("Worker failed to load " + moduleId, e);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(method, args) {
    return new Promise((resolve, reject) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(method, args).then(resolve, reject);
      }, reject);
    });
  }
  _onError(message, error) {
    console.error(message);
    console.info(error);
  }
};

// node_modules/monaco-editor/esm/vs/base/worker/defaultWorkerFactory.js
var _a;
var ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy("defaultWorkerFactory", { createScriptURL: (value) => value });
function getWorker(workerId, label) {
  if (globals.MonacoEnvironment) {
    if (typeof globals.MonacoEnvironment.getWorker === "function") {
      return globals.MonacoEnvironment.getWorker(workerId, label);
    }
    if (typeof globals.MonacoEnvironment.getWorkerUrl === "function") {
      const wokerUrl = globals.MonacoEnvironment.getWorkerUrl(workerId, label);
      return new Worker(ttPolicy ? ttPolicy.createScriptURL(wokerUrl) : wokerUrl, { name: label });
    }
  }
  throw new Error(`You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`);
}
function isPromiseLike(obj) {
  if (typeof obj.then === "function") {
    return true;
  }
  return false;
}
var WebWorker = class {
  constructor(moduleId, id, label, onMessageCallback, onErrorCallback) {
    this.id = id;
    const workerOrPromise = getWorker("workerMain.js", label);
    if (isPromiseLike(workerOrPromise)) {
      this.worker = workerOrPromise;
    } else {
      this.worker = Promise.resolve(workerOrPromise);
    }
    this.postMessage(moduleId, []);
    this.worker.then((w) => {
      w.onmessage = function(ev) {
        onMessageCallback(ev.data);
      };
      w.onmessageerror = onErrorCallback;
      if (typeof w.addEventListener === "function") {
        w.addEventListener("error", onErrorCallback);
      }
    });
  }
  getId() {
    return this.id;
  }
  postMessage(message, transfer) {
    if (this.worker) {
      this.worker.then((w) => w.postMessage(message, transfer));
    }
  }
  dispose() {
    if (this.worker) {
      this.worker.then((w) => w.terminate());
    }
    this.worker = null;
  }
};
var DefaultWorkerFactory = class {
  constructor(label) {
    this._label = label;
    this._webWorkerFailedBeforeError = false;
  }
  create(moduleId, onMessageCallback, onErrorCallback) {
    let workerId = ++DefaultWorkerFactory.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError) {
      throw this._webWorkerFailedBeforeError;
    }
    return new WebWorker(moduleId, workerId, this._label || "anonymous" + workerId, onMessageCallback, (err) => {
      logOnceWebWorkerWarning(err);
      this._webWorkerFailedBeforeError = err;
      onErrorCallback(err);
    });
  }
};
DefaultWorkerFactory.LAST_WORKER_ID = 0;

// node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js
var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
  return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = class {
  constructor(lines) {
    const startColumns = [];
    const endColumns = [];
    for (let i = 0, length = lines.length; i < length; i++) {
      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
      endColumns[i] = getLastNonBlankColumn(lines[i], 1);
    }
    this.lines = lines;
    this._startColumns = startColumns;
    this._endColumns = endColumns;
  }
  getElements() {
    const elements = [];
    for (let i = 0, len = this.lines.length; i < len; i++) {
      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
    }
    return elements;
  }
  getStrictElement(index) {
    return this.lines[index];
  }
  getStartLineNumber(i) {
    return i + 1;
  }
  getEndLineNumber(i) {
    return i + 1;
  }
  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
    const charCodes = [];
    const lineNumbers = [];
    const columns = [];
    let len = 0;
    for (let index = startIndex; index <= endIndex; index++) {
      const lineContent = this.lines[index];
      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
      for (let col = startColumn; col < endColumn; col++) {
        charCodes[len] = lineContent.charCodeAt(col - 1);
        lineNumbers[len] = index + 1;
        columns[len] = col;
        len++;
      }
    }
    return new CharSequence(charCodes, lineNumbers, columns);
  }
};
var CharSequence = class {
  constructor(charCodes, lineNumbers, columns) {
    this._charCodes = charCodes;
    this._lineNumbers = lineNumbers;
    this._columns = columns;
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(i) {
    return this._lineNumbers[i];
  }
  getStartColumn(i) {
    return this._columns[i];
  }
  getEndLineNumber(i) {
    return this._lineNumbers[i];
  }
  getEndColumn(i) {
    return this._columns[i] + 1;
  }
};
var CharChange = class {
  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalStartColumn = originalStartColumn;
    this.originalEndLineNumber = originalEndLineNumber;
    this.originalEndColumn = originalEndColumn;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedStartColumn = modifiedStartColumn;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.modifiedEndColumn = modifiedEndColumn;
  }
  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
    let originalStartLineNumber;
    let originalStartColumn;
    let originalEndLineNumber;
    let originalEndColumn;
    let modifiedStartLineNumber;
    let modifiedStartColumn;
    let modifiedEndLineNumber;
    let modifiedEndColumn;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = 0;
      originalStartColumn = 0;
      originalEndLineNumber = 0;
      originalEndColumn = 0;
    } else {
      originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = 0;
      modifiedStartColumn = 0;
      modifiedEndLineNumber = 0;
      modifiedEndColumn = 0;
    } else {
      modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
  }
};
function postProcessCharChanges(rawChanges) {
  if (rawChanges.length <= 1) {
    return rawChanges;
  }
  const result = [rawChanges[0]];
  let prevChange = result[0];
  for (let i = 1, len = rawChanges.length; i < len; i++) {
    const currChange = rawChanges[i];
    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
    } else {
      result.push(currChange);
      prevChange = currChange;
    }
  }
  return result;
}
var LineChange = class {
  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalEndLineNumber = originalEndLineNumber;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.charChanges = charChanges;
  }
  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let charChanges = void 0;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
      originalEndLineNumber = 0;
    } else {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
      modifiedEndLineNumber = 0;
    } else {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
      let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
      if (shouldPostProcessCharChanges) {
        rawChanges = postProcessCharChanges(rawChanges);
      }
      charChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
      }
    }
    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
  }
};
var DiffComputer = class {
  constructor(originalLines, modifiedLines, opts) {
    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
    this.originalLines = originalLines;
    this.modifiedLines = modifiedLines;
    this.original = new LineSequence(originalLines);
    this.modified = new LineSequence(modifiedLines);
    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: []
        };
      }
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    }
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    }
    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
    const rawChanges = diffResult.changes;
    const quitEarly = diffResult.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const lineChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      }
      return {
        quitEarly,
        changes: lineChanges
      };
    }
    const result = [];
    let originalLineIndex = 0;
    let modifiedLineIndex = 0;
    for (let i = -1, len = rawChanges.length; i < len; i++) {
      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
        const originalLine = this.originalLines[originalLineIndex];
        const modifiedLine = this.modifiedLines[modifiedLineIndex];
        if (originalLine !== modifiedLine) {
          {
            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
            while (originalStartColumn > 1 && modifiedStartColumn > 1) {
              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            if (originalStartColumn > 1 || modifiedStartColumn > 1) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            }
          }
          {
            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
            const originalMaxColumn = originalLine.length + 1;
            const modifiedMaxColumn = modifiedLine.length + 1;
            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalEndColumn++;
              modifiedEndColumn++;
            }
            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
            }
          }
        }
        originalLineIndex++;
        modifiedLineIndex++;
      }
      if (nextChange) {
        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        originalLineIndex += nextChange.originalLength;
        modifiedLineIndex += nextChange.modifiedLength;
      }
    }
    return {
      quitEarly,
      changes: result
    };
  }
  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
      return;
    }
    let charChanges = void 0;
    if (this.shouldComputeCharChanges) {
      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
    }
    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
  }
  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    const len = result.length;
    if (len === 0) {
      return false;
    }
    const prevChange = result[len - 1];
    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
      return false;
    }
    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
      prevChange.originalEndLineNumber = originalLineNumber;
      prevChange.modifiedEndLineNumber = modifiedLineNumber;
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    return false;
  }
};
function getFirstNonBlankColumn(txt, defaultValue) {
  const r = firstNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
  const r = lastNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
  if (maximumRuntime === 0) {
    return () => true;
  }
  const startTime = Date.now();
  return () => {
    return Date.now() - startTime < maximumRuntime;
  };
}

// node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.startLineNumber - 1].substring(range2.endColumn - 1));
      return;
    }
    this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.endLineNumber - 1].substring(range2.endColumn - 1));
    this._lines.splice(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    let insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    let newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data[i] = defaultValue;
    }
    this._data = data;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      let [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    let states = new Uint8Matrix(maxState, maxCharCode, 0);
    for (let i = 0, len = edges.length; i < len; i++) {
      let [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [1, 104, 2],
      [1, 72, 2],
      [1, 102, 6],
      [1, 70, 6],
      [2, 116, 3],
      [2, 84, 3],
      [3, 116, 4],
      [3, 84, 4],
      [4, 112, 5],
      [4, 80, 5],
      [5, 115, 9],
      [5, 83, 9],
      [5, 58, 10],
      [6, 105, 7],
      [6, 73, 7],
      [7, 108, 8],
      [7, 76, 8],
      [8, 101, 9],
      [8, 69, 9],
      [9, 58, 10],
      [10, 47, 11],
      [11, 47, 12]
    ]);
  }
  return _stateMachine;
}
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(0);
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1);
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2);
    }
  }
  return _classifier;
}
var LinkComputer = class {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    let result = [];
    for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
      const line = model.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            case 39:
              chClass = linkBeginChCode === 34 || linkBeginChCode === 96 ? 0 : 1;
              break;
            case 34:
              chClass = linkBeginChCode === 39 || linkBeginChCode === 96 ? 0 : 1;
              break;
            case 96:
              chClass = linkBeginChCode === 39 || linkBeginChCode === 34 ? 0 : 1;
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 124:
              chClass = linkBeginChCode === 124 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};
function computeLinks(model) {
  if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
    return [];
  }
  return LinkComputer.computeLinks(model);
}

// node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js
var BasicInplaceReplace = class {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(range1, text1, range2, text2, up) {
    if (range1 && text1) {
      let result = this.doNavigateValueSet(text1, up);
      if (result) {
        return {
          range: range1,
          value: result
        };
      }
    }
    if (range2 && text2) {
      let result = this.doNavigateValueSet(text2, up);
      if (result) {
        return {
          range: range2,
          value: result
        };
      }
    }
    return null;
  }
  doNavigateValueSet(text, up) {
    let numberResult = this.numberReplace(text, up);
    if (numberResult !== null) {
      return numberResult;
    }
    return this.textReplace(text, up);
  }
  numberReplace(value, up) {
    let precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
    let n1 = Number(value);
    let n2 = parseFloat(value);
    if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
      if (n1 === 0 && !up) {
        return null;
      } else {
        n1 = Math.floor(n1 * precision);
        n1 += up ? precision : -precision;
        return String(n1 / precision);
      }
    }
    return null;
  }
  textReplace(value, up) {
    return this.valueSetsReplace(this._defaultValueSet, value, up);
  }
  valueSetsReplace(valueSets, value, up) {
    let result = null;
    for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
      result = this.valueSetReplace(valueSets[i], value, up);
    }
    return result;
  }
  valueSetReplace(valueSet, value, up) {
    let idx = valueSet.indexOf(value);
    if (idx >= 0) {
      idx += up ? 1 : -1;
      if (idx < 0) {
        idx = valueSet.length - 1;
      } else {
        idx %= valueSet.length;
      }
      return valueSet[idx];
    }
    return null;
  }
};
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MirrorModel = class extends MirrorTextModel {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(lineNumber) {
    return this._lines[lineNumber - 1];
  }
  getWordAtPosition(position, wordDefinition) {
    let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
    if (wordAtText) {
      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
    }
    return null;
  }
  words(wordDefinition) {
    const lines = this._lines;
    const wordenize = this._wordenize.bind(this);
    let lineNumber = 0;
    let lineText = "";
    let wordRangesIdx = 0;
    let wordRanges = [];
    return {
      *[Symbol.iterator]() {
        while (true) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber];
              wordRanges = wordenize(lineText, wordDefinition);
              wordRangesIdx = 0;
              lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }
    };
  }
  getLineWords(lineNumber, wordDefinition) {
    let content = this._lines[lineNumber - 1];
    let ranges = this._wordenize(content, wordDefinition);
    let words = [];
    for (const range2 of ranges) {
      words.push({
        word: content.substring(range2.start, range2.end),
        startColumn: range2.start + 1,
        endColumn: range2.end + 1
      });
    }
    return words;
  }
  _wordenize(content, wordDefinition) {
    const result = [];
    let match;
    wordDefinition.lastIndex = 0;
    while (match = wordDefinition.exec(content)) {
      if (match[0].length === 0) {
        break;
      }
      result.push({ start: match.index, end: match.index + match[0].length });
    }
    return result;
  }
  getValueInRange(range2) {
    range2 = this._validateRange(range2);
    if (range2.startLineNumber === range2.endLineNumber) {
      return this._lines[range2.startLineNumber - 1].substring(range2.startColumn - 1, range2.endColumn - 1);
    }
    let lineEnding = this._eol;
    let startLineIndex = range2.startLineNumber - 1;
    let endLineIndex = range2.endLineNumber - 1;
    let resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range2.startColumn - 1));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range2.endColumn - 1));
    return resultLines.join(lineEnding);
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    let out = this._lineStarts.getIndexOf(offset);
    let lineLength = this._lines[out.index].length;
    return {
      lineNumber: 1 + out.index,
      column: 1 + Math.min(out.remainder, lineLength)
    };
  }
  _validateRange(range2) {
    const start = this._validatePosition({ lineNumber: range2.startLineNumber, column: range2.startColumn });
    const end = this._validatePosition({ lineNumber: range2.endLineNumber, column: range2.endColumn });
    if (start.lineNumber !== range2.startLineNumber || start.column !== range2.startColumn || end.lineNumber !== range2.endLineNumber || end.column !== range2.endColumn) {
      return {
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
      };
    }
    return range2;
  }
  _validatePosition(position) {
    if (!Position.isIPosition(position)) {
      throw new Error("bad position");
    }
    let { lineNumber, column } = position;
    let hasChanged = false;
    if (lineNumber < 1) {
      lineNumber = 1;
      column = 1;
      hasChanged = true;
    } else if (lineNumber > this._lines.length) {
      lineNumber = this._lines.length;
      column = this._lines[lineNumber - 1].length + 1;
      hasChanged = true;
    } else {
      let maxCharacter = this._lines[lineNumber - 1].length + 1;
      if (column < 1) {
        column = 1;
        hasChanged = true;
      } else if (column > maxCharacter) {
        column = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    } else {
      return { lineNumber, column };
    }
  }
};
var EditorSimpleWorker = class {
  constructor(host, foreignModuleFactory) {
    this._host = host;
    this._models = Object.create(null);
    this._foreignModuleFactory = foreignModuleFactory;
    this._foreignModule = null;
  }
  dispose() {
    this._models = Object.create(null);
  }
  _getModel(uri) {
    return this._models[uri];
  }
  _getModels() {
    let all = [];
    Object.keys(this._models).forEach((key) => all.push(this._models[key]));
    return all;
  }
  acceptNewModel(data) {
    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
  }
  acceptModelChanged(strURL, e) {
    if (!this._models[strURL]) {
      return;
    }
    let model = this._models[strURL];
    model.onEvents(e);
  }
  acceptRemovedModel(strURL) {
    if (!this._models[strURL]) {
      return;
    }
    delete this._models[strURL];
  }
  computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
    return __awaiter2(this, void 0, void 0, function* () {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const originalLines = original.getLinesContent();
      const modifiedLines = modified.getLinesContent();
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        shouldComputeCharChanges: true,
        shouldPostProcessCharChanges: true,
        shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
        shouldMakePrettyDiff: true,
        maxComputationTime
      });
      const diffResult = diffComputer.computeDiff();
      const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);
      return {
        quitEarly: diffResult.quitEarly,
        identical,
        changes: diffResult.changes
      };
    });
  }
  _modelsAreIdentical(original, modified) {
    const originalLineCount = original.getLineCount();
    const modifiedLineCount = modified.getLineCount();
    if (originalLineCount !== modifiedLineCount) {
      return false;
    }
    for (let line = 1; line <= originalLineCount; line++) {
      const originalLine = original.getLineContent(line);
      const modifiedLine = modified.getLineContent(line);
      if (originalLine !== modifiedLine) {
        return false;
      }
    }
    return true;
  }
  computeMoreMinimalEdits(modelUrl, edits) {
    return __awaiter2(this, void 0, void 0, function* () {
      const model = this._getModel(modelUrl);
      if (!model) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a, b) => {
        if (a.range && b.range) {
          return Range.compareRangesUsingStarts(a.range, b.range);
        }
        let aRng = a.range ? 0 : 1;
        let bRng = b.range ? 0 : 1;
        return aRng - bRng;
      });
      for (let { range: range2, text, eol } of edits) {
        if (typeof eol === "number") {
          lastEol = eol;
        }
        if (Range.isEmpty(range2) && !text) {
          continue;
        }
        const original = model.getValueInRange(range2);
        text = text.replace(/\r\n|\n|\r/g, model.eol);
        if (original === text) {
          continue;
        }
        if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
          result.push({ range: range2, text });
          continue;
        }
        const changes = stringDiff(original, text, false);
        const editOffset = model.offsetAt(Range.lift(range2).getStartPosition());
        for (const change of changes) {
          const start = model.positionAt(editOffset + change.originalStart);
          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text.substr(change.modifiedStart, change.modifiedLength),
            range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
          };
          if (model.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
      }
      return result;
    });
  }
  computeLinks(modelUrl) {
    return __awaiter2(this, void 0, void 0, function* () {
      let model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeLinks(model);
    });
  }
  textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
    return __awaiter2(this, void 0, void 0, function* () {
      const sw = new StopWatch(true);
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const seen = new Set();
      outer:
        for (let url of modelUrls) {
          const model = this._getModel(url);
          if (!model) {
            continue;
          }
          for (let word of model.words(wordDefRegExp)) {
            if (word === leadingWord || !isNaN(Number(word))) {
              continue;
            }
            seen.add(word);
            if (seen.size > EditorSimpleWorker._suggestionsLimit) {
              break outer;
            }
          }
        }
      return { words: Array.from(seen), duration: sw.elapsed() };
    });
  }
  computeWordRanges(modelUrl, range2, wordDef, wordDefFlags) {
    return __awaiter2(this, void 0, void 0, function* () {
      let model = this._getModel(modelUrl);
      if (!model) {
        return Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = Object.create(null);
      for (let line = range2.startLineNumber; line < range2.endLineNumber; line++) {
        let words = model.getLineWords(line, wordDefRegExp);
        for (const word of words) {
          if (!isNaN(Number(word.word))) {
            continue;
          }
          let array = result[word.word];
          if (!array) {
            array = [];
            result[word.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word.startColumn,
            endLineNumber: line,
            endColumn: word.endColumn
          });
        }
      }
      return result;
    });
  }
  navigateValueSet(modelUrl, range2, up, wordDef, wordDefFlags) {
    return __awaiter2(this, void 0, void 0, function* () {
      let model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      let wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range2.startColumn === range2.endColumn) {
        range2 = {
          startLineNumber: range2.startLineNumber,
          startColumn: range2.startColumn,
          endLineNumber: range2.endLineNumber,
          endColumn: range2.endColumn + 1
        };
      }
      let selectionText = model.getValueInRange(range2);
      let wordRange = model.getWordAtPosition({ lineNumber: range2.startLineNumber, column: range2.startColumn }, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      let word = model.getValueInRange(wordRange);
      let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range2, selectionText, wordRange, word, up);
      return result;
    });
  }
  loadForeignModule(moduleId, createData, foreignHostMethods) {
    const proxyMethodRequest = (method, args) => {
      return this._host.fhr(method, args);
    };
    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
    let ctx = {
      host: foreignHost,
      getMirrorModels: () => {
        return this._getModels();
      }
    };
    if (this._foreignModuleFactory) {
      this._foreignModule = this._foreignModuleFactory(ctx, createData);
      return Promise.resolve(getAllMethodNames(this._foreignModule));
    }
    return Promise.reject(new Error(`Unexpected usage`));
  }
  fmr(method, args) {
    if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
EditorSimpleWorker._diffLimit = 1e5;
EditorSimpleWorker._suggestionsLimit = 1e4;
if (typeof importScripts === "function") {
  globals.monaco = createMonacoBaseAPI();
}

// node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfigurationService.js
var ITextResourceConfigurationService = createDecorator("textResourceConfigurationService");
var ITextResourcePropertiesService = createDecorator("textResourcePropertiesService");

// node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerServiceImpl.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;
var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1e3;
function canSyncModel(modelService, resource) {
  let model = modelService.getModel(resource);
  if (!model) {
    return false;
  }
  if (model.isTooLargeForSyncing()) {
    return false;
  }
  return true;
}
var EditorWorkerServiceImpl = class EditorWorkerServiceImpl2 extends Disposable {
  constructor(modelService, configurationService, logService) {
    super();
    this._modelService = modelService;
    this._workerManager = this._register(new WorkerManager(this._modelService));
    this._logService = logService;
    this._register(LinkProviderRegistry.register("*", {
      provideLinks: (model, token) => {
        if (!canSyncModel(this._modelService, model.uri)) {
          return Promise.resolve({ links: [] });
        }
        return this._workerManager.withWorker().then((client) => client.computeLinks(model.uri)).then((links) => {
          return links && { links };
        });
      }
    }));
    this._register(CompletionProviderRegistry.register("*", new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeDiff(original, modified) {
    return canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified);
  }
  computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime) {
    return this._workerManager.withWorker().then((client) => client.computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime));
  }
  computeMoreMinimalEdits(resource, edits) {
    if (isNonEmptyArray(edits)) {
      if (!canSyncModel(this._modelService, resource)) {
        return Promise.resolve(edits);
      }
      const sw = StopWatch.create(true);
      const result = this._workerManager.withWorker().then((client) => client.computeMoreMinimalEdits(resource, edits));
      result.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", resource.toString(true), sw.elapsed()));
      return Promise.race([result, timeout(1e3).then(() => edits)]);
    } else {
      return Promise.resolve(void 0);
    }
  }
  canNavigateValueSet(resource) {
    return canSyncModel(this._modelService, resource);
  }
  navigateValueSet(resource, range2, up) {
    return this._workerManager.withWorker().then((client) => client.navigateValueSet(resource, range2, up));
  }
  canComputeWordRanges(resource) {
    return canSyncModel(this._modelService, resource);
  }
  computeWordRanges(resource, range2) {
    return this._workerManager.withWorker().then((client) => client.computeWordRanges(resource, range2));
  }
};
EditorWorkerServiceImpl = __decorate2([
  __param2(0, IModelService),
  __param2(1, ITextResourceConfigurationService),
  __param2(2, ILogService)
], EditorWorkerServiceImpl);
var WordBasedCompletionItemProvider = class {
  constructor(workerManager, configurationService, modelService) {
    this._debugDisplayName = "wordbasedCompletions";
    this._workerManager = workerManager;
    this._configurationService = configurationService;
    this._modelService = modelService;
  }
  provideCompletionItems(model, position) {
    return __awaiter3(this, void 0, void 0, function* () {
      const config = this._configurationService.getValue(model.uri, position, "editor");
      if (!config.wordBasedSuggestions) {
        return void 0;
      }
      const models = [];
      if (config.wordBasedSuggestionsMode === "currentDocument") {
        if (canSyncModel(this._modelService, model.uri)) {
          models.push(model.uri);
        }
      } else {
        for (const candidate of this._modelService.getModels()) {
          if (!canSyncModel(this._modelService, candidate.uri)) {
            continue;
          }
          if (candidate === model) {
            models.unshift(candidate.uri);
          } else if (config.wordBasedSuggestionsMode === "allDocuments" || candidate.getLanguageIdentifier().id === model.getLanguageIdentifier().id) {
            models.push(candidate.uri);
          }
        }
      }
      if (models.length === 0) {
        return void 0;
      }
      const wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
      const word = model.getWordAtPosition(position);
      const replace = !word ? Range.fromPositions(position) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
      const insert = replace.setEndPosition(position.lineNumber, position.column);
      const client = yield this._workerManager.withWorker();
      const data = yield client.textualSuggest(models, word === null || word === void 0 ? void 0 : word.word, wordDefRegExp);
      if (!data) {
        return void 0;
      }
      return {
        duration: data.duration,
        suggestions: data.words.map((word2) => {
          return {
            kind: 18,
            label: word2,
            insertText: word2,
            range: { insert, replace }
          };
        })
      };
    });
  }
};
var WorkerManager = class extends Disposable {
  constructor(modelService) {
    super();
    this._modelService = modelService;
    this._editorWorkerClient = null;
    this._lastWorkerUsedTime = new Date().getTime();
    let stopWorkerInterval = this._register(new IntervalTimer());
    stopWorkerInterval.cancelAndSet(() => this._checkStopIdleWorker(), Math.round(STOP_WORKER_DELTA_TIME_MS / 2));
    this._register(this._modelService.onModelRemoved((_) => this._checkStopEmptyWorker()));
  }
  dispose() {
    if (this._editorWorkerClient) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
    super.dispose();
  }
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    let models = this._modelService.getModels();
    if (models.length === 0) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    let timeSinceLastWorkerUsedTime = new Date().getTime() - this._lastWorkerUsedTime;
    if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  withWorker() {
    this._lastWorkerUsedTime = new Date().getTime();
    if (!this._editorWorkerClient) {
      this._editorWorkerClient = new EditorWorkerClient(this._modelService, false, "editorWorkerService");
    }
    return Promise.resolve(this._editorWorkerClient);
  }
};
var EditorModelManager = class extends Disposable {
  constructor(proxy, modelService, keepIdleModels) {
    super();
    this._syncedModels = Object.create(null);
    this._syncedModelsLastUsedTime = Object.create(null);
    this._proxy = proxy;
    this._modelService = modelService;
    if (!keepIdleModels) {
      let timer = new IntervalTimer();
      timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
      this._register(timer);
    }
  }
  dispose() {
    for (let modelUrl in this._syncedModels) {
      dispose(this._syncedModels[modelUrl]);
    }
    this._syncedModels = Object.create(null);
    this._syncedModelsLastUsedTime = Object.create(null);
    super.dispose();
  }
  ensureSyncedResources(resources) {
    for (const resource of resources) {
      let resourceStr = resource.toString();
      if (!this._syncedModels[resourceStr]) {
        this._beginModelSync(resource);
      }
      if (this._syncedModels[resourceStr]) {
        this._syncedModelsLastUsedTime[resourceStr] = new Date().getTime();
      }
    }
  }
  _checkStopModelSync() {
    let currentTime = new Date().getTime();
    let toRemove = [];
    for (let modelUrl in this._syncedModelsLastUsedTime) {
      let elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
      if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
        toRemove.push(modelUrl);
      }
    }
    for (const e of toRemove) {
      this._stopModelSync(e);
    }
  }
  _beginModelSync(resource) {
    let model = this._modelService.getModel(resource);
    if (!model) {
      return;
    }
    if (model.isTooLargeForSyncing()) {
      return;
    }
    let modelUrl = resource.toString();
    this._proxy.acceptNewModel({
      url: model.uri.toString(),
      lines: model.getLinesContent(),
      EOL: model.getEOL(),
      versionId: model.getVersionId()
    });
    const toDispose = new DisposableStore();
    toDispose.add(model.onDidChangeContent((e) => {
      this._proxy.acceptModelChanged(modelUrl.toString(), e);
    }));
    toDispose.add(model.onWillDispose(() => {
      this._stopModelSync(modelUrl);
    }));
    toDispose.add(toDisposable(() => {
      this._proxy.acceptRemovedModel(modelUrl);
    }));
    this._syncedModels[modelUrl] = toDispose;
  }
  _stopModelSync(modelUrl) {
    let toDispose = this._syncedModels[modelUrl];
    delete this._syncedModels[modelUrl];
    delete this._syncedModelsLastUsedTime[modelUrl];
    dispose(toDispose);
  }
};
var SynchronousWorkerClient = class {
  constructor(instance) {
    this._instance = instance;
    this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
};
var EditorWorkerHost = class {
  constructor(workerClient) {
    this._workerClient = workerClient;
  }
  fhr(method, args) {
    return this._workerClient.fhr(method, args);
  }
};
var EditorWorkerClient = class extends Disposable {
  constructor(modelService, keepIdleModels, label) {
    super();
    this._disposed = false;
    this._modelService = modelService;
    this._keepIdleModels = keepIdleModels;
    this._workerFactory = new DefaultWorkerFactory(label);
    this._worker = null;
    this._modelManager = null;
  }
  fhr(method, args) {
    throw new Error(`Not implemented!`);
  }
  _getOrCreateWorker() {
    if (!this._worker) {
      try {
        this._worker = this._register(new SimpleWorkerClient(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new EditorWorkerHost(this)));
      } catch (err) {
        logOnceWebWorkerWarning(err);
        this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      }
    }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (err) => {
      logOnceWebWorkerWarning(err);
      this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      return this._getOrCreateWorker().getProxyObject();
    });
  }
  _getOrCreateModelManager(proxy) {
    if (!this._modelManager) {
      this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, this._keepIdleModels));
    }
    return this._modelManager;
  }
  _withSyncedResources(resources) {
    if (this._disposed) {
      return Promise.reject(canceled());
    }
    return this._getProxy().then((proxy) => {
      this._getOrCreateModelManager(proxy).ensureSyncedResources(resources);
      return proxy;
    });
  }
  computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime) {
    return this._withSyncedResources([original, modified]).then((proxy) => {
      return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace, maxComputationTime);
    });
  }
  computeMoreMinimalEdits(resource, edits) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeMoreMinimalEdits(resource.toString(), edits);
    });
  }
  computeLinks(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeLinks(resource.toString());
    });
  }
  textualSuggest(resources, leadingWord, wordDefRegExp) {
    return __awaiter3(this, void 0, void 0, function* () {
      const proxy = yield this._withSyncedResources(resources);
      const wordDef = wordDefRegExp.source;
      const wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.textualSuggest(resources.map((r) => r.toString()), leadingWord, wordDef, wordDefFlags);
    });
  }
  computeWordRanges(resource, range2) {
    return this._withSyncedResources([resource]).then((proxy) => {
      let model = this._modelService.getModel(resource);
      if (!model) {
        return Promise.resolve(null);
      }
      let wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
      let wordDef = wordDefRegExp.source;
      let wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.computeWordRanges(resource.toString(), range2, wordDef, wordDefFlags);
    });
  }
  navigateValueSet(resource, range2, up) {
    return this._withSyncedResources([resource]).then((proxy) => {
      let model = this._modelService.getModel(resource);
      if (!model) {
        return null;
      }
      let wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
      let wordDef = wordDefRegExp.source;
      let wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.navigateValueSet(resource.toString(), range2, up, wordDef, wordDefFlags);
    });
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/webWorker.js
function createWebWorker(modelService, opts) {
  return new MonacoWebWorkerImpl(modelService, opts);
}
var MonacoWebWorkerImpl = class extends EditorWorkerClient {
  constructor(modelService, opts) {
    super(modelService, opts.keepIdleModels || false, opts.label);
    this._foreignModuleId = opts.moduleId;
    this._foreignModuleCreateData = opts.createData || null;
    this._foreignModuleHost = opts.host || null;
    this._foreignProxy = null;
  }
  fhr(method, args) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== "function") {
      return Promise.reject(new Error("Missing method " + method + " or missing main thread foreign host."));
    }
    try {
      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _getForeignProxy() {
    if (!this._foreignProxy) {
      this._foreignProxy = this._getProxy().then((proxy) => {
        const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];
        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {
          this._foreignModuleCreateData = null;
          const proxyMethodRequest = (method, args) => {
            return proxy.fmr(method, args);
          };
          const createProxyMethod = (method, proxyMethodRequest2) => {
            return function() {
              const args = Array.prototype.slice.call(arguments, 0);
              return proxyMethodRequest2(method, args);
            };
          };
          let foreignProxy = {};
          for (const foreignMethod of foreignMethods) {
            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);
          }
          return foreignProxy;
        });
      });
    }
    return this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(resources) {
    return this._withSyncedResources(resources).then((_) => this.getProxy());
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCommon.js
function isFuzzyActionArr(what) {
  return Array.isArray(what);
}
function isFuzzyAction(what) {
  return !isFuzzyActionArr(what);
}
function isString(what) {
  return typeof what === "string";
}
function isIAction(what) {
  return !isString(what);
}
function empty(s) {
  return s ? false : true;
}
function fixCase(lexer, str) {
  return lexer.ignoreCase && str ? str.toLowerCase() : str;
}
function sanitize(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function log(lexer, msg) {
  console.log(`${lexer.languageId}: ${msg}`);
}
function createError(lexer, msg) {
  return new Error(`${lexer.languageId}: ${msg}`);
}
function substituteMatches(lexer, str, id, matches, state) {
  const re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let stateMatches = null;
  return str.replace(re, function(full, sub, dollar, hash, n, s, attr, ofs, total) {
    if (!empty(dollar)) {
      return "$";
    }
    if (!empty(hash)) {
      return fixCase(lexer, id);
    }
    if (!empty(n) && n < matches.length) {
      return fixCase(lexer, matches[n]);
    }
    if (!empty(attr) && lexer && typeof lexer[attr] === "string") {
      return lexer[attr];
    }
    if (stateMatches === null) {
      stateMatches = state.split(".");
      stateMatches.unshift(state);
    }
    if (!empty(s) && s < stateMatches.length) {
      return fixCase(lexer, stateMatches[s]);
    }
    return "";
  });
}
function findRules(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const rules = lexer.tokenizer[state];
    if (rules) {
      return rules;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return null;
}
function stateExists(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const exist = lexer.stateNames[state];
    if (exist) {
      return true;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return false;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js
var CACHE_STACK_DEPTH = 5;
var MonarchStackElementFactory = class {
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = Object.create(null);
  }
  static create(parent, state) {
    return this._INSTANCE.create(parent, state);
  }
  create(parent, state) {
    if (parent !== null && parent.depth >= this._maxCacheDepth) {
      return new MonarchStackElement(parent, state);
    }
    let stackElementId = MonarchStackElement.getStackElementId(parent);
    if (stackElementId.length > 0) {
      stackElementId += "|";
    }
    stackElementId += state;
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchStackElement(parent, state);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
var MonarchStackElement = class {
  constructor(parent, state) {
    this.parent = parent;
    this.state = state;
    this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(element) {
    let result = "";
    while (element !== null) {
      if (result.length > 0) {
        result += "|";
      }
      result += element.state;
      element = element.parent;
    }
    return result;
  }
  static _equals(a, b) {
    while (a !== null && b !== null) {
      if (a === b) {
        return true;
      }
      if (a.state !== b.state) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    }
    if (a === null && b === null) {
      return true;
    }
    return false;
  }
  equals(other) {
    return MonarchStackElement._equals(this, other);
  }
  push(state) {
    return MonarchStackElementFactory.create(this, state);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let result = this;
    while (result.parent) {
      result = result.parent;
    }
    return result;
  }
  switchTo(state) {
    return MonarchStackElementFactory.create(this.parent, state);
  }
};
var EmbeddedModeData = class {
  constructor(modeId, state) {
    this.modeId = modeId;
    this.state = state;
  }
  equals(other) {
    return this.modeId === other.modeId && this.state.equals(other.state);
  }
  clone() {
    let stateClone = this.state.clone();
    if (stateClone === this.state) {
      return this;
    }
    return new EmbeddedModeData(this.modeId, this.state);
  }
};
var MonarchLineStateFactory = class {
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = Object.create(null);
  }
  static create(stack, embeddedModeData) {
    return this._INSTANCE.create(stack, embeddedModeData);
  }
  create(stack, embeddedModeData) {
    if (embeddedModeData !== null) {
      return new MonarchLineState(stack, embeddedModeData);
    }
    if (stack !== null && stack.depth >= this._maxCacheDepth) {
      return new MonarchLineState(stack, embeddedModeData);
    }
    let stackElementId = MonarchStackElement.getStackElementId(stack);
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchLineState(stack, null);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
var MonarchLineState = class {
  constructor(stack, embeddedModeData) {
    this.stack = stack;
    this.embeddedModeData = embeddedModeData;
  }
  clone() {
    let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;
    if (embeddedModeDataClone === this.embeddedModeData) {
      return this;
    }
    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);
  }
  equals(other) {
    if (!(other instanceof MonarchLineState)) {
      return false;
    }
    if (!this.stack.equals(other.stack)) {
      return false;
    }
    if (this.embeddedModeData === null && other.embeddedModeData === null) {
      return true;
    }
    if (this.embeddedModeData === null || other.embeddedModeData === null) {
      return false;
    }
    return this.embeddedModeData.equals(other.embeddedModeData);
  }
};
var MonarchClassicTokensCollector = class {
  constructor() {
    this._tokens = [];
    this._language = null;
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
  }
  enterMode(startOffset, modeId) {
    this._language = modeId;
  }
  emit(startOffset, type) {
    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {
      return;
    }
    this._lastTokenType = type;
    this._lastTokenLanguage = this._language;
    this._tokens.push(new Token(startOffset, type, this._language));
  }
  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {
    const nestedModeId = embeddedModeData.modeId;
    const embeddedModeState = embeddedModeData.state;
    const nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
    if (!nestedModeTokenizationSupport) {
      this.enterMode(offsetDelta, nestedModeId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);
    this._tokens = this._tokens.concat(nestedResult.tokens);
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
    this._language = null;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult(this._tokens, endState);
  }
};
var MonarchModernTokensCollector = class {
  constructor(modeService, theme) {
    this._modeService = modeService;
    this._theme = theme;
    this._prependTokens = null;
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
  }
  enterMode(startOffset, modeId) {
    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;
  }
  emit(startOffset, type) {
    let metadata = this._theme.match(this._currentLanguageId, type);
    if (this._lastTokenMetadata === metadata) {
      return;
    }
    this._lastTokenMetadata = metadata;
    this._tokens.push(startOffset);
    this._tokens.push(metadata);
  }
  static _merge(a, b, c) {
    let aLen = a !== null ? a.length : 0;
    let bLen = b.length;
    let cLen = c !== null ? c.length : 0;
    if (aLen === 0 && bLen === 0 && cLen === 0) {
      return new Uint32Array(0);
    }
    if (aLen === 0 && bLen === 0) {
      return c;
    }
    if (bLen === 0 && cLen === 0) {
      return a;
    }
    let result = new Uint32Array(aLen + bLen + cLen);
    if (a !== null) {
      result.set(a);
    }
    for (let i = 0; i < bLen; i++) {
      result[aLen + i] = b[i];
    }
    if (c !== null) {
      result.set(c, aLen + bLen);
    }
    return result;
  }
  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {
    const nestedModeId = embeddedModeData.modeId;
    const embeddedModeState = embeddedModeData.state;
    const nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
    if (!nestedModeTokenizationSupport) {
      this.enterMode(offsetDelta, nestedModeId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);
    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
  }
};
var MonarchTokenizer = class {
  constructor(modeService, standaloneThemeService, modeId, lexer) {
    this._modeService = modeService;
    this._standaloneThemeService = standaloneThemeService;
    this._modeId = modeId;
    this._lexer = lexer;
    this._embeddedModes = Object.create(null);
    this.embeddedLoaded = Promise.resolve(void 0);
    let emitting = false;
    this._tokenizationRegistryListener = TokenizationRegistry.onDidChange((e) => {
      if (emitting) {
        return;
      }
      let isOneOfMyEmbeddedModes = false;
      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {
        let language = e.changedLanguages[i];
        if (this._embeddedModes[language]) {
          isOneOfMyEmbeddedModes = true;
          break;
        }
      }
      if (isOneOfMyEmbeddedModes) {
        emitting = true;
        TokenizationRegistry.fire([this._modeId]);
        emitting = false;
      }
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    let promises = [];
    for (let nestedModeId in this._embeddedModes) {
      const tokenizationSupport = TokenizationRegistry.get(nestedModeId);
      if (tokenizationSupport) {
        if (tokenizationSupport instanceof MonarchTokenizer) {
          const nestedModeStatus = tokenizationSupport.getLoadStatus();
          if (nestedModeStatus.loaded === false) {
            promises.push(nestedModeStatus.promise);
          }
        }
        continue;
      }
      const tokenizationSupportPromise = TokenizationRegistry.getPromise(nestedModeId);
      if (tokenizationSupportPromise) {
        promises.push(tokenizationSupportPromise);
      }
    }
    if (promises.length === 0) {
      return {
        loaded: true
      };
    }
    return {
      loaded: false,
      promise: Promise.all(promises).then((_) => void 0)
    };
  }
  getInitialState() {
    let rootState = MonarchStackElementFactory.create(null, this._lexer.start);
    return MonarchLineStateFactory.create(rootState, null);
  }
  tokenize(line, hasEOL, lineState, offsetDelta) {
    let tokensCollector = new MonarchClassicTokensCollector();
    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  tokenize2(line, hasEOL, lineState, offsetDelta) {
    let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);
    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  _tokenize(line, hasEOL, lineState, offsetDelta, collector) {
    if (lineState.embeddedModeData) {
      return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);
    } else {
      return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);
    }
  }
  _findLeavingNestedModeOffset(line, state) {
    let rules = this._lexer.tokenizer[state.stack.state];
    if (!rules) {
      rules = findRules(this._lexer, state.stack.state);
      if (!rules) {
        throw createError(this._lexer, "tokenizer state is not defined: " + state.stack.state);
      }
    }
    let popOffset = -1;
    let hasEmbeddedPopRule = false;
    for (const rule of rules) {
      if (!isIAction(rule.action) || rule.action.nextEmbedded !== "@pop") {
        continue;
      }
      hasEmbeddedPopRule = true;
      let regex = rule.regex;
      let regexSource = rule.regex.source;
      if (regexSource.substr(0, 4) === "^(?:" && regexSource.substr(regexSource.length - 1, 1) === ")") {
        let flags = (regex.ignoreCase ? "i" : "") + (regex.unicode ? "u" : "");
        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);
      }
      let result = line.search(regex);
      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {
        continue;
      }
      if (popOffset === -1 || result < popOffset) {
        popOffset = result;
      }
    }
    if (!hasEmbeddedPopRule) {
      throw createError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
    }
    return popOffset;
  }
  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {
    let popOffset = this._findLeavingNestedModeOffset(line, lineState);
    if (popOffset === -1) {
      let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);
      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));
    }
    let nestedModeLine = line.substring(0, popOffset);
    if (nestedModeLine.length > 0) {
      tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);
    }
    let restOfTheLine = line.substring(popOffset);
    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);
  }
  _safeRuleName(rule) {
    if (rule) {
      return rule.name;
    }
    return "(unknown)";
  }
  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {
    tokensCollector.enterMode(offsetDelta, this._modeId);
    const lineWithoutLFLength = lineWithoutLF.length;
    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + "\n" : lineWithoutLF;
    const lineLength = line.length;
    let embeddedModeData = lineState.embeddedModeData;
    let stack = lineState.stack;
    let pos = 0;
    let groupMatching = null;
    let forceEvaluation = true;
    while (forceEvaluation || pos < lineLength) {
      const pos0 = pos;
      const stackLen0 = stack.depth;
      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;
      const state = stack.state;
      let matches = null;
      let matched = null;
      let action = null;
      let rule = null;
      let enteringEmbeddedMode = null;
      if (groupMatching) {
        matches = groupMatching.matches;
        const groupEntry = groupMatching.groups.shift();
        matched = groupEntry.matched;
        action = groupEntry.action;
        rule = groupMatching.rule;
        if (groupMatching.groups.length === 0) {
          groupMatching = null;
        }
      } else {
        if (!forceEvaluation && pos >= lineLength) {
          break;
        }
        forceEvaluation = false;
        let rules = this._lexer.tokenizer[state];
        if (!rules) {
          rules = findRules(this._lexer, state);
          if (!rules) {
            throw createError(this._lexer, "tokenizer state is not defined: " + state);
          }
        }
        let restOfLine = line.substr(pos);
        for (const rule2 of rules) {
          if (pos === 0 || !rule2.matchOnlyAtLineStart) {
            matches = restOfLine.match(rule2.regex);
            if (matches) {
              matched = matches[0];
              action = rule2.action;
              break;
            }
          }
        }
      }
      if (!matches) {
        matches = [""];
        matched = "";
      }
      if (!action) {
        if (pos < lineLength) {
          matches = [line.charAt(pos)];
          matched = matches[0];
        }
        action = this._lexer.defaultToken;
      }
      if (matched === null) {
        break;
      }
      pos += matched.length;
      while (isFuzzyAction(action) && isIAction(action) && action.test) {
        action = action.test(matched, matches, state, pos === lineLength);
      }
      let result = null;
      if (typeof action === "string" || Array.isArray(action)) {
        result = action;
      } else if (action.group) {
        result = action.group;
      } else if (action.token !== null && action.token !== void 0) {
        if (action.tokenSubst) {
          result = substituteMatches(this._lexer, action.token, matched, matches, state);
        } else {
          result = action.token;
        }
        if (action.nextEmbedded) {
          if (action.nextEmbedded === "@pop") {
            if (!embeddedModeData) {
              throw createError(this._lexer, "cannot pop embedded mode if not inside one");
            }
            embeddedModeData = null;
          } else if (embeddedModeData) {
            throw createError(this._lexer, "cannot enter embedded mode from within an embedded mode");
          } else {
            enteringEmbeddedMode = substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
          }
        }
        if (action.goBack) {
          pos = Math.max(0, pos - action.goBack);
        }
        if (action.switchTo && typeof action.switchTo === "string") {
          let nextState = substituteMatches(this._lexer, action.switchTo, matched, matches, state);
          if (nextState[0] === "@") {
            nextState = nextState.substr(1);
          }
          if (!findRules(this._lexer, nextState)) {
            throw createError(this._lexer, "trying to switch to a state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
          } else {
            stack = stack.switchTo(nextState);
          }
        } else if (action.transform && typeof action.transform === "function") {
          throw createError(this._lexer, "action.transform not supported");
        } else if (action.next) {
          if (action.next === "@push") {
            if (stack.depth >= this._lexer.maxStack) {
              throw createError(this._lexer, "maximum tokenizer stack size reached: [" + stack.state + "," + stack.parent.state + ",...]");
            } else {
              stack = stack.push(state);
            }
          } else if (action.next === "@pop") {
            if (stack.depth <= 1) {
              throw createError(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.pop();
            }
          } else if (action.next === "@popall") {
            stack = stack.popall();
          } else {
            let nextState = substituteMatches(this._lexer, action.next, matched, matches, state);
            if (nextState[0] === "@") {
              nextState = nextState.substr(1);
            }
            if (!findRules(this._lexer, nextState)) {
              throw createError(this._lexer, "trying to set a next state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.push(nextState);
            }
          }
        }
        if (action.log && typeof action.log === "string") {
          log(this._lexer, this._lexer.languageId + ": " + substituteMatches(this._lexer, action.log, matched, matches, state));
        }
      }
      if (result === null) {
        throw createError(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(rule));
      }
      const computeNewStateForEmbeddedMode = (enteringEmbeddedMode2) => {
        let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode2);
        if (enteringEmbeddedModeId) {
          enteringEmbeddedMode2 = enteringEmbeddedModeId;
        }
        const embeddedModeData2 = this._getNestedEmbeddedModeData(enteringEmbeddedMode2);
        if (pos < lineLength) {
          const restOfLine = lineWithoutLF.substr(pos);
          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData2), offsetDelta + pos, tokensCollector);
        } else {
          return MonarchLineStateFactory.create(stack, embeddedModeData2);
        }
      };
      if (Array.isArray(result)) {
        if (groupMatching && groupMatching.groups.length > 0) {
          throw createError(this._lexer, "groups cannot be nested: " + this._safeRuleName(rule));
        }
        if (matches.length !== result.length + 1) {
          throw createError(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(rule));
        }
        let totalLen = 0;
        for (let i = 1; i < matches.length; i++) {
          totalLen += matches[i].length;
        }
        if (totalLen !== matched.length) {
          throw createError(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(rule));
        }
        groupMatching = {
          rule,
          matches,
          groups: []
        };
        for (let i = 0; i < result.length; i++) {
          groupMatching.groups[i] = {
            action: result[i],
            matched: matches[i + 1]
          };
        }
        pos -= matched.length;
        continue;
      } else {
        if (result === "@rematch") {
          pos -= matched.length;
          matched = "";
          matches = null;
          result = "";
          if (enteringEmbeddedMode !== null) {
            return computeNewStateForEmbeddedMode(enteringEmbeddedMode);
          }
        }
        if (matched.length === 0) {
          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {
            continue;
          } else {
            throw createError(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(rule));
          }
        }
        let tokenType = null;
        if (isString(result) && result.indexOf("@brackets") === 0) {
          let rest = result.substr("@brackets".length);
          let bracket = findBracket(this._lexer, matched);
          if (!bracket) {
            throw createError(this._lexer, "@brackets token returned but no bracket defined as: " + matched);
          }
          tokenType = sanitize(bracket.token + rest);
        } else {
          let token = result === "" ? "" : result + this._lexer.tokenPostfix;
          tokenType = sanitize(token);
        }
        if (pos0 < lineWithoutLFLength) {
          tokensCollector.emit(pos0 + offsetDelta, tokenType);
        }
      }
      if (enteringEmbeddedMode !== null) {
        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);
      }
    }
    return MonarchLineStateFactory.create(stack, embeddedModeData);
  }
  _getNestedEmbeddedModeData(mimetypeOrModeId) {
    let nestedModeId = this._locateMode(mimetypeOrModeId);
    if (nestedModeId) {
      let tokenizationSupport = TokenizationRegistry.get(nestedModeId);
      if (tokenizationSupport) {
        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());
      }
    }
    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);
  }
  _locateMode(mimetypeOrModeId) {
    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {
      return null;
    }
    if (mimetypeOrModeId === this._modeId) {
      return mimetypeOrModeId;
    }
    let modeId = this._modeService.getModeId(mimetypeOrModeId);
    if (modeId) {
      this._modeService.triggerMode(modeId);
      this._embeddedModes[modeId] = true;
    }
    return modeId;
  }
};
function findBracket(lexer, matched) {
  if (!matched) {
    return null;
  }
  matched = fixCase(lexer, matched);
  let brackets = lexer.brackets;
  for (const bracket of brackets) {
    if (bracket.open === matched) {
      return { token: bracket.token, bracketType: 1 };
    } else if (bracket.close === matched) {
      return { token: bracket.token, bracketType: -1 };
    }
  }
  return null;
}
function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {
  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js
var _a2;
var ttPolicy2 = (_a2 = window.trustedTypes) === null || _a2 === void 0 ? void 0 : _a2.createPolicy("standaloneColorizer", { createHTML: (value) => value });
var Colorizer = class {
  static colorizeElement(themeService, modeService, domNode, options) {
    options = options || {};
    let theme = options.theme || "vs";
    let mimeType = options.mimeType || domNode.getAttribute("lang") || domNode.getAttribute("data-lang");
    if (!mimeType) {
      console.error("Mode not detected");
      return Promise.resolve();
    }
    themeService.setTheme(theme);
    let text = domNode.firstChild ? domNode.firstChild.nodeValue : "";
    domNode.className += " " + theme;
    let render = (str) => {
      var _a6;
      const trustedhtml = (_a6 = ttPolicy2 === null || ttPolicy2 === void 0 ? void 0 : ttPolicy2.createHTML(str)) !== null && _a6 !== void 0 ? _a6 : str;
      domNode.innerHTML = trustedhtml;
    };
    return this.colorize(modeService, text || "", mimeType, options).then(render, (err) => console.error(err));
  }
  static colorize(modeService, text, mimeType, options) {
    let tabSize = 4;
    if (options && typeof options.tabSize === "number") {
      tabSize = options.tabSize;
    }
    if (startsWithUTF8BOM(text)) {
      text = text.substr(1);
    }
    let lines = splitLines(text);
    let language = modeService.getModeId(mimeType);
    if (!language) {
      return Promise.resolve(_fakeColorize(lines, tabSize));
    }
    modeService.triggerMode(language);
    const tokenizationSupport = TokenizationRegistry.get(language);
    if (tokenizationSupport) {
      return _colorize(lines, tabSize, tokenizationSupport);
    }
    const tokenizationSupportPromise = TokenizationRegistry.getPromise(language);
    if (tokenizationSupportPromise) {
      return new Promise((resolve, reject) => {
        tokenizationSupportPromise.then((tokenizationSupport2) => {
          _colorize(lines, tabSize, tokenizationSupport2).then(resolve, reject);
        }, reject);
      });
    }
    return new Promise((resolve, reject) => {
      let listener = null;
      let timeout2 = null;
      const execute = () => {
        if (listener) {
          listener.dispose();
          listener = null;
        }
        if (timeout2) {
          timeout2.dispose();
          timeout2 = null;
        }
        const tokenizationSupport2 = TokenizationRegistry.get(language);
        if (tokenizationSupport2) {
          _colorize(lines, tabSize, tokenizationSupport2).then(resolve, reject);
          return;
        }
        resolve(_fakeColorize(lines, tabSize));
      };
      timeout2 = new TimeoutTimer();
      timeout2.cancelAndSet(execute, 500);
      listener = TokenizationRegistry.onDidChange((e) => {
        if (e.changedLanguages.indexOf(language) >= 0) {
          execute();
        }
      });
    });
  }
  static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
    const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
    const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, mightContainRTL);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    return renderResult.html;
  }
  static colorizeModelLine(model, lineNumber, tabSize = 4) {
    let content = model.getLineContent(lineNumber);
    model.forceTokenization(lineNumber);
    let tokens = model.getLineTokens(lineNumber);
    let inflatedTokens = tokens.inflate();
    return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);
  }
};
function _colorize(lines, tabSize, tokenizationSupport) {
  return new Promise((c, e) => {
    const execute = () => {
      const result = _actualColorize(lines, tabSize, tokenizationSupport);
      if (tokenizationSupport instanceof MonarchTokenizer) {
        const status2 = tokenizationSupport.getLoadStatus();
        if (status2.loaded === false) {
          status2.promise.then(execute, e);
          return;
        }
      }
      c(result);
    };
    execute();
  });
}
function _fakeColorize(lines, tabSize) {
  let html = [];
  const defaultMetadata = (0 << 11 | 1 << 14 | 2 << 23) >>> 0;
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = defaultMetadata;
  for (let i = 0, length = lines.length; i < length; i++) {
    let line = lines[i];
    tokens[0] = line.length;
    const lineTokens = new LineTokens(tokens, line);
    const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, true);
    const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, true);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
  }
  return html.join("");
}
function _actualColorize(lines, tabSize, tokenizationSupport) {
  let html = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, length = lines.length; i < length; i++) {
    let line = lines[i];
    let tokenizeResult = tokenizationSupport.tokenize2(line, true, state, 0);
    LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
    let lineTokens = new LineTokens(tokenizeResult.tokens, line);
    const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, true);
    const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, true);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
    state = tokenizeResult.endState;
  }
  return html.join("");
}

// node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js
function isCodeEditor(thing) {
  if (thing && typeof thing.getEditorType === "function") {
    return thing.getEditorType() === EditorType.ICodeEditor;
  } else {
    return false;
  }
}

// node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js
var IBulkEditService = createDecorator("IWorkspaceEditService");
function isWorkspaceFileEdit(thing) {
  return isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));
}
function isWorkspaceTextEdit(thing) {
  return isObject(thing) && URI.isUri(thing.resource) && isObject(thing.edit);
}
var ResourceEdit = class {
  constructor(metadata) {
    this.metadata = metadata;
  }
  static convert(edit) {
    return edit.edits.map((edit2) => {
      if (isWorkspaceTextEdit(edit2)) {
        return new ResourceTextEdit(edit2.resource, edit2.edit, edit2.modelVersionId, edit2.metadata);
      }
      if (isWorkspaceFileEdit(edit2)) {
        return new ResourceFileEdit(edit2.oldUri, edit2.newUri, edit2.options, edit2.metadata);
      }
      throw new Error("Unsupported edit");
    });
  }
};
var ResourceTextEdit = class extends ResourceEdit {
  constructor(resource, textEdit, versionId, metadata) {
    super(metadata);
    this.resource = resource;
    this.textEdit = textEdit;
    this.versionId = versionId;
  }
};
var ResourceFileEdit = class extends ResourceEdit {
  constructor(oldResource, newResource, options, metadata) {
    super(metadata);
    this.oldResource = oldResource;
    this.newResource = newResource;
    this.options = options;
  }
};

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationModels.js
var ConfigurationModel = class {
  constructor(_contents = {}, _keys = [], _overrides = []) {
    this._contents = _contents;
    this._keys = _keys;
    this._overrides = _overrides;
    this.isFrozen = false;
  }
  get contents() {
    return this.checkAndFreeze(this._contents);
  }
  get overrides() {
    return this.checkAndFreeze(this._overrides);
  }
  get keys() {
    return this.checkAndFreeze(this._keys);
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(section) {
    return section ? getConfigurationValue(this.contents, section) : this.contents;
  }
  override(identifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(identifier);
    if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
      return this;
    }
    let contents = {};
    for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
      let contentsForKey = this.contents[key];
      let overrideContentsForKey = overrideContents[key];
      if (overrideContentsForKey) {
        if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
          contentsForKey = deepClone(contentsForKey);
          this.mergeContents(contentsForKey, overrideContentsForKey);
        } else {
          contentsForKey = overrideContentsForKey;
        }
      }
      contents[key] = contentsForKey;
    }
    return new ConfigurationModel(contents, this.keys, this.overrides);
  }
  merge(...others) {
    const contents = deepClone(this.contents);
    const overrides = deepClone(this.overrides);
    const keys = [...this.keys];
    for (const other of others) {
      this.mergeContents(contents, other.contents);
      for (const otherOverride of other.overrides) {
        const [override] = overrides.filter((o) => equals2(o.identifiers, otherOverride.identifiers));
        if (override) {
          this.mergeContents(override.contents, otherOverride.contents);
        } else {
          overrides.push(deepClone(otherOverride));
        }
      }
      for (const key of other.keys) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        }
      }
    }
    return new ConfigurationModel(contents, keys, overrides);
  }
  freeze() {
    this.isFrozen = true;
    return this;
  }
  mergeContents(source, target) {
    for (const key of Object.keys(target)) {
      if (key in source) {
        if (isObject(source[key]) && isObject(target[key])) {
          this.mergeContents(source[key], target[key]);
          continue;
        }
      }
      source[key] = deepClone(target[key]);
    }
  }
  checkAndFreeze(data) {
    if (this.isFrozen && !Object.isFrozen(data)) {
      return deepFreeze(data);
    }
    return data;
  }
  getContentsForOverrideIdentifer(identifier) {
    for (const override of this.overrides) {
      if (override.identifiers.indexOf(identifier) !== -1) {
        return override.contents;
      }
    }
    return null;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(key, value) {
    this.addKey(key);
    addToValueTree(this.contents, key, value, (e) => {
      throw new Error(e);
    });
  }
  removeValue(key) {
    if (this.removeKey(key)) {
      removeFromValueTree(this.contents, key);
    }
  }
  addKey(key) {
    let index = this.keys.length;
    for (let i = 0; i < index; i++) {
      if (key.indexOf(this.keys[i]) === 0) {
        index = i;
      }
    }
    this.keys.splice(index, 1, key);
  }
  removeKey(key) {
    let index = this.keys.indexOf(key);
    if (index !== -1) {
      this.keys.splice(index, 1);
      return true;
    }
    return false;
  }
};
var DefaultConfigurationModel = class extends ConfigurationModel {
  constructor() {
    const contents = getDefaultValues();
    const keys = getConfigurationKeys();
    const overrides = [];
    for (const key of Object.keys(contents)) {
      if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
        overrides.push({
          identifiers: [overrideIdentifierFromKey(key).trim()],
          keys: Object.keys(contents[key]),
          contents: toValuesTree(contents[key], (message) => console.error(`Conflict in default settings file: ${message}`))
        });
      }
    }
    super(contents, keys, overrides);
  }
};
var Configuration2 = class {
  constructor(_defaultConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap(), _freeze = true) {
    this._defaultConfiguration = _defaultConfiguration;
    this._localUserConfiguration = _localUserConfiguration;
    this._remoteUserConfiguration = _remoteUserConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._folderConfigurations = _folderConfigurations;
    this._memoryConfiguration = _memoryConfiguration;
    this._memoryConfigurationByResource = _memoryConfigurationByResource;
    this._freeze = _freeze;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations = new ResourceMap();
    this._userConfiguration = null;
  }
  getValue(section, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
    return consolidateConfigurationModel.getValue(section);
  }
  updateValue(key, value, overrides = {}) {
    let memoryConfiguration;
    if (overrides.resource) {
      memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
      if (!memoryConfiguration) {
        memoryConfiguration = new ConfigurationModel();
        this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
      }
    } else {
      memoryConfiguration = this._memoryConfiguration;
    }
    if (value === void 0) {
      memoryConfiguration.removeValue(key);
    } else {
      memoryConfiguration.setValue(key, value);
    }
    if (!overrides.resource) {
      this._workspaceConsolidatedConfiguration = null;
    }
  }
  get userConfiguration() {
    if (!this._userConfiguration) {
      this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);
      if (this._freeze) {
        this._userConfiguration.freeze();
      }
    }
    return this._userConfiguration;
  }
  getConsolidateConfigurationModel(overrides, workspace) {
    let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
    return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
  }
  getConsolidatedConfigurationModelForResource({ resource }, workspace) {
    let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
      }
      const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
      if (memoryConfigurationForResource) {
        consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
      }
    }
    return consolidateConfiguration;
  }
  getWorkspaceConsolidatedConfiguration() {
    if (!this._workspaceConsolidatedConfiguration) {
      this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
      if (this._freeze) {
        this._workspaceConfiguration = this._workspaceConfiguration.freeze();
      }
    }
    return this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(folder) {
    let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
    if (!folderConsolidatedConfiguration) {
      const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
      const folderConfiguration = this._folderConfigurations.get(folder);
      if (folderConfiguration) {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
        if (this._freeze) {
          folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
        }
        this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
      } else {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
      }
    }
    return folderConsolidatedConfiguration;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {
        const { contents, overrides, keys } = this._folderConfigurations.get(folder);
        result.push([folder, { contents, overrides, keys }]);
        return result;
      }, [])
    };
  }
  static parse(data) {
    const defaultConfiguration = this.parseConfigurationModel(data.defaults);
    const userConfiguration = this.parseConfigurationModel(data.user);
    const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
    const folders = data.folders.reduce((result, value) => {
      result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1]));
      return result;
    }, new ResourceMap());
    return new Configuration2(defaultConfiguration, userConfiguration, new ConfigurationModel(), workspaceConfiguration, folders, new ConfigurationModel(), new ResourceMap(), false);
  }
  static parseConfigurationModel(model) {
    return new ConfigurationModel(model.contents, model.keys, model.overrides).freeze();
  }
};
var ConfigurationChangeEvent = class {
  constructor(change, previous, currentConfiguraiton, currentWorkspace) {
    this.change = change;
    this.previous = previous;
    this.currentConfiguraiton = currentConfiguraiton;
    this.currentWorkspace = currentWorkspace;
    this._previousConfiguration = void 0;
    const keysSet = new Set();
    change.keys.forEach((key) => keysSet.add(key));
    change.overrides.forEach(([, keys]) => keys.forEach((key) => keysSet.add(key)));
    this.affectedKeys = [...keysSet.values()];
    const configurationModel = new ConfigurationModel();
    this.affectedKeys.forEach((key) => configurationModel.setValue(key, {}));
    this.affectedKeysTree = configurationModel.contents;
  }
  get previousConfiguration() {
    if (!this._previousConfiguration && this.previous) {
      this._previousConfiguration = Configuration2.parse(this.previous.data);
    }
    return this._previousConfiguration;
  }
  affectsConfiguration(section, overrides) {
    var _a6;
    if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section)) {
      if (overrides) {
        const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, (_a6 = this.previous) === null || _a6 === void 0 ? void 0 : _a6.workspace) : void 0;
        const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
        return !equals(value1, value2);
      }
      return true;
    }
    return false;
  }
  doesAffectedKeysTreeContains(affectedKeysTree, section) {
    let requestedTree = toValuesTree({ [section]: true }, () => {
    });
    let key;
    while (typeof requestedTree === "object" && (key = Object.keys(requestedTree)[0])) {
      affectedKeysTree = affectedKeysTree[key];
      if (!affectedKeysTree) {
        return false;
      }
      requestedTree = requestedTree[key];
    }
    return true;
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
var AbstractKeybindingService = class extends Disposable {
  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._commandService = _commandService;
    this._telemetryService = _telemetryService;
    this._notificationService = _notificationService;
    this._logService = _logService;
    this._onDidUpdateKeybindings = this._register(new Emitter());
    this._currentChord = null;
    this._currentChordChecker = new IntervalTimer();
    this._currentChordStatusMessage = null;
    this._currentSingleModifier = null;
    this._currentSingleModifierClearTimeout = new TimeoutTimer();
    this._logging = false;
  }
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None;
  }
  dispose() {
    super.dispose();
  }
  _log(str) {
    if (this._logging) {
      this._logService.info(`[KeybindingService]: ${str}`);
    }
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(commandId, context) {
    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);
    if (!result) {
      return void 0;
    }
    return result.resolvedKeybinding;
  }
  dispatchEvent(e, target) {
    return this._dispatch(e, target);
  }
  softDispatch(e, target) {
    const keybinding = this.resolveKeyboardEvent(e);
    if (keybinding.isChord()) {
      console.warn("Unexpected keyboard event mapped to a chord");
      return null;
    }
    const [firstPart] = keybinding.getDispatchParts();
    if (firstPart === null) {
      return null;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const currentChord = this._currentChord ? this._currentChord.keypress : null;
    return this._getResolver().resolve(contextValue, currentChord, firstPart);
  }
  _enterChordMode(firstPart, keypressLabel) {
    this._currentChord = {
      keypress: firstPart,
      label: keypressLabel
    };
    this._currentChordStatusMessage = this._notificationService.status(localize("first.chord", "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
    const chordEnterTime = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      if (Date.now() - chordEnterTime > 5e3) {
        this._leaveChordMode();
      }
    }, 500);
  }
  _leaveChordMode() {
    if (this._currentChordStatusMessage) {
      this._currentChordStatusMessage.dispose();
      this._currentChordStatusMessage = null;
    }
    this._currentChordChecker.cancel();
    this._currentChord = null;
  }
  _dispatch(e, target) {
    return this._doDispatch(this.resolveKeyboardEvent(e), target, false);
  }
  _singleModifierDispatch(e, target) {
    const keybinding = this.resolveKeyboardEvent(e);
    const [singleModifier] = keybinding.getSingleModifierDispatchParts();
    if (singleModifier !== null && this._currentSingleModifier === null) {
      this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);
      this._currentSingleModifier = singleModifier;
      this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log(`+ Clearing single modifier due to 300ms elapsed.`);
        this._currentSingleModifier = null;
      }, 300);
      return false;
    }
    if (singleModifier !== null && singleModifier === this._currentSingleModifier) {
      this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);
      this._currentSingleModifierClearTimeout.cancel();
      this._currentSingleModifier = null;
      return this._doDispatch(keybinding, target, true);
    }
    this._currentSingleModifierClearTimeout.cancel();
    this._currentSingleModifier = null;
    return false;
  }
  _doDispatch(keybinding, target, isSingleModiferChord = false) {
    let shouldPreventDefault = false;
    if (keybinding.isChord()) {
      console.warn("Unexpected keyboard event mapped to a chord");
      return false;
    }
    let firstPart = null;
    let currentChord = null;
    if (isSingleModiferChord) {
      const [dispatchKeyname] = keybinding.getSingleModifierDispatchParts();
      firstPart = dispatchKeyname;
      currentChord = dispatchKeyname;
    } else {
      [firstPart] = keybinding.getDispatchParts();
      currentChord = this._currentChord ? this._currentChord.keypress : null;
    }
    if (firstPart === null) {
      this._log(`\\ Keyboard event cannot be dispatched in keydown phase.`);
      return shouldPreventDefault;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const keypressLabel = keybinding.getLabel();
    const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);
    this._logService.trace("KeybindingService#dispatch", keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);
    if (resolveResult && resolveResult.enterChord) {
      shouldPreventDefault = true;
      this._enterChordMode(firstPart, keypressLabel);
      return shouldPreventDefault;
    }
    if (this._currentChord) {
      if (!resolveResult || !resolveResult.commandId) {
        this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, keypressLabel), { hideAfter: 10 * 1e3 });
        shouldPreventDefault = true;
      }
    }
    this._leaveChordMode();
    if (resolveResult && resolveResult.commandId) {
      if (!resolveResult.bubble) {
        shouldPreventDefault = true;
      }
      if (typeof resolveResult.commandArgs === "undefined") {
        this._commandService.executeCommand(resolveResult.commandId).then(void 0, (err) => this._notificationService.warn(err));
      } else {
        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(void 0, (err) => this._notificationService.warn(err));
      }
      this._telemetryService.publicLog2("workbenchActionExecuted", { id: resolveResult.commandId, from: "keybinding" });
    }
    return shouldPreventDefault;
  }
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey) {
      return false;
    }
    if (event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30) {
      return true;
    }
    return false;
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js
var KeybindingResolver = class {
  constructor(defaultKeybindings, overrides, log2) {
    this._log = log2;
    this._defaultKeybindings = defaultKeybindings;
    this._defaultBoundCommands = new Map();
    for (let i = 0, len = defaultKeybindings.length; i < len; i++) {
      const command = defaultKeybindings[i].command;
      if (command) {
        this._defaultBoundCommands.set(command, true);
      }
    }
    this._map = new Map();
    this._lookupMap = new Map();
    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);
    for (let i = 0, len = this._keybindings.length; i < len; i++) {
      let k = this._keybindings[i];
      if (k.keypressParts.length === 0) {
        continue;
      }
      if (k.when && k.when.type === 0) {
        continue;
      }
      this._addKeyPress(k.keypressParts[0], k);
    }
  }
  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {
    if (defaultKb.command !== command) {
      return false;
    }
    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {
      return false;
    }
    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {
      return false;
    }
    if (when) {
      if (!defaultKb.when) {
        return false;
      }
      if (!when.equals(defaultKb.when)) {
        return false;
      }
    }
    return true;
  }
  static combine(defaults, rawOverrides) {
    defaults = defaults.slice(0);
    let overrides = [];
    for (const override of rawOverrides) {
      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== "-") {
        overrides.push(override);
        continue;
      }
      const command = override.command.substr(1);
      const keypressFirstPart = override.keypressParts[0];
      const keypressChordPart = override.keypressParts[1];
      const when = override.when;
      for (let j = defaults.length - 1; j >= 0; j--) {
        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {
          defaults.splice(j, 1);
        }
      }
    }
    return defaults.concat(overrides);
  }
  _addKeyPress(keypress, item) {
    const conflicts = this._map.get(keypress);
    if (typeof conflicts === "undefined") {
      this._map.set(keypress, [item]);
      this._addToLookupMap(item);
      return;
    }
    for (let i = conflicts.length - 1; i >= 0; i--) {
      let conflict = conflicts[i];
      if (conflict.command === item.command) {
        continue;
      }
      const conflictIsChord = conflict.keypressParts.length > 1;
      const itemIsChord = item.keypressParts.length > 1;
      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {
        continue;
      }
      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {
        this._removeFromLookupMap(conflict);
      }
    }
    conflicts.push(item);
    this._addToLookupMap(item);
  }
  _addToLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      arr = [item];
      this._lookupMap.set(item.command, arr);
    } else {
      arr.push(item);
    }
  }
  _removeFromLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      return;
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] === item) {
        arr.splice(i, 1);
        return;
      }
    }
  }
  static whenIsEntirelyIncluded(a, b) {
    if (!b || b.type === 1) {
      return true;
    }
    if (!a || a.type === 1) {
      return false;
    }
    return this._implies(a, b);
  }
  static _implies(p, q) {
    const notP = p.negate();
    const terminals = (node) => {
      if (node.type === 9) {
        return node.expr;
      }
      return [node];
    };
    let expr = terminals(notP).concat(terminals(q));
    for (let i = 0; i < expr.length; i++) {
      const a = expr[i];
      const notA = a.negate();
      for (let j = i + 1; j < expr.length; j++) {
        const b = expr[j];
        if (notA.equals(b)) {
          return true;
        }
      }
    }
    return false;
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(commandId, context) {
    const items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return null;
    }
    if (items.length === 1) {
      return items[0];
    }
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      if (context.contextMatchesRules(item.when)) {
        return item;
      }
    }
    return items[items.length - 1];
  }
  resolve(context, currentChord, keypress) {
    this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);
    let lookupMap = null;
    if (currentChord !== null) {
      const candidates = this._map.get(currentChord);
      if (typeof candidates === "undefined") {
        this._log(`\\ No keybinding entries.`);
        return null;
      }
      lookupMap = [];
      for (let i = 0, len = candidates.length; i < len; i++) {
        let candidate = candidates[i];
        if (candidate.keypressParts[1] === keypress) {
          lookupMap.push(candidate);
        }
      }
    } else {
      const candidates = this._map.get(keypress);
      if (typeof candidates === "undefined") {
        this._log(`\\ No keybinding entries.`);
        return null;
      }
      lookupMap = candidates;
    }
    let result = this._findCommand(context, lookupMap);
    if (!result) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);
      return null;
    }
    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
      return {
        enterChord: true,
        leaveChord: false,
        commandId: null,
        commandArgs: null,
        bubble: false
      };
    }
    this._log(`\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
    return {
      enterChord: false,
      leaveChord: result.keypressParts.length > 1,
      commandId: result.command,
      commandArgs: result.commandArgs,
      bubble: result.bubble
    };
  }
  _findCommand(context, matches) {
    for (let i = matches.length - 1; i >= 0; i--) {
      let k = matches[i];
      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {
        continue;
      }
      return k;
    }
    return null;
  }
  static contextMatchesRules(context, rules) {
    if (!rules) {
      return true;
    }
    return rules.evaluate(context);
  }
};
function printWhenExplanation(when) {
  if (!when) {
    return `no when condition`;
  }
  return `${when.serialize()}`;
}
function printSourceExplanation(kb) {
  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js
var ResolvedKeybindingItem = class {
  constructor(resolvedKeybinding, command, commandArgs, when, isDefault, extensionId, isBuiltinExtension) {
    this._resolvedKeybindingItemBrand = void 0;
    this.resolvedKeybinding = resolvedKeybinding;
    this.keypressParts = resolvedKeybinding ? removeElementsAfterNulls(resolvedKeybinding.getDispatchParts()) : [];
    if (resolvedKeybinding && this.keypressParts.length === 0) {
      this.keypressParts = removeElementsAfterNulls(resolvedKeybinding.getSingleModifierDispatchParts());
    }
    this.bubble = command ? command.charCodeAt(0) === 94 : false;
    this.command = this.bubble ? command.substr(1) : command;
    this.commandArgs = commandArgs;
    this.when = when;
    this.isDefault = isDefault;
    this.extensionId = extensionId;
    this.isBuiltinExtension = isBuiltinExtension;
  }
};
function removeElementsAfterNulls(arr) {
  let result = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    const element = arr[i];
    if (!element) {
      return result;
    }
    result.push(element);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js
var BaseResolvedKeybinding = class extends ResolvedKeybinding {
  constructor(os, parts) {
    super();
    if (parts.length === 0) {
      throw illegalArgument(`parts`);
    }
    this._os = os;
    this._parts = parts;
  }
  getLabel() {
    return UILabelProvider.toLabel(this._os, this._parts, (keybinding) => this._getLabel(keybinding));
  }
  getAriaLabel() {
    return AriaLabelProvider.toLabel(this._os, this._parts, (keybinding) => this._getAriaLabel(keybinding));
  }
  isChord() {
    return this._parts.length > 1;
  }
  getParts() {
    return this._parts.map((keybinding) => this._getPart(keybinding));
  }
  _getPart(keybinding) {
    return new ResolvedKeybindingPart(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getLabel(keybinding), this._getAriaLabel(keybinding));
  }
  getDispatchParts() {
    return this._parts.map((keybinding) => this._getDispatchPart(keybinding));
  }
  getSingleModifierDispatchParts() {
    return this._parts.map((keybinding) => this._getSingleModifierDispatchPart(keybinding));
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
var USLayoutResolvedKeybinding = class extends BaseResolvedKeybinding {
  constructor(actual, os) {
    super(os, actual.parts);
  }
  _keyCodeToUILabel(keyCode) {
    if (this._os === 2) {
      switch (keyCode) {
        case 15:
          return "\u2190";
        case 16:
          return "\u2191";
        case 17:
          return "\u2192";
        case 18:
          return "\u2193";
      }
    }
    return KeyCodeUtils.toString(keyCode);
  }
  _getLabel(keybinding) {
    if (keybinding.isDuplicateModifierCase()) {
      return "";
    }
    return this._keyCodeToUILabel(keybinding.keyCode);
  }
  _getAriaLabel(keybinding) {
    if (keybinding.isDuplicateModifierCase()) {
      return "";
    }
    return KeyCodeUtils.toString(keybinding.keyCode);
  }
  _getDispatchPart(keybinding) {
    return USLayoutResolvedKeybinding.getDispatchStr(keybinding);
  }
  static getDispatchStr(keybinding) {
    if (keybinding.isModifierKey()) {
      return null;
    }
    let result = "";
    if (keybinding.ctrlKey) {
      result += "ctrl+";
    }
    if (keybinding.shiftKey) {
      result += "shift+";
    }
    if (keybinding.altKey) {
      result += "alt+";
    }
    if (keybinding.metaKey) {
      result += "meta+";
    }
    result += KeyCodeUtils.toString(keybinding.keyCode);
    return result;
  }
  _getSingleModifierDispatchPart(keybinding) {
    if (keybinding.keyCode === 5 && !keybinding.shiftKey && !keybinding.altKey && !keybinding.metaKey) {
      return "ctrl";
    }
    if (keybinding.keyCode === 4 && !keybinding.ctrlKey && !keybinding.altKey && !keybinding.metaKey) {
      return "shift";
    }
    if (keybinding.keyCode === 6 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.metaKey) {
      return "alt";
    }
    if (keybinding.keyCode === 57 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.altKey) {
      return "meta";
    }
    return null;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js
var AccessibilityHelpNLS;
(function(AccessibilityHelpNLS2) {
  AccessibilityHelpNLS2.noSelection = localize("noSelection", "No selection");
  AccessibilityHelpNLS2.singleSelectionRange = localize("singleSelectionRange", "Line {0}, Column {1} ({2} selected)");
  AccessibilityHelpNLS2.singleSelection = localize("singleSelection", "Line {0}, Column {1}");
  AccessibilityHelpNLS2.multiSelectionRange = localize("multiSelectionRange", "{0} selections ({1} characters selected)");
  AccessibilityHelpNLS2.multiSelection = localize("multiSelection", "{0} selections");
  AccessibilityHelpNLS2.emergencyConfOn = localize("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'.");
  AccessibilityHelpNLS2.openingDocs = localize("openingDocs", "Now opening the Editor Accessibility documentation page.");
  AccessibilityHelpNLS2.readonlyDiffEditor = localize("readonlyDiffEditor", " in a read-only pane of a diff editor.");
  AccessibilityHelpNLS2.editableDiffEditor = localize("editableDiffEditor", " in a pane of a diff editor.");
  AccessibilityHelpNLS2.readonlyEditor = localize("readonlyEditor", " in a read-only code editor");
  AccessibilityHelpNLS2.editableEditor = localize("editableEditor", " in a code editor");
  AccessibilityHelpNLS2.changeConfigToOnMac = localize("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now.");
  AccessibilityHelpNLS2.changeConfigToOnWinLinux = localize("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now.");
  AccessibilityHelpNLS2.auto_on = localize("auto_on", "The editor is configured to be optimized for usage with a Screen Reader.");
  AccessibilityHelpNLS2.auto_off = localize("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time.");
  AccessibilityHelpNLS2.tabFocusModeOnMsg = localize("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}.");
  AccessibilityHelpNLS2.tabFocusModeOnMsgNoKb = localize("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.");
  AccessibilityHelpNLS2.tabFocusModeOffMsg = localize("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}.");
  AccessibilityHelpNLS2.tabFocusModeOffMsgNoKb = localize("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.");
  AccessibilityHelpNLS2.openDocMac = localize("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility.");
  AccessibilityHelpNLS2.openDocWinLinux = localize("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility.");
  AccessibilityHelpNLS2.outroMsg = localize("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape.");
  AccessibilityHelpNLS2.showAccessibilityHelpAction = localize("showAccessibilityHelpAction", "Show Accessibility Help");
})(AccessibilityHelpNLS || (AccessibilityHelpNLS = {}));
var InspectTokensNLS;
(function(InspectTokensNLS2) {
  InspectTokensNLS2.inspectTokensAction = localize("inspectTokens", "Developer: Inspect Tokens");
})(InspectTokensNLS || (InspectTokensNLS = {}));
var GoToLineNLS;
(function(GoToLineNLS2) {
  GoToLineNLS2.gotoLineActionLabel = localize("gotoLineActionLabel", "Go to Line/Column...");
})(GoToLineNLS || (GoToLineNLS = {}));
var QuickHelpNLS;
(function(QuickHelpNLS2) {
  QuickHelpNLS2.helpQuickAccessActionLabel = localize("helpQuickAccess", "Show all Quick Access Providers");
})(QuickHelpNLS || (QuickHelpNLS = {}));
var QuickCommandNLS;
(function(QuickCommandNLS2) {
  QuickCommandNLS2.quickCommandActionLabel = localize("quickCommandActionLabel", "Command Palette");
  QuickCommandNLS2.quickCommandHelp = localize("quickCommandActionHelp", "Show And Run Commands");
})(QuickCommandNLS || (QuickCommandNLS = {}));
var QuickOutlineNLS;
(function(QuickOutlineNLS2) {
  QuickOutlineNLS2.quickOutlineActionLabel = localize("quickOutlineActionLabel", "Go to Symbol...");
  QuickOutlineNLS2.quickOutlineByCategoryActionLabel = localize("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(QuickOutlineNLS || (QuickOutlineNLS = {}));
var StandaloneCodeEditorNLS;
(function(StandaloneCodeEditorNLS2) {
  StandaloneCodeEditorNLS2.editorViewAccessibleLabel = localize("editorViewAccessibleLabel", "Editor content");
  StandaloneCodeEditorNLS2.accessibilityHelpMessage = localize("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));
var ToggleHighContrastNLS;
(function(ToggleHighContrastNLS2) {
  ToggleHighContrastNLS2.toggleHighContrast = localize("toggleHighContrast", "Toggle High Contrast Theme");
})(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));
var SimpleServicesNLS;
(function(SimpleServicesNLS2) {
  SimpleServicesNLS2.bulkEditServiceSummary = localize("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(SimpleServicesNLS || (SimpleServicesNLS = {}));

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/simpleServices.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SimpleModel = class {
  constructor(model) {
    this.disposed = false;
    this.model = model;
    this._onWillDispose = new Emitter();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = true;
    this._onWillDispose.fire();
  }
};
function withTypedEditor(widget, codeEditorCallback, diffEditorCallback) {
  if (isCodeEditor(widget)) {
    return codeEditorCallback(widget);
  } else {
    return diffEditorCallback(widget);
  }
}
var SimpleEditorModelResolverService = class SimpleEditorModelResolverService2 {
  constructor(modelService) {
    this.modelService = modelService;
  }
  setEditor(editor2) {
    this.editor = editor2;
  }
  createModelReference(resource) {
    let model = null;
    if (this.editor) {
      model = withTypedEditor(this.editor, (editor2) => this.findModel(editor2, resource), (diffEditor) => this.findModel(diffEditor.getOriginalEditor(), resource) || this.findModel(diffEditor.getModifiedEditor(), resource));
    }
    if (!model) {
      return Promise.reject(new Error(`Model not found`));
    }
    return Promise.resolve(new ImmortalReference(new SimpleModel(model)));
  }
  findModel(editor2, resource) {
    let model = this.modelService.getModel(resource);
    if (model && model.uri.toString() !== resource.toString()) {
      return null;
    }
    return model;
  }
};
SimpleEditorModelResolverService = __decorate3([
  __param3(0, IModelService)
], SimpleEditorModelResolverService);
var SimpleEditorProgressService = class {
  show() {
    return SimpleEditorProgressService.NULL_PROGRESS_RUNNER;
  }
  showWhile(promise, delay) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield promise;
    });
  }
};
SimpleEditorProgressService.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
var SimpleDialogService = class {
  confirm(confirmation) {
    return this.doConfirm(confirmation).then((confirmed) => {
      return {
        confirmed,
        checkboxChecked: false
      };
    });
  }
  doConfirm(confirmation) {
    let messageText = confirmation.message;
    if (confirmation.detail) {
      messageText = messageText + "\n\n" + confirmation.detail;
    }
    return Promise.resolve(window.confirm(messageText));
  }
  show(severity, message, buttons, options) {
    return Promise.resolve({ choice: 0 });
  }
};
var SimpleNotificationService = class {
  info(message) {
    return this.notify({ severity: severity_default.Info, message });
  }
  warn(message) {
    return this.notify({ severity: severity_default.Warning, message });
  }
  error(error) {
    return this.notify({ severity: severity_default.Error, message: error });
  }
  notify(notification) {
    switch (notification.severity) {
      case severity_default.Error:
        console.error(notification.message);
        break;
      case severity_default.Warning:
        console.warn(notification.message);
        break;
      default:
        console.log(notification.message);
        break;
    }
    return SimpleNotificationService.NO_OP;
  }
  status(message, options) {
    return Disposable.None;
  }
};
SimpleNotificationService.NO_OP = new NoOpNotification();
var StandaloneCommandService = class {
  constructor(instantiationService) {
    this._onWillExecuteCommand = new Emitter();
    this._onDidExecuteCommand = new Emitter();
    this.onDidExecuteCommand = this._onDidExecuteCommand.event;
    this._instantiationService = instantiationService;
  }
  executeCommand(id, ...args) {
    const command = CommandsRegistry.getCommand(id);
    if (!command) {
      return Promise.reject(new Error(`command '${id}' not found`));
    }
    try {
      this._onWillExecuteCommand.fire({ commandId: id, args });
      const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);
      this._onDidExecuteCommand.fire({ commandId: id, args });
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
};
var StandaloneKeybindingService = class extends AbstractKeybindingService {
  constructor(contextKeyService, commandService, telemetryService, notificationService, logService, domNode) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService);
    this._cachedResolver = null;
    this._dynamicKeybindings = [];
    this._register(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => {
      const keyEvent = new StandardKeyboardEvent(e);
      const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
      if (shouldPreventDefault) {
        keyEvent.preventDefault();
        keyEvent.stopPropagation();
      }
    }));
    this._register(addDisposableListener(window, EventType.KEY_UP, (e) => {
      const keyEvent = new StandardKeyboardEvent(e);
      const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
      if (shouldPreventDefault) {
        keyEvent.preventDefault();
      }
    }));
  }
  addDynamicKeybinding(commandId, _keybinding, handler, when) {
    const keybinding = createKeybinding(_keybinding, OS);
    const toDispose = new DisposableStore();
    if (keybinding) {
      this._dynamicKeybindings.push({
        keybinding,
        command: commandId,
        when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: false
      });
      toDispose.add(toDisposable(() => {
        for (let i = 0; i < this._dynamicKeybindings.length; i++) {
          let kb = this._dynamicKeybindings[i];
          if (kb.command === commandId) {
            this._dynamicKeybindings.splice(i, 1);
            this.updateResolver({ source: 1 });
            return;
          }
        }
      }));
    }
    toDispose.add(CommandsRegistry.registerCommand(commandId, handler));
    this.updateResolver({ source: 1 });
    return toDispose;
  }
  updateResolver(event) {
    this._cachedResolver = null;
    this._onDidUpdateKeybindings.fire(event);
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
      const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
      this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return document.hasFocus();
  }
  _toNormalizedKeybindingItems(items, isDefault) {
    let result = [], resultLen = 0;
    for (const item of items) {
      const when = item.when || void 0;
      const keybinding = item.keybinding;
      if (!keybinding) {
        result[resultLen++] = new ResolvedKeybindingItem(void 0, item.command, item.commandArgs, when, isDefault, null, false);
      } else {
        const resolvedKeybindings = this.resolveKeybinding(keybinding);
        for (const resolvedKeybinding of resolvedKeybindings) {
          result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);
        }
      }
    }
    return result;
  }
  resolveKeybinding(keybinding) {
    return [new USLayoutResolvedKeybinding(keybinding, OS)];
  }
  resolveKeyboardEvent(keyboardEvent) {
    let keybinding = new SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode).toChord();
    return new USLayoutResolvedKeybinding(keybinding, OS);
  }
};
function isConfigurationOverrides(thing) {
  return thing && typeof thing === "object" && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === "string") && (!thing.resource || thing.resource instanceof URI);
}
var SimpleConfigurationService = class {
  constructor() {
    this._onDidChangeConfiguration = new Emitter();
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._configuration = new Configuration2(new DefaultConfigurationModel(), new ConfigurationModel());
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
    return this._configuration.getValue(section, overrides, void 0);
  }
  updateValues(values) {
    const previous = { data: this._configuration.toData() };
    let changedKeys = [];
    for (const entry of values) {
      const [key, value] = entry;
      if (this.getValue(key) === value) {
        continue;
      }
      this._configuration.updateValue(key, value);
      changedKeys.push(key);
    }
    if (changedKeys.length > 0) {
      const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration);
      configurationChangeEvent.source = 7;
      configurationChangeEvent.sourceConfig = null;
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
    return Promise.resolve();
  }
};
var SimpleResourceConfigurationService = class {
  constructor(configurationService) {
    this.configurationService = configurationService;
    this._onDidChangeConfiguration = new Emitter();
    this.configurationService.onDidChangeConfiguration((e) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
    });
  }
  getValue(resource, arg2, arg3) {
    const position = Position.isIPosition(arg2) ? arg2 : null;
    const section = position ? typeof arg3 === "string" ? arg3 : void 0 : typeof arg2 === "string" ? arg2 : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue();
    }
    return this.configurationService.getValue(section);
  }
};
var SimpleResourcePropertiesService = class SimpleResourcePropertiesService2 {
  constructor(configurationService) {
    this.configurationService = configurationService;
  }
  getEOL(resource, language) {
    const eol = this.configurationService.getValue("files.eol", { overrideIdentifier: language, resource });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return isLinux || isMacintosh ? "\n" : "\r\n";
  }
};
SimpleResourcePropertiesService = __decorate3([
  __param3(0, IConfigurationService)
], SimpleResourcePropertiesService);
var StandaloneTelemetryService = class {
  publicLog(eventName, data) {
    return Promise.resolve(void 0);
  }
  publicLog2(eventName, data) {
    return this.publicLog(eventName, data);
  }
};
var SimpleWorkspaceContextService = class {
  constructor() {
    const resource = URI.from({ scheme: SimpleWorkspaceContextService.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new WorkspaceFolder({ uri: resource, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
};
SimpleWorkspaceContextService.SCHEME = "inmemory";
function updateConfigurationService(configurationService, source, isDiffEditor) {
  if (!source) {
    return;
  }
  if (!(configurationService instanceof SimpleConfigurationService)) {
    return;
  }
  let toUpdate = [];
  Object.keys(source).forEach((key) => {
    if (isEditorConfigurationKey(key)) {
      toUpdate.push([`editor.${key}`, source[key]]);
    }
    if (isDiffEditor && isDiffEditorConfigurationKey(key)) {
      toUpdate.push([`diffEditor.${key}`, source[key]]);
    }
  });
  if (toUpdate.length > 0) {
    configurationService.updateValues(toUpdate);
  }
}
var SimpleBulkEditService = class {
  constructor(_modelService) {
    this._modelService = _modelService;
  }
  hasPreviewHandler() {
    return false;
  }
  apply(edits, _options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const textEdits = new Map();
      for (let edit of edits) {
        if (!(edit instanceof ResourceTextEdit)) {
          throw new Error("bad edit - only text edits are supported");
        }
        const model = this._modelService.getModel(edit.resource);
        if (!model) {
          throw new Error("bad edit - model not found");
        }
        if (typeof edit.versionId === "number" && model.getVersionId() !== edit.versionId) {
          throw new Error("bad state - model changed in the meantime");
        }
        let array = textEdits.get(model);
        if (!array) {
          array = [];
          textEdits.set(model, array);
        }
        array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));
      }
      let totalEdits = 0;
      let totalFiles = 0;
      for (const [model, edits2] of textEdits) {
        model.pushStackElement();
        model.pushEditOperations([], edits2, () => []);
        model.pushStackElement();
        totalFiles += 1;
        totalEdits += edits2.length;
      }
      return {
        ariaSummary: format(SimpleServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles)
      };
    });
  }
};
var SimpleUriLabelService = class {
  getUriLabel(resource, options) {
    if (resource.scheme === "file") {
      return resource.fsPath;
    }
    return resource.path;
  }
};
var SimpleLayoutService = class {
  constructor(_codeEditorService, _container) {
    this._codeEditorService = _codeEditorService;
    this._container = _container;
    this.onDidLayout = Event.None;
  }
  get dimension() {
    if (!this._dimension) {
      this._dimension = getClientArea(window.document.body);
    }
    return this._dimension;
  }
  get container() {
    return this._container;
  }
  focus() {
    var _a6;
    (_a6 = this._codeEditorService.getFocusedCodeEditor()) === null || _a6 === void 0 ? void 0 : _a6.focus();
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffEditor.css";

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffReview.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffReview.css";
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a3;
var DIFF_LINES_PADDING = 3;
var DiffEntry = class {
  constructor(originalLineStart, originalLineEnd, modifiedLineStart, modifiedLineEnd) {
    this.originalLineStart = originalLineStart;
    this.originalLineEnd = originalLineEnd;
    this.modifiedLineStart = modifiedLineStart;
    this.modifiedLineEnd = modifiedLineEnd;
  }
  getType() {
    if (this.originalLineStart === 0) {
      return 1;
    }
    if (this.modifiedLineStart === 0) {
      return 2;
    }
    return 0;
  }
};
var Diff = class {
  constructor(entries) {
    this.entries = entries;
  }
};
var diffReviewInsertIcon = registerIcon("diff-review-insert", Codicon.add, localize("diffReviewInsertIcon", "Icon for 'Insert' in diff review."));
var diffReviewRemoveIcon = registerIcon("diff-review-remove", Codicon.remove, localize("diffReviewRemoveIcon", "Icon for 'Remove' in diff review."));
var diffReviewCloseIcon = registerIcon("diff-review-close", Codicon.close, localize("diffReviewCloseIcon", "Icon for 'Close' in diff review."));
var DiffReview = class extends Disposable {
  constructor(diffEditor) {
    super();
    this._width = 0;
    this._diffEditor = diffEditor;
    this._isVisible = false;
    this.shadow = createFastDomNode(document.createElement("div"));
    this.shadow.setClassName("diff-review-shadow");
    this.actionBarContainer = createFastDomNode(document.createElement("div"));
    this.actionBarContainer.setClassName("diff-review-actions");
    this._actionBar = this._register(new ActionBar(this.actionBarContainer.domNode));
    this._actionBar.push(new Action("diffreview.close", localize("label.close", "Close"), "close-diff-review " + ThemeIcon.asClassName(diffReviewCloseIcon), true, () => __awaiter5(this, void 0, void 0, function* () {
      return this.hide();
    })), { label: false, icon: true });
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setClassName("diff-review monaco-editor-background");
    this._content = createFastDomNode(document.createElement("div"));
    this._content.setClassName("diff-review-content");
    this._content.setAttribute("role", "code");
    this.scrollbar = this._register(new DomScrollableElement(this._content.domNode, {}));
    this.domNode.domNode.appendChild(this.scrollbar.getDomNode());
    this._register(diffEditor.onDidUpdateDiff(() => {
      if (!this._isVisible) {
        return;
      }
      this._diffs = this._compute();
      this._render();
    }));
    this._register(diffEditor.getModifiedEditor().onDidChangeCursorPosition(() => {
      if (!this._isVisible) {
        return;
      }
      this._render();
    }));
    this._register(addStandardDisposableListener(this.domNode.domNode, "click", (e) => {
      e.preventDefault();
      let row = findParentWithClass(e.target, "diff-review-row");
      if (row) {
        this._goToRow(row);
      }
    }));
    this._register(addStandardDisposableListener(this.domNode.domNode, "keydown", (e) => {
      if (e.equals(18) || e.equals(2048 | 18) || e.equals(512 | 18)) {
        e.preventDefault();
        this._goToRow(this._getNextRow());
      }
      if (e.equals(16) || e.equals(2048 | 16) || e.equals(512 | 16)) {
        e.preventDefault();
        this._goToRow(this._getPrevRow());
      }
      if (e.equals(9) || e.equals(2048 | 9) || e.equals(512 | 9) || e.equals(1024 | 9)) {
        e.preventDefault();
        this.hide();
      }
      if (e.equals(10) || e.equals(3)) {
        e.preventDefault();
        this.accept();
      }
    }));
    this._diffs = [];
    this._currentDiff = null;
  }
  prev() {
    let index = 0;
    if (!this._isVisible) {
      this._diffs = this._compute();
    }
    if (this._isVisible) {
      let currentIndex = -1;
      for (let i = 0, len = this._diffs.length; i < len; i++) {
        if (this._diffs[i] === this._currentDiff) {
          currentIndex = i;
          break;
        }
      }
      index = this._diffs.length + currentIndex - 1;
    } else {
      index = this._findDiffIndex(this._diffEditor.getPosition());
    }
    if (this._diffs.length === 0) {
      return;
    }
    index = index % this._diffs.length;
    const entries = this._diffs[index].entries;
    this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));
    this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: entries[entries.length - 1].modifiedLineEnd });
    this._isVisible = true;
    this._diffEditor.doLayout();
    this._render();
    this._goToRow(this._getNextRow());
  }
  next() {
    let index = 0;
    if (!this._isVisible) {
      this._diffs = this._compute();
    }
    if (this._isVisible) {
      let currentIndex = -1;
      for (let i = 0, len = this._diffs.length; i < len; i++) {
        if (this._diffs[i] === this._currentDiff) {
          currentIndex = i;
          break;
        }
      }
      index = currentIndex + 1;
    } else {
      index = this._findDiffIndex(this._diffEditor.getPosition());
    }
    if (this._diffs.length === 0) {
      return;
    }
    index = index % this._diffs.length;
    const entries = this._diffs[index].entries;
    this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));
    this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: entries[entries.length - 1].modifiedLineEnd });
    this._isVisible = true;
    this._diffEditor.doLayout();
    this._render();
    this._goToRow(this._getNextRow());
  }
  accept() {
    let jumpToLineNumber = -1;
    let current = this._getCurrentFocusedRow();
    if (current) {
      let lineNumber = parseInt(current.getAttribute("data-line"), 10);
      if (!isNaN(lineNumber)) {
        jumpToLineNumber = lineNumber;
      }
    }
    this.hide();
    if (jumpToLineNumber !== -1) {
      this._diffEditor.setPosition(new Position(jumpToLineNumber, 1));
      this._diffEditor.revealPosition(new Position(jumpToLineNumber, 1), 1);
    }
  }
  hide() {
    this._isVisible = false;
    this._diffEditor.updateOptions({ readOnly: false });
    this._diffEditor.focus();
    this._diffEditor.doLayout();
    this._render();
  }
  _getPrevRow() {
    let current = this._getCurrentFocusedRow();
    if (!current) {
      return this._getFirstRow();
    }
    if (current.previousElementSibling) {
      return current.previousElementSibling;
    }
    return current;
  }
  _getNextRow() {
    let current = this._getCurrentFocusedRow();
    if (!current) {
      return this._getFirstRow();
    }
    if (current.nextElementSibling) {
      return current.nextElementSibling;
    }
    return current;
  }
  _getFirstRow() {
    return this.domNode.domNode.querySelector(".diff-review-row");
  }
  _getCurrentFocusedRow() {
    let result = document.activeElement;
    if (result && /diff-review-row/.test(result.className)) {
      return result;
    }
    return null;
  }
  _goToRow(row) {
    let prev = this._getCurrentFocusedRow();
    row.tabIndex = 0;
    row.focus();
    if (prev && prev !== row) {
      prev.tabIndex = -1;
    }
    this.scrollbar.scanDomNode();
  }
  isVisible() {
    return this._isVisible;
  }
  layout(top, width, height) {
    this._width = width;
    this.shadow.setTop(top - 6);
    this.shadow.setWidth(width);
    this.shadow.setHeight(this._isVisible ? 6 : 0);
    this.domNode.setTop(top);
    this.domNode.setWidth(width);
    this.domNode.setHeight(height);
    this._content.setHeight(height);
    this._content.setWidth(width);
    if (this._isVisible) {
      this.actionBarContainer.setAttribute("aria-hidden", "false");
      this.actionBarContainer.setDisplay("block");
    } else {
      this.actionBarContainer.setAttribute("aria-hidden", "true");
      this.actionBarContainer.setDisplay("none");
    }
  }
  _compute() {
    const lineChanges = this._diffEditor.getLineChanges();
    if (!lineChanges || lineChanges.length === 0) {
      return [];
    }
    const originalModel = this._diffEditor.getOriginalEditor().getModel();
    const modifiedModel = this._diffEditor.getModifiedEditor().getModel();
    if (!originalModel || !modifiedModel) {
      return [];
    }
    return DiffReview._mergeAdjacent(lineChanges, originalModel.getLineCount(), modifiedModel.getLineCount());
  }
  static _mergeAdjacent(lineChanges, originalLineCount, modifiedLineCount) {
    if (!lineChanges || lineChanges.length === 0) {
      return [];
    }
    let diffs = [], diffsLength = 0;
    for (let i = 0, len = lineChanges.length; i < len; i++) {
      const lineChange = lineChanges[i];
      const originalStart = lineChange.originalStartLineNumber;
      const originalEnd = lineChange.originalEndLineNumber;
      const modifiedStart = lineChange.modifiedStartLineNumber;
      const modifiedEnd = lineChange.modifiedEndLineNumber;
      let r2 = [], rLength2 = 0;
      {
        const originalEqualAbove = originalEnd === 0 ? originalStart : originalStart - 1;
        const modifiedEqualAbove = modifiedEnd === 0 ? modifiedStart : modifiedStart - 1;
        let minOriginal = 1;
        let minModified = 1;
        if (i > 0) {
          const prevLineChange = lineChanges[i - 1];
          if (prevLineChange.originalEndLineNumber === 0) {
            minOriginal = prevLineChange.originalStartLineNumber + 1;
          } else {
            minOriginal = prevLineChange.originalEndLineNumber + 1;
          }
          if (prevLineChange.modifiedEndLineNumber === 0) {
            minModified = prevLineChange.modifiedStartLineNumber + 1;
          } else {
            minModified = prevLineChange.modifiedEndLineNumber + 1;
          }
        }
        let fromOriginal = originalEqualAbove - DIFF_LINES_PADDING + 1;
        let fromModified = modifiedEqualAbove - DIFF_LINES_PADDING + 1;
        if (fromOriginal < minOriginal) {
          const delta = minOriginal - fromOriginal;
          fromOriginal = fromOriginal + delta;
          fromModified = fromModified + delta;
        }
        if (fromModified < minModified) {
          const delta = minModified - fromModified;
          fromOriginal = fromOriginal + delta;
          fromModified = fromModified + delta;
        }
        r2[rLength2++] = new DiffEntry(fromOriginal, originalEqualAbove, fromModified, modifiedEqualAbove);
      }
      {
        if (originalEnd !== 0) {
          r2[rLength2++] = new DiffEntry(originalStart, originalEnd, 0, 0);
        }
      }
      {
        if (modifiedEnd !== 0) {
          r2[rLength2++] = new DiffEntry(0, 0, modifiedStart, modifiedEnd);
        }
      }
      {
        const originalEqualBelow = originalEnd === 0 ? originalStart + 1 : originalEnd + 1;
        const modifiedEqualBelow = modifiedEnd === 0 ? modifiedStart + 1 : modifiedEnd + 1;
        let maxOriginal = originalLineCount;
        let maxModified = modifiedLineCount;
        if (i + 1 < len) {
          const nextLineChange = lineChanges[i + 1];
          if (nextLineChange.originalEndLineNumber === 0) {
            maxOriginal = nextLineChange.originalStartLineNumber;
          } else {
            maxOriginal = nextLineChange.originalStartLineNumber - 1;
          }
          if (nextLineChange.modifiedEndLineNumber === 0) {
            maxModified = nextLineChange.modifiedStartLineNumber;
          } else {
            maxModified = nextLineChange.modifiedStartLineNumber - 1;
          }
        }
        let toOriginal = originalEqualBelow + DIFF_LINES_PADDING - 1;
        let toModified = modifiedEqualBelow + DIFF_LINES_PADDING - 1;
        if (toOriginal > maxOriginal) {
          const delta = maxOriginal - toOriginal;
          toOriginal = toOriginal + delta;
          toModified = toModified + delta;
        }
        if (toModified > maxModified) {
          const delta = maxModified - toModified;
          toOriginal = toOriginal + delta;
          toModified = toModified + delta;
        }
        r2[rLength2++] = new DiffEntry(originalEqualBelow, toOriginal, modifiedEqualBelow, toModified);
      }
      diffs[diffsLength++] = new Diff(r2);
    }
    let curr = diffs[0].entries;
    let r = [], rLength = 0;
    for (let i = 1, len = diffs.length; i < len; i++) {
      const thisDiff = diffs[i].entries;
      const currLast = curr[curr.length - 1];
      const thisFirst = thisDiff[0];
      if (currLast.getType() === 0 && thisFirst.getType() === 0 && thisFirst.originalLineStart <= currLast.originalLineEnd) {
        curr[curr.length - 1] = new DiffEntry(currLast.originalLineStart, thisFirst.originalLineEnd, currLast.modifiedLineStart, thisFirst.modifiedLineEnd);
        curr = curr.concat(thisDiff.slice(1));
        continue;
      }
      r[rLength++] = new Diff(curr);
      curr = thisDiff;
    }
    r[rLength++] = new Diff(curr);
    return r;
  }
  _findDiffIndex(pos) {
    const lineNumber = pos.lineNumber;
    for (let i = 0, len = this._diffs.length; i < len; i++) {
      const diff = this._diffs[i].entries;
      const lastModifiedLine = diff[diff.length - 1].modifiedLineEnd;
      if (lineNumber <= lastModifiedLine) {
        return i;
      }
    }
    return 0;
  }
  _render() {
    const originalOptions = this._diffEditor.getOriginalEditor().getOptions();
    const modifiedOptions = this._diffEditor.getModifiedEditor().getOptions();
    const originalModel = this._diffEditor.getOriginalEditor().getModel();
    const modifiedModel = this._diffEditor.getModifiedEditor().getModel();
    const originalModelOpts = originalModel.getOptions();
    const modifiedModelOpts = modifiedModel.getOptions();
    if (!this._isVisible || !originalModel || !modifiedModel) {
      clearNode(this._content.domNode);
      this._currentDiff = null;
      this.scrollbar.scanDomNode();
      return;
    }
    this._diffEditor.updateOptions({ readOnly: true });
    const diffIndex = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs[diffIndex] === this._currentDiff) {
      return;
    }
    this._currentDiff = this._diffs[diffIndex];
    const diffs = this._diffs[diffIndex].entries;
    let container = document.createElement("div");
    container.className = "diff-review-table";
    container.setAttribute("role", "list");
    container.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands');
    Configuration.applyFontInfoSlow(container, modifiedOptions.get(41));
    let minOriginalLine = 0;
    let maxOriginalLine = 0;
    let minModifiedLine = 0;
    let maxModifiedLine = 0;
    for (let i = 0, len = diffs.length; i < len; i++) {
      const diffEntry = diffs[i];
      const originalLineStart = diffEntry.originalLineStart;
      const originalLineEnd = diffEntry.originalLineEnd;
      const modifiedLineStart = diffEntry.modifiedLineStart;
      const modifiedLineEnd = diffEntry.modifiedLineEnd;
      if (originalLineStart !== 0 && (minOriginalLine === 0 || originalLineStart < minOriginalLine)) {
        minOriginalLine = originalLineStart;
      }
      if (originalLineEnd !== 0 && (maxOriginalLine === 0 || originalLineEnd > maxOriginalLine)) {
        maxOriginalLine = originalLineEnd;
      }
      if (modifiedLineStart !== 0 && (minModifiedLine === 0 || modifiedLineStart < minModifiedLine)) {
        minModifiedLine = modifiedLineStart;
      }
      if (modifiedLineEnd !== 0 && (maxModifiedLine === 0 || modifiedLineEnd > maxModifiedLine)) {
        maxModifiedLine = modifiedLineEnd;
      }
    }
    let header = document.createElement("div");
    header.className = "diff-review-row";
    let cell = document.createElement("div");
    cell.className = "diff-review-cell diff-review-summary";
    const originalChangedLinesCnt = maxOriginalLine - minOriginalLine + 1;
    const modifiedChangedLinesCnt = maxModifiedLine - minModifiedLine + 1;
    cell.appendChild(document.createTextNode(`${diffIndex + 1}/${this._diffs.length}: @@ -${minOriginalLine},${originalChangedLinesCnt} +${minModifiedLine},${modifiedChangedLinesCnt} @@`));
    header.setAttribute("data-line", String(minModifiedLine));
    const getAriaLines = (lines) => {
      if (lines === 0) {
        return localize("no_lines_changed", "no lines changed");
      } else if (lines === 1) {
        return localize("one_line_changed", "1 line changed");
      } else {
        return localize("more_lines_changed", "{0} lines changed", lines);
      }
    };
    const originalChangedLinesCntAria = getAriaLines(originalChangedLinesCnt);
    const modifiedChangedLinesCntAria = getAriaLines(modifiedChangedLinesCnt);
    header.setAttribute("aria-label", localize({
      key: "header",
      comment: [
        "This is the ARIA label for a git diff header.",
        "A git diff header looks like this: @@ -154,12 +159,39 @@.",
        "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
        "Variables 0 and 1 refer to the diff index out of total number of diffs.",
        "Variables 2 and 4 will be numbers (a line number).",
        'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
      ]
    }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", diffIndex + 1, this._diffs.length, minOriginalLine, originalChangedLinesCntAria, minModifiedLine, modifiedChangedLinesCntAria));
    header.appendChild(cell);
    header.setAttribute("role", "listitem");
    container.appendChild(header);
    const lineHeight = modifiedOptions.get(57);
    let modLine = minModifiedLine;
    for (let i = 0, len = diffs.length; i < len; i++) {
      const diffEntry = diffs[i];
      DiffReview._renderSection(container, diffEntry, modLine, lineHeight, this._width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts);
      if (diffEntry.modifiedLineStart !== 0) {
        modLine = diffEntry.modifiedLineEnd;
      }
    }
    clearNode(this._content.domNode);
    this._content.domNode.appendChild(container);
    this.scrollbar.scanDomNode();
  }
  static _renderSection(dest, diffEntry, modLine, lineHeight, width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts) {
    const type = diffEntry.getType();
    let rowClassName = "diff-review-row";
    let lineNumbersExtraClassName = "";
    const spacerClassName = "diff-review-spacer";
    let spacerIcon = null;
    switch (type) {
      case 1:
        rowClassName = "diff-review-row line-insert";
        lineNumbersExtraClassName = " char-insert";
        spacerIcon = diffReviewInsertIcon;
        break;
      case 2:
        rowClassName = "diff-review-row line-delete";
        lineNumbersExtraClassName = " char-delete";
        spacerIcon = diffReviewRemoveIcon;
        break;
    }
    const originalLineStart = diffEntry.originalLineStart;
    const originalLineEnd = diffEntry.originalLineEnd;
    const modifiedLineStart = diffEntry.modifiedLineStart;
    const modifiedLineEnd = diffEntry.modifiedLineEnd;
    const cnt = Math.max(modifiedLineEnd - modifiedLineStart, originalLineEnd - originalLineStart);
    const originalLayoutInfo = originalOptions.get(129);
    const originalLineNumbersWidth = originalLayoutInfo.glyphMarginWidth + originalLayoutInfo.lineNumbersWidth;
    const modifiedLayoutInfo = modifiedOptions.get(129);
    const modifiedLineNumbersWidth = 10 + modifiedLayoutInfo.glyphMarginWidth + modifiedLayoutInfo.lineNumbersWidth;
    for (let i = 0; i <= cnt; i++) {
      const originalLine = originalLineStart === 0 ? 0 : originalLineStart + i;
      const modifiedLine = modifiedLineStart === 0 ? 0 : modifiedLineStart + i;
      const row = document.createElement("div");
      row.style.minWidth = width + "px";
      row.className = rowClassName;
      row.setAttribute("role", "listitem");
      if (modifiedLine !== 0) {
        modLine = modifiedLine;
      }
      row.setAttribute("data-line", String(modLine));
      let cell = document.createElement("div");
      cell.className = "diff-review-cell";
      cell.style.height = `${lineHeight}px`;
      row.appendChild(cell);
      const originalLineNumber = document.createElement("span");
      originalLineNumber.style.width = originalLineNumbersWidth + "px";
      originalLineNumber.style.minWidth = originalLineNumbersWidth + "px";
      originalLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
      if (originalLine !== 0) {
        originalLineNumber.appendChild(document.createTextNode(String(originalLine)));
      } else {
        originalLineNumber.innerText = "\xA0";
      }
      cell.appendChild(originalLineNumber);
      const modifiedLineNumber = document.createElement("span");
      modifiedLineNumber.style.width = modifiedLineNumbersWidth + "px";
      modifiedLineNumber.style.minWidth = modifiedLineNumbersWidth + "px";
      modifiedLineNumber.style.paddingRight = "10px";
      modifiedLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
      if (modifiedLine !== 0) {
        modifiedLineNumber.appendChild(document.createTextNode(String(modifiedLine)));
      } else {
        modifiedLineNumber.innerText = "\xA0";
      }
      cell.appendChild(modifiedLineNumber);
      const spacer = document.createElement("span");
      spacer.className = spacerClassName;
      if (spacerIcon) {
        const spacerCodicon = document.createElement("span");
        spacerCodicon.className = ThemeIcon.asClassName(spacerIcon);
        spacerCodicon.innerText = "\xA0\xA0";
        spacer.appendChild(spacerCodicon);
      } else {
        spacer.innerText = "\xA0\xA0";
      }
      cell.appendChild(spacer);
      let lineContent;
      if (modifiedLine !== 0) {
        let html = this._renderLine(modifiedModel, modifiedOptions, modifiedModelOpts.tabSize, modifiedLine);
        if (DiffReview._ttPolicy) {
          html = DiffReview._ttPolicy.createHTML(html);
        }
        cell.insertAdjacentHTML("beforeend", html);
        lineContent = modifiedModel.getLineContent(modifiedLine);
      } else {
        let html = this._renderLine(originalModel, originalOptions, originalModelOpts.tabSize, originalLine);
        if (DiffReview._ttPolicy) {
          html = DiffReview._ttPolicy.createHTML(html);
        }
        cell.insertAdjacentHTML("beforeend", html);
        lineContent = originalModel.getLineContent(originalLine);
      }
      if (lineContent.length === 0) {
        lineContent = localize("blankLine", "blank");
      }
      let ariaLabel = "";
      switch (type) {
        case 0:
          if (originalLine === modifiedLine) {
            ariaLabel = localize({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", lineContent, originalLine);
          } else {
            ariaLabel = localize("equalLine", "{0} original line {1} modified line {2}", lineContent, originalLine, modifiedLine);
          }
          break;
        case 1:
          ariaLabel = localize("insertLine", "+ {0} modified line {1}", lineContent, modifiedLine);
          break;
        case 2:
          ariaLabel = localize("deleteLine", "- {0} original line {1}", lineContent, originalLine);
          break;
      }
      row.setAttribute("aria-label", ariaLabel);
      dest.appendChild(row);
    }
  }
  static _renderLine(model, options, tabSize, lineNumber) {
    const lineContent = model.getLineContent(lineNumber);
    const fontInfo = options.get(41);
    const lineTokens = LineTokens.createEmpty(lineContent);
    const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, model.mightContainNonBasicASCII());
    const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, model.mightContainRTL());
    const r = renderViewLine2(new RenderLineInput(fontInfo.isMonospace && !options.get(27), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(104), options.get(87), options.get(81), options.get(42) !== EditorFontLigatures.OFF, null));
    return r.html;
  }
};
DiffReview._ttPolicy = (_a3 = window.trustedTypes) === null || _a3 === void 0 ? void 0 : _a3.createPolicy("diffReview", { createHTML: (value) => value });
registerThemingParticipant((theme, collector) => {
  const lineNumbers = theme.getColor(editorLineNumbers);
  if (lineNumbers) {
    collector.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${lineNumbers}; }`);
  }
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${shadow} 0 -6px 6px -6px inset; }`);
  }
});
var DiffReviewNext = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.diffReview.next",
      label: localize("editor.action.diffReview.next", "Go to Next Difference"),
      alias: "Go to Next Difference",
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 65,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor) {
      diffEditor.diffReviewNext();
    }
  }
};
var DiffReviewPrev = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.diffReview.prev",
      label: localize("editor.action.diffReview.prev", "Go to Previous Difference"),
      alias: "Go to Previous Difference",
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 1024 | 65,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor) {
      diffEditor.diffReviewPrev();
    }
  }
};
function findFocusedDiffEditor(accessor) {
  const codeEditorService = accessor.get(ICodeEditorService);
  const diffEditors = codeEditorService.listDiffEditors();
  const activeCodeEditor = codeEditorService.getActiveCodeEditor();
  if (!activeCodeEditor) {
    return null;
  }
  for (let i = 0, len = diffEditors.length; i < len; i++) {
    const diffEditor = diffEditors[i];
    if (diffEditor.getModifiedEditor().getId() === activeCodeEditor.getId() || diffEditor.getOriginalEditor().getId() === activeCodeEditor.getId()) {
      return diffEditor;
    }
  }
  return null;
}
registerEditorAction(DiffReviewNext);
registerEditorAction(DiffReviewPrev);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/inlineDiffMargin.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlineDiffMargin = class extends Disposable {
  constructor(_viewZoneId, _marginDomNode, editor2, diff, _contextMenuService, _clipboardService) {
    super();
    this._viewZoneId = _viewZoneId;
    this._marginDomNode = _marginDomNode;
    this.editor = editor2;
    this.diff = diff;
    this._contextMenuService = _contextMenuService;
    this._clipboardService = _clipboardService;
    this._visibility = false;
    this._marginDomNode.style.zIndex = "10";
    this._diffActions = document.createElement("div");
    this._diffActions.className = Codicon.lightBulb.classNames + " lightbulb-glyph";
    this._diffActions.style.position = "absolute";
    const lineHeight = editor2.getOption(57);
    const lineFeed = editor2.getModel().getEOL();
    this._diffActions.style.right = "0px";
    this._diffActions.style.visibility = "hidden";
    this._diffActions.style.height = `${lineHeight}px`;
    this._diffActions.style.lineHeight = `${lineHeight}px`;
    this._marginDomNode.appendChild(this._diffActions);
    const actions = [];
    actions.push(new Action("diff.clipboard.copyDeletedContent", diff.originalEndLineNumber > diff.modifiedStartLineNumber ? localize("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : localize("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line"), void 0, true, () => __awaiter6(this, void 0, void 0, function* () {
      const range2 = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber + 1, 1);
      const deletedText = diff.originalModel.getValueInRange(range2);
      yield this._clipboardService.writeText(deletedText);
    })));
    let currentLineNumberOffset = 0;
    let copyLineAction = void 0;
    if (diff.originalEndLineNumber > diff.modifiedStartLineNumber) {
      copyLineAction = new Action("diff.clipboard.copyDeletedLineContent", localize("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", diff.originalStartLineNumber), void 0, true, () => __awaiter6(this, void 0, void 0, function* () {
        const lineContent = diff.originalModel.getLineContent(diff.originalStartLineNumber + currentLineNumberOffset);
        yield this._clipboardService.writeText(lineContent);
      }));
      actions.push(copyLineAction);
    }
    const readOnly = editor2.getOption(79);
    if (!readOnly) {
      actions.push(new Action("diff.inline.revertChange", localize("diff.inline.revertChange.label", "Revert this change"), void 0, true, () => __awaiter6(this, void 0, void 0, function* () {
        const range2 = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber, diff.originalModel.getLineMaxColumn(diff.originalEndLineNumber));
        const deletedText = diff.originalModel.getValueInRange(range2);
        if (diff.modifiedEndLineNumber === 0) {
          const column = editor2.getModel().getLineMaxColumn(diff.modifiedStartLineNumber);
          editor2.executeEdits("diffEditor", [
            {
              range: new Range(diff.modifiedStartLineNumber, column, diff.modifiedStartLineNumber, column),
              text: lineFeed + deletedText
            }
          ]);
        } else {
          const column = editor2.getModel().getLineMaxColumn(diff.modifiedEndLineNumber);
          editor2.executeEdits("diffEditor", [
            {
              range: new Range(diff.modifiedStartLineNumber, 1, diff.modifiedEndLineNumber, column),
              text: deletedText
            }
          ]);
        }
      })));
    }
    const showContextMenu = (x, y) => {
      this._contextMenuService.showContextMenu({
        getAnchor: () => {
          return {
            x,
            y
          };
        },
        getActions: () => {
          if (copyLineAction) {
            copyLineAction.label = localize("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", diff.originalStartLineNumber + currentLineNumberOffset);
          }
          return actions;
        },
        autoSelectFirstItem: true
      });
    };
    this._register(addStandardDisposableListener(this._diffActions, "mousedown", (e) => {
      const { top, height } = getDomNodePagePosition(this._diffActions);
      let pad = Math.floor(lineHeight / 3);
      e.preventDefault();
      showContextMenu(e.posx, top + height + pad);
    }));
    this._register(editor2.onMouseMove((e) => {
      if (e.target.type === 8 || e.target.type === 5) {
        const viewZoneId = e.target.detail.viewZoneId;
        if (viewZoneId === this._viewZoneId) {
          this.visibility = true;
          currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
        } else {
          this.visibility = false;
        }
      } else {
        this.visibility = false;
      }
    }));
    this._register(editor2.onMouseDown((e) => {
      if (!e.event.rightButton) {
        return;
      }
      if (e.target.type === 8 || e.target.type === 5) {
        const viewZoneId = e.target.detail.viewZoneId;
        if (viewZoneId === this._viewZoneId) {
          e.event.preventDefault();
          currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
          showContextMenu(e.event.posx, e.event.posy + lineHeight);
        }
      }
    }));
  }
  get visibility() {
    return this._visibility;
  }
  set visibility(_visibility) {
    if (this._visibility !== _visibility) {
      this._visibility = _visibility;
      if (_visibility) {
        this._diffActions.style.visibility = "visible";
      } else {
        this._diffActions.style.visibility = "hidden";
      }
    }
  }
  _updateLightBulbPosition(marginDomNode, y, lineHeight) {
    const { top } = getDomNodePagePosition(marginDomNode);
    const offset = y - top;
    const lineNumberOffset = Math.floor(offset / lineHeight);
    const newTop = lineNumberOffset * lineHeight;
    this._diffActions.style.top = `${newTop}px`;
    if (this.diff.viewLineCounts) {
      let acc = 0;
      for (let i = 0; i < this.diff.viewLineCounts.length; i++) {
        acc += this.diff.viewLineCounts[i];
        if (lineNumberOffset < acc) {
          return i;
        }
      }
    }
    return lineNumberOffset;
  }
};

// node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js
var Progress = class {
  constructor(callback) {
    this.callback = callback;
  }
  report(item) {
    this._value = item;
    this.callback(this._value);
  }
};
Progress.None = Object.freeze({ report() {
} });
var IEditorProgressService = createDecorator("editorProgressService");

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a4;
var VisualEditorState = class {
  constructor(_contextMenuService, _clipboardService) {
    this._contextMenuService = _contextMenuService;
    this._clipboardService = _clipboardService;
    this._zones = [];
    this._inlineDiffMargins = [];
    this._zonesMap = {};
    this._decorations = [];
  }
  getForeignViewZones(allViewZones) {
    return allViewZones.filter((z) => !this._zonesMap[String(z.id)]);
  }
  clean(editor2) {
    if (this._zones.length > 0) {
      editor2.changeViewZones((viewChangeAccessor) => {
        for (const zoneId of this._zones) {
          viewChangeAccessor.removeZone(zoneId);
        }
      });
    }
    this._zones = [];
    this._zonesMap = {};
    this._decorations = editor2.deltaDecorations(this._decorations, []);
  }
  apply(editor2, overviewRuler, newDecorations, restoreScrollState) {
    const scrollState = restoreScrollState ? StableEditorScrollState.capture(editor2) : null;
    editor2.changeViewZones((viewChangeAccessor) => {
      for (const zoneId of this._zones) {
        viewChangeAccessor.removeZone(zoneId);
      }
      for (const inlineDiffMargin of this._inlineDiffMargins) {
        inlineDiffMargin.dispose();
      }
      this._zones = [];
      this._zonesMap = {};
      this._inlineDiffMargins = [];
      for (let i = 0, length = newDecorations.zones.length; i < length; i++) {
        const viewZone = newDecorations.zones[i];
        viewZone.suppressMouseDown = true;
        const zoneId = viewChangeAccessor.addZone(viewZone);
        this._zones.push(zoneId);
        this._zonesMap[String(zoneId)] = true;
        if (newDecorations.zones[i].diff && viewZone.marginDomNode) {
          viewZone.suppressMouseDown = false;
          this._inlineDiffMargins.push(new InlineDiffMargin(zoneId, viewZone.marginDomNode, editor2, newDecorations.zones[i].diff, this._contextMenuService, this._clipboardService));
        }
      }
    });
    if (scrollState) {
      scrollState.restore(editor2);
    }
    this._decorations = editor2.deltaDecorations(this._decorations, newDecorations.decorations);
    if (overviewRuler) {
      overviewRuler.setZones(newDecorations.overviewZones);
    }
  }
};
var DIFF_EDITOR_ID = 0;
var diffInsertIcon = registerIcon("diff-insert", Codicon.add, localize("diffInsertIcon", "Line decoration for inserts in the diff editor."));
var diffRemoveIcon = registerIcon("diff-remove", Codicon.remove, localize("diffRemoveIcon", "Line decoration for removals in the diff editor."));
var ttPolicy3 = (_a4 = window.trustedTypes) === null || _a4 === void 0 ? void 0 : _a4.createPolicy("diffEditorWidget", { createHTML: (value) => value });
var DiffEditorWidget = class DiffEditorWidget2 extends Disposable {
  constructor(domElement, options, codeEditorWidgetOptions, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, _editorProgressService) {
    super();
    this._editorProgressService = _editorProgressService;
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
    this._onDidUpdateDiff = this._register(new Emitter());
    this.onDidUpdateDiff = this._onDidUpdateDiff.event;
    this._onDidContentSizeChange = this._register(new Emitter());
    this._lastOriginalWarning = null;
    this._lastModifiedWarning = null;
    this._editorWorkerService = editorWorkerService;
    this._codeEditorService = codeEditorService;
    this._contextKeyService = this._register(contextKeyService.createScoped(domElement));
    this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    this._contextKeyService.createKey("isInDiffEditor", true);
    this._themeService = themeService;
    this._notificationService = notificationService;
    this._id = ++DIFF_EDITOR_ID;
    this._state = 0;
    this._updatingDiffProgress = null;
    this._domElement = domElement;
    options = options || {};
    this._renderSideBySide = true;
    if (typeof options.renderSideBySide !== "undefined") {
      this._renderSideBySide = options.renderSideBySide;
    }
    this._maxComputationTime = 5e3;
    if (typeof options.maxComputationTime !== "undefined") {
      this._maxComputationTime = options.maxComputationTime;
    }
    this._ignoreTrimWhitespace = true;
    if (typeof options.ignoreTrimWhitespace !== "undefined") {
      this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;
    }
    this._renderIndicators = true;
    if (typeof options.renderIndicators !== "undefined") {
      this._renderIndicators = options.renderIndicators;
    }
    this._originalIsEditable = boolean(options.originalEditable, false);
    this._diffCodeLens = boolean(options.diffCodeLens, false);
    this._diffWordWrap = validateDiffWordWrap(options.diffWordWrap, "inherit");
    if (typeof options.isInEmbeddedEditor !== "undefined") {
      this._contextKeyService.createKey("isInEmbeddedDiffEditor", options.isInEmbeddedEditor);
    } else {
      this._contextKeyService.createKey("isInEmbeddedDiffEditor", false);
    }
    this._renderOverviewRuler = true;
    if (typeof options.renderOverviewRuler !== "undefined") {
      this._renderOverviewRuler = Boolean(options.renderOverviewRuler);
    }
    this._updateDecorationsRunner = this._register(new RunOnceScheduler(() => this._updateDecorations(), 0));
    this._containerDomElement = document.createElement("div");
    this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    this._containerDomElement.style.position = "relative";
    this._containerDomElement.style.height = "100%";
    this._domElement.appendChild(this._containerDomElement);
    this._overviewViewportDomElement = createFastDomNode(document.createElement("div"));
    this._overviewViewportDomElement.setClassName("diffViewport");
    this._overviewViewportDomElement.setPosition("absolute");
    this._overviewDomElement = document.createElement("div");
    this._overviewDomElement.className = "diffOverview";
    this._overviewDomElement.style.position = "absolute";
    this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode);
    this._register(addStandardDisposableListener(this._overviewDomElement, "mousedown", (e) => {
      this._modifiedEditor.delegateVerticalScrollbarMouseDown(e);
    }));
    if (this._renderOverviewRuler) {
      this._containerDomElement.appendChild(this._overviewDomElement);
    }
    this._originalDomNode = document.createElement("div");
    this._originalDomNode.className = "editor original";
    this._originalDomNode.style.position = "absolute";
    this._originalDomNode.style.height = "100%";
    this._containerDomElement.appendChild(this._originalDomNode);
    this._modifiedDomNode = document.createElement("div");
    this._modifiedDomNode.className = "editor modified";
    this._modifiedDomNode.style.position = "absolute";
    this._modifiedDomNode.style.height = "100%";
    this._containerDomElement.appendChild(this._modifiedDomNode);
    this._beginUpdateDecorationsTimeout = -1;
    this._currentlyChangingViewZones = false;
    this._diffComputationToken = 0;
    this._originalEditorState = new VisualEditorState(contextMenuService, clipboardService);
    this._modifiedEditorState = new VisualEditorState(contextMenuService, clipboardService);
    this._isVisible = true;
    this._isHandlingScrollEvent = false;
    this._elementSizeObserver = this._register(new ElementSizeObserver(this._containerDomElement, options.dimension, () => this._onDidContainerSizeChanged()));
    if (options.automaticLayout) {
      this._elementSizeObserver.startObserving();
    }
    this._diffComputationResult = null;
    this._originalEditor = this._createLeftHandSideEditor(options, codeEditorWidgetOptions.originalEditor || {});
    this._modifiedEditor = this._createRightHandSideEditor(options, codeEditorWidgetOptions.modifiedEditor || {});
    this._originalOverviewRuler = null;
    this._modifiedOverviewRuler = null;
    this._reviewPane = new DiffReview(this);
    this._containerDomElement.appendChild(this._reviewPane.domNode.domNode);
    this._containerDomElement.appendChild(this._reviewPane.shadow.domNode);
    this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode);
    this._enableSplitViewResizing = true;
    if (typeof options.enableSplitViewResizing !== "undefined") {
      this._enableSplitViewResizing = options.enableSplitViewResizing;
    }
    if (this._renderSideBySide) {
      this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
    } else {
      this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
    }
    this._register(themeService.onDidColorThemeChange((t) => {
      if (this._strategy && this._strategy.applyColors(t)) {
        this._updateDecorationsRunner.schedule();
      }
      this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }));
    const contributions = EditorExtensionsRegistry.getDiffEditorContributions();
    for (const desc of contributions) {
      try {
        this._register(instantiationService.createInstance(desc.ctor, this));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    this._codeEditorService.addDiffEditor(this);
  }
  _setState(newState) {
    if (this._state === newState) {
      return;
    }
    this._state = newState;
    if (this._updatingDiffProgress) {
      this._updatingDiffProgress.done();
      this._updatingDiffProgress = null;
    }
    if (this._state === 1) {
      this._updatingDiffProgress = this._editorProgressService.show(true, 1e3);
    }
  }
  diffReviewNext() {
    this._reviewPane.next();
  }
  diffReviewPrev() {
    this._reviewPane.prev();
  }
  static _getClassName(theme, renderSideBySide) {
    let result = "monaco-diff-editor monaco-editor-background ";
    if (renderSideBySide) {
      result += "side-by-side ";
    }
    result += getThemeTypeSelector(theme.type);
    return result;
  }
  _recreateOverviewRulers() {
    if (!this._renderOverviewRuler) {
      return;
    }
    if (this._originalOverviewRuler) {
      this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
      this._originalOverviewRuler.dispose();
    }
    if (this._originalEditor.hasModel()) {
      this._originalOverviewRuler = this._originalEditor.createOverviewRuler("original diffOverviewRuler");
      this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());
    }
    if (this._modifiedOverviewRuler) {
      this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
      this._modifiedOverviewRuler.dispose();
    }
    if (this._modifiedEditor.hasModel()) {
      this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler("modified diffOverviewRuler");
      this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());
    }
    this._layoutOverviewRulers();
  }
  _createLeftHandSideEditor(options, codeEditorWidgetOptions) {
    const editor2 = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options), codeEditorWidgetOptions);
    this._register(editor2.onDidScrollChange((e) => {
      if (this._isHandlingScrollEvent) {
        return;
      }
      if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
        return;
      }
      this._isHandlingScrollEvent = true;
      this._modifiedEditor.setScrollPosition({
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      });
      this._isHandlingScrollEvent = false;
      this._layoutOverviewViewport();
    }));
    this._register(editor2.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!editor2.getModel()) {
        return;
      }
      if (e.hasChanged(41)) {
        this._updateDecorationsRunner.schedule();
      }
      if (e.hasChanged(130)) {
        this._updateDecorationsRunner.cancel();
        this._updateDecorations();
      }
    }));
    this._register(editor2.onDidChangeModelContent(() => {
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }));
    const isInDiffLeftEditorKey = this._contextKeyService.createKey("isInDiffLeftEditor", editor2.hasWidgetFocus());
    this._register(editor2.onDidFocusEditorWidget(() => isInDiffLeftEditorKey.set(true)));
    this._register(editor2.onDidBlurEditorWidget(() => isInDiffLeftEditorKey.set(false)));
    this._register(editor2.onDidContentSizeChange((e) => {
      const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
      const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: height,
        contentWidth: width,
        contentHeightChanged: e.contentHeightChanged,
        contentWidthChanged: e.contentWidthChanged
      });
    }));
    return editor2;
  }
  _createRightHandSideEditor(options, codeEditorWidgetOptions) {
    const editor2 = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options), codeEditorWidgetOptions);
    this._register(editor2.onDidScrollChange((e) => {
      if (this._isHandlingScrollEvent) {
        return;
      }
      if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
        return;
      }
      this._isHandlingScrollEvent = true;
      this._originalEditor.setScrollPosition({
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      });
      this._isHandlingScrollEvent = false;
      this._layoutOverviewViewport();
    }));
    this._register(editor2.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!editor2.getModel()) {
        return;
      }
      if (e.hasChanged(41)) {
        this._updateDecorationsRunner.schedule();
      }
      if (e.hasChanged(130)) {
        this._updateDecorationsRunner.cancel();
        this._updateDecorations();
      }
    }));
    this._register(editor2.onDidChangeModelContent(() => {
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }));
    this._register(editor2.onDidChangeModelOptions((e) => {
      if (e.tabSize) {
        this._updateDecorationsRunner.schedule();
      }
    }));
    const isInDiffRightEditorKey = this._contextKeyService.createKey("isInDiffRightEditor", editor2.hasWidgetFocus());
    this._register(editor2.onDidFocusEditorWidget(() => isInDiffRightEditorKey.set(true)));
    this._register(editor2.onDidBlurEditorWidget(() => isInDiffRightEditorKey.set(false)));
    this._register(editor2.onDidContentSizeChange((e) => {
      const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
      const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: height,
        contentWidth: width,
        contentHeightChanged: e.contentHeightChanged,
        contentWidthChanged: e.contentWidthChanged
      });
    }));
    return editor2;
  }
  _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
    return instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);
  }
  dispose() {
    this._codeEditorService.removeDiffEditor(this);
    if (this._beginUpdateDecorationsTimeout !== -1) {
      window.clearTimeout(this._beginUpdateDecorationsTimeout);
      this._beginUpdateDecorationsTimeout = -1;
    }
    this._cleanViewZonesAndDecorations();
    if (this._originalOverviewRuler) {
      this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
      this._originalOverviewRuler.dispose();
    }
    if (this._modifiedOverviewRuler) {
      this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
      this._modifiedOverviewRuler.dispose();
    }
    this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);
    if (this._renderOverviewRuler) {
      this._containerDomElement.removeChild(this._overviewDomElement);
    }
    this._containerDomElement.removeChild(this._originalDomNode);
    this._originalEditor.dispose();
    this._containerDomElement.removeChild(this._modifiedDomNode);
    this._modifiedEditor.dispose();
    this._strategy.dispose();
    this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);
    this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);
    this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);
    this._reviewPane.dispose();
    this._domElement.removeChild(this._containerDomElement);
    this._onDidDispose.fire();
    super.dispose();
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return EditorType.IDiffEditor;
  }
  getLineChanges() {
    if (!this._diffComputationResult) {
      return null;
    }
    return this._diffComputationResult.changes;
  }
  getOriginalEditor() {
    return this._originalEditor;
  }
  getModifiedEditor() {
    return this._modifiedEditor;
  }
  updateOptions(newOptions) {
    let renderSideBySideChanged = false;
    if (typeof newOptions.renderSideBySide !== "undefined") {
      if (this._renderSideBySide !== newOptions.renderSideBySide) {
        this._renderSideBySide = newOptions.renderSideBySide;
        renderSideBySideChanged = true;
      }
    }
    if (typeof newOptions.maxComputationTime !== "undefined") {
      this._maxComputationTime = newOptions.maxComputationTime;
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }
    let beginUpdateDecorations = false;
    if (typeof newOptions.ignoreTrimWhitespace !== "undefined") {
      if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {
        this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;
        beginUpdateDecorations = true;
      }
    }
    if (typeof newOptions.renderIndicators !== "undefined") {
      if (this._renderIndicators !== newOptions.renderIndicators) {
        this._renderIndicators = newOptions.renderIndicators;
        beginUpdateDecorations = true;
      }
    }
    if (beginUpdateDecorations) {
      this._beginUpdateDecorations();
    }
    this._originalIsEditable = boolean(newOptions.originalEditable, this._originalIsEditable);
    this._diffCodeLens = boolean(newOptions.diffCodeLens, this._diffCodeLens);
    this._diffWordWrap = validateDiffWordWrap(newOptions.diffWordWrap, this._diffWordWrap);
    this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions));
    this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions));
    if (typeof newOptions.enableSplitViewResizing !== "undefined") {
      this._enableSplitViewResizing = newOptions.enableSplitViewResizing;
    }
    this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);
    if (renderSideBySideChanged) {
      if (this._renderSideBySide) {
        this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
      } else {
        this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
      }
      this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }
    if (typeof newOptions.renderOverviewRuler !== "undefined" && this._renderOverviewRuler !== newOptions.renderOverviewRuler) {
      this._renderOverviewRuler = newOptions.renderOverviewRuler;
      if (this._renderOverviewRuler) {
        this._containerDomElement.appendChild(this._overviewDomElement);
      } else {
        this._containerDomElement.removeChild(this._overviewDomElement);
      }
    }
  }
  getModel() {
    return {
      original: this._originalEditor.getModel(),
      modified: this._modifiedEditor.getModel()
    };
  }
  setModel(model) {
    if (model && (!model.original || !model.modified)) {
      throw new Error(!model.original ? "DiffEditorWidget.setModel: Original model is null" : "DiffEditorWidget.setModel: Modified model is null");
    }
    this._cleanViewZonesAndDecorations();
    this._originalEditor.setModel(model ? model.original : null);
    this._modifiedEditor.setModel(model ? model.modified : null);
    this._updateDecorationsRunner.cancel();
    if (model) {
      this._originalEditor.setScrollTop(0);
      this._modifiedEditor.setScrollTop(0);
    }
    this._diffComputationResult = null;
    this._diffComputationToken++;
    this._setState(0);
    if (model) {
      this._recreateOverviewRulers();
      this._beginUpdateDecorations();
    }
    this._layoutOverviewViewport();
  }
  getDomNode() {
    return this._domElement;
  }
  getVisibleColumnFromPosition(position) {
    return this._modifiedEditor.getVisibleColumnFromPosition(position);
  }
  getPosition() {
    return this._modifiedEditor.getPosition();
  }
  setPosition(position) {
    this._modifiedEditor.setPosition(position);
  }
  revealLine(lineNumber, scrollType = 0) {
    this._modifiedEditor.revealLine(lineNumber, scrollType);
  }
  revealLineInCenter(lineNumber, scrollType = 0) {
    this._modifiedEditor.revealLineInCenter(lineNumber, scrollType);
  }
  revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0) {
    this._modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);
  }
  revealLineNearTop(lineNumber, scrollType = 0) {
    this._modifiedEditor.revealLineNearTop(lineNumber, scrollType);
  }
  revealPosition(position, scrollType = 0) {
    this._modifiedEditor.revealPosition(position, scrollType);
  }
  revealPositionInCenter(position, scrollType = 0) {
    this._modifiedEditor.revealPositionInCenter(position, scrollType);
  }
  revealPositionInCenterIfOutsideViewport(position, scrollType = 0) {
    this._modifiedEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);
  }
  revealPositionNearTop(position, scrollType = 0) {
    this._modifiedEditor.revealPositionNearTop(position, scrollType);
  }
  getSelection() {
    return this._modifiedEditor.getSelection();
  }
  getSelections() {
    return this._modifiedEditor.getSelections();
  }
  setSelection(something) {
    this._modifiedEditor.setSelection(something);
  }
  setSelections(ranges) {
    this._modifiedEditor.setSelections(ranges);
  }
  revealLines(startLineNumber, endLineNumber, scrollType = 0) {
    this._modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0) {
    this._modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0) {
    this._modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0) {
    this._modifiedEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);
  }
  revealRange(range2, scrollType = 0, revealVerticalInCenter = false, revealHorizontal = true) {
    this._modifiedEditor.revealRange(range2, scrollType, revealVerticalInCenter, revealHorizontal);
  }
  revealRangeInCenter(range2, scrollType = 0) {
    this._modifiedEditor.revealRangeInCenter(range2, scrollType);
  }
  revealRangeInCenterIfOutsideViewport(range2, scrollType = 0) {
    this._modifiedEditor.revealRangeInCenterIfOutsideViewport(range2, scrollType);
  }
  revealRangeNearTop(range2, scrollType = 0) {
    this._modifiedEditor.revealRangeNearTop(range2, scrollType);
  }
  revealRangeNearTopIfOutsideViewport(range2, scrollType = 0) {
    this._modifiedEditor.revealRangeNearTopIfOutsideViewport(range2, scrollType);
  }
  revealRangeAtTop(range2, scrollType = 0) {
    this._modifiedEditor.revealRangeAtTop(range2, scrollType);
  }
  getSupportedActions() {
    return this._modifiedEditor.getSupportedActions();
  }
  saveViewState() {
    const originalViewState = this._originalEditor.saveViewState();
    const modifiedViewState = this._modifiedEditor.saveViewState();
    return {
      original: originalViewState,
      modified: modifiedViewState
    };
  }
  restoreViewState(s) {
    if (s && s.original && s.modified) {
      const diffEditorState = s;
      this._originalEditor.restoreViewState(diffEditorState.original);
      this._modifiedEditor.restoreViewState(diffEditorState.modified);
    }
  }
  layout(dimension) {
    this._elementSizeObserver.observe(dimension);
  }
  focus() {
    this._modifiedEditor.focus();
  }
  hasTextFocus() {
    return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
  }
  trigger(source, handlerId, payload) {
    this._modifiedEditor.trigger(source, handlerId, payload);
  }
  changeDecorations(callback) {
    return this._modifiedEditor.changeDecorations(callback);
  }
  _onDidContainerSizeChanged() {
    this._doLayout();
  }
  _getReviewHeight() {
    return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
  }
  _layoutOverviewRulers() {
    if (!this._renderOverviewRuler) {
      return;
    }
    if (!this._originalOverviewRuler || !this._modifiedOverviewRuler) {
      return;
    }
    const height = this._elementSizeObserver.getHeight();
    const reviewHeight = this._getReviewHeight();
    const freeSpace = DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
    const layoutInfo = this._modifiedEditor.getLayoutInfo();
    if (layoutInfo) {
      this._originalOverviewRuler.setLayout({
        top: 0,
        width: DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        right: freeSpace + DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        height: height - reviewHeight
      });
      this._modifiedOverviewRuler.setLayout({
        top: 0,
        right: 0,
        width: DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        height: height - reviewHeight
      });
    }
  }
  _onViewZonesChanged() {
    if (this._currentlyChangingViewZones) {
      return;
    }
    this._updateDecorationsRunner.schedule();
  }
  _beginUpdateDecorationsSoon() {
    if (this._beginUpdateDecorationsTimeout !== -1) {
      window.clearTimeout(this._beginUpdateDecorationsTimeout);
      this._beginUpdateDecorationsTimeout = -1;
    }
    this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), DiffEditorWidget2.UPDATE_DIFF_DECORATIONS_DELAY);
  }
  static _equals(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.toString() === b.toString();
  }
  _beginUpdateDecorations() {
    this._beginUpdateDecorationsTimeout = -1;
    const currentOriginalModel = this._originalEditor.getModel();
    const currentModifiedModel = this._modifiedEditor.getModel();
    if (!currentOriginalModel || !currentModifiedModel) {
      return;
    }
    this._diffComputationToken++;
    const currentToken = this._diffComputationToken;
    this._setState(1);
    if (!this._editorWorkerService.canComputeDiff(currentOriginalModel.uri, currentModifiedModel.uri)) {
      if (!DiffEditorWidget2._equals(currentOriginalModel.uri, this._lastOriginalWarning) || !DiffEditorWidget2._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {
        this._lastOriginalWarning = currentOriginalModel.uri;
        this._lastModifiedWarning = currentModifiedModel.uri;
        this._notificationService.warn(localize("diff.tooLarge", "Cannot compare files because one file is too large."));
      }
      return;
    }
    this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace, this._maxComputationTime).then((result) => {
      if (currentToken === this._diffComputationToken && currentOriginalModel === this._originalEditor.getModel() && currentModifiedModel === this._modifiedEditor.getModel()) {
        this._setState(2);
        this._diffComputationResult = result;
        this._updateDecorationsRunner.schedule();
        this._onDidUpdateDiff.fire();
      }
    }, (error) => {
      if (currentToken === this._diffComputationToken && currentOriginalModel === this._originalEditor.getModel() && currentModifiedModel === this._modifiedEditor.getModel()) {
        this._setState(2);
        this._diffComputationResult = null;
        this._updateDecorationsRunner.schedule();
      }
    });
  }
  _cleanViewZonesAndDecorations() {
    this._originalEditorState.clean(this._originalEditor);
    this._modifiedEditorState.clean(this._modifiedEditor);
  }
  _updateDecorations() {
    if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel()) {
      return;
    }
    const lineChanges = this._diffComputationResult ? this._diffComputationResult.changes : [];
    const foreignOriginal = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces());
    const foreignModified = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces());
    const diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, this._renderIndicators, foreignOriginal, foreignModified);
    try {
      this._currentlyChangingViewZones = true;
      this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, diffDecorations.original, false);
      this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);
    } finally {
      this._currentlyChangingViewZones = false;
    }
  }
  _adjustOptionsForSubEditor(options) {
    const clonedOptions = Object.assign({}, options);
    clonedOptions.inDiffEditor = true;
    clonedOptions.automaticLayout = false;
    clonedOptions.scrollbar = Object.assign({}, clonedOptions.scrollbar || {});
    clonedOptions.scrollbar.vertical = "visible";
    clonedOptions.folding = false;
    clonedOptions.codeLens = this._diffCodeLens;
    clonedOptions.fixedOverflowWidgets = true;
    clonedOptions.minimap = Object.assign({}, clonedOptions.minimap || {});
    clonedOptions.minimap.enabled = false;
    return clonedOptions;
  }
  _adjustOptionsForLeftHandSide(options) {
    const result = this._adjustOptionsForSubEditor(options);
    if (!this._renderSideBySide) {
      result.wordWrapOverride1 = "off";
    } else {
      result.wordWrapOverride1 = this._diffWordWrap;
    }
    if (options.originalAriaLabel) {
      result.ariaLabel = options.originalAriaLabel;
    }
    result.readOnly = !this._originalIsEditable;
    result.extraEditorClassName = "original-in-monaco-diff-editor";
    return Object.assign(Object.assign({}, result), { dimension: {
      height: 0,
      width: 0
    } });
  }
  _adjustOptionsForRightHandSide(options) {
    const result = this._adjustOptionsForSubEditor(options);
    if (options.modifiedAriaLabel) {
      result.ariaLabel = options.modifiedAriaLabel;
    }
    result.wordWrapOverride1 = this._diffWordWrap;
    result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH;
    result.scrollbar.verticalHasArrows = false;
    result.extraEditorClassName = "modified-in-monaco-diff-editor";
    return Object.assign(Object.assign({}, result), { dimension: {
      height: 0,
      width: 0
    } });
  }
  doLayout() {
    this._elementSizeObserver.observe();
    this._doLayout();
  }
  _doLayout() {
    const width = this._elementSizeObserver.getWidth();
    const height = this._elementSizeObserver.getHeight();
    const reviewHeight = this._getReviewHeight();
    const splitPoint = this._strategy.layout();
    this._originalDomNode.style.width = splitPoint + "px";
    this._originalDomNode.style.left = "0px";
    this._modifiedDomNode.style.width = width - splitPoint + "px";
    this._modifiedDomNode.style.left = splitPoint + "px";
    this._overviewDomElement.style.top = "0px";
    this._overviewDomElement.style.height = height - reviewHeight + "px";
    this._overviewDomElement.style.width = DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH + "px";
    this._overviewDomElement.style.left = width - DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH + "px";
    this._overviewViewportDomElement.setWidth(DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH);
    this._overviewViewportDomElement.setHeight(30);
    this._originalEditor.layout({ width: splitPoint, height: height - reviewHeight });
    this._modifiedEditor.layout({ width: width - splitPoint - (this._renderOverviewRuler ? DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: height - reviewHeight });
    if (this._originalOverviewRuler || this._modifiedOverviewRuler) {
      this._layoutOverviewRulers();
    }
    this._reviewPane.layout(height - reviewHeight, width, reviewHeight);
    this._layoutOverviewViewport();
  }
  _layoutOverviewViewport() {
    const layout2 = this._computeOverviewViewport();
    if (!layout2) {
      this._overviewViewportDomElement.setTop(0);
      this._overviewViewportDomElement.setHeight(0);
    } else {
      this._overviewViewportDomElement.setTop(layout2.top);
      this._overviewViewportDomElement.setHeight(layout2.height);
    }
  }
  _computeOverviewViewport() {
    const layoutInfo = this._modifiedEditor.getLayoutInfo();
    if (!layoutInfo) {
      return null;
    }
    const scrollTop = this._modifiedEditor.getScrollTop();
    const scrollHeight = this._modifiedEditor.getScrollHeight();
    const computedAvailableSize = Math.max(0, layoutInfo.height);
    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);
    const computedRatio = scrollHeight > 0 ? computedRepresentableSize / scrollHeight : 0;
    const computedSliderSize = Math.max(0, Math.floor(layoutInfo.height * computedRatio));
    const computedSliderPosition = Math.floor(scrollTop * computedRatio);
    return {
      height: computedSliderSize,
      top: computedSliderPosition
    };
  }
  _createDataSource() {
    return {
      getWidth: () => {
        return this._elementSizeObserver.getWidth();
      },
      getHeight: () => {
        return this._elementSizeObserver.getHeight() - this._getReviewHeight();
      },
      getOptions: () => {
        return {
          renderOverviewRuler: this._renderOverviewRuler
        };
      },
      getContainerDomNode: () => {
        return this._containerDomElement;
      },
      relayoutEditors: () => {
        this._doLayout();
      },
      getOriginalEditor: () => {
        return this._originalEditor;
      },
      getModifiedEditor: () => {
        return this._modifiedEditor;
      }
    };
  }
  _setStrategy(newStrategy) {
    if (this._strategy) {
      this._strategy.dispose();
    }
    this._strategy = newStrategy;
    newStrategy.applyColors(this._themeService.getColorTheme());
    if (this._diffComputationResult) {
      this._updateDecorations();
    }
    this._doLayout();
  }
  _getLineChangeAtOrBeforeLineNumber(lineNumber, startLineNumberExtractor) {
    const lineChanges = this._diffComputationResult ? this._diffComputationResult.changes : [];
    if (lineChanges.length === 0 || lineNumber < startLineNumberExtractor(lineChanges[0])) {
      return null;
    }
    let min = 0;
    let max = lineChanges.length - 1;
    while (min < max) {
      const mid = Math.floor((min + max) / 2);
      const midStart = startLineNumberExtractor(lineChanges[mid]);
      const midEnd = mid + 1 <= max ? startLineNumberExtractor(lineChanges[mid + 1]) : 1073741824;
      if (lineNumber < midStart) {
        max = mid - 1;
      } else if (lineNumber >= midEnd) {
        min = mid + 1;
      } else {
        min = mid;
        max = mid;
      }
    }
    return lineChanges[min];
  }
  _getEquivalentLineForOriginalLineNumber(lineNumber) {
    const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange2) => lineChange2.originalStartLineNumber);
    if (!lineChange) {
      return lineNumber;
    }
    const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
    const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
    const lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1 : 0;
    const lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1 : 0;
    const delta = lineNumber - originalEquivalentLineNumber;
    if (delta <= lineChangeOriginalLength) {
      return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);
    }
    return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;
  }
  _getEquivalentLineForModifiedLineNumber(lineNumber) {
    const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange2) => lineChange2.modifiedStartLineNumber);
    if (!lineChange) {
      return lineNumber;
    }
    const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
    const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
    const lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1 : 0;
    const lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1 : 0;
    const delta = lineNumber - modifiedEquivalentLineNumber;
    if (delta <= lineChangeModifiedLength) {
      return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);
    }
    return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;
  }
  getDiffLineInformationForOriginal(lineNumber) {
    if (!this._diffComputationResult) {
      return null;
    }
    return {
      equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)
    };
  }
  getDiffLineInformationForModified(lineNumber) {
    if (!this._diffComputationResult) {
      return null;
    }
    return {
      equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)
    };
  }
};
DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200;
DiffEditorWidget = __decorate4([
  __param4(3, IClipboardService),
  __param4(4, IEditorWorkerService),
  __param4(5, IContextKeyService),
  __param4(6, IInstantiationService),
  __param4(7, ICodeEditorService),
  __param4(8, IThemeService),
  __param4(9, INotificationService),
  __param4(10, IContextMenuService),
  __param4(11, IEditorProgressService)
], DiffEditorWidget);
var DiffEditorWidgetStyle = class extends Disposable {
  constructor(dataSource) {
    super();
    this._dataSource = dataSource;
    this._insertColor = null;
    this._removeColor = null;
  }
  applyColors(theme) {
    const newInsertColor = (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);
    const newRemoveColor = (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);
    const hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);
    this._insertColor = newInsertColor;
    this._removeColor = newRemoveColor;
    return hasChanges;
  }
  getEditorsDiffDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces) {
    modifiedWhitespaces = modifiedWhitespaces.sort((a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    });
    originalWhitespaces = originalWhitespaces.sort((a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    });
    const zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, renderIndicators);
    const originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators);
    const modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators);
    return {
      original: {
        decorations: originalDecorations.decorations,
        overviewZones: originalDecorations.overviewZones,
        zones: zones.original
      },
      modified: {
        decorations: modifiedDecorations.decorations,
        overviewZones: modifiedDecorations.overviewZones,
        zones: zones.modified
      }
    };
  }
};
var ForeignViewZonesIterator = class {
  constructor(source) {
    this._source = source;
    this._index = -1;
    this.current = null;
    this.advance();
  }
  advance() {
    this._index++;
    if (this._index < this._source.length) {
      this.current = this._source[this._index];
    } else {
      this.current = null;
    }
  }
};
var ViewZonesComputer = class {
  constructor(_lineChanges, _originalForeignVZ, _modifiedForeignVZ, _originalEditor, _modifiedEditor) {
    this._lineChanges = _lineChanges;
    this._originalForeignVZ = _originalForeignVZ;
    this._modifiedForeignVZ = _modifiedForeignVZ;
    this._originalEditor = _originalEditor;
    this._modifiedEditor = _modifiedEditor;
  }
  static _getViewLineCount(editor2, startLineNumber, endLineNumber) {
    const model = editor2.getModel();
    const viewModel = editor2._getViewModel();
    if (model && viewModel) {
      const viewRange = getViewRange(model, viewModel, startLineNumber, endLineNumber);
      return viewRange.endLineNumber - viewRange.startLineNumber + 1;
    }
    return endLineNumber - startLineNumber + 1;
  }
  getViewZones() {
    const originalLineHeight = this._originalEditor.getOption(57);
    const modifiedLineHeight = this._modifiedEditor.getOption(57);
    const originalHasWrapping = this._originalEditor.getOption(130).wrappingColumn !== -1;
    const modifiedHasWrapping = this._modifiedEditor.getOption(130).wrappingColumn !== -1;
    const hasWrapping = originalHasWrapping || modifiedHasWrapping;
    const originalModel = this._originalEditor.getModel();
    const originalCoordinatesConverter = this._originalEditor._getViewModel().coordinatesConverter;
    const modifiedCoordinatesConverter = this._modifiedEditor._getViewModel().coordinatesConverter;
    const result = {
      original: [],
      modified: []
    };
    let lineChangeModifiedLength = 0;
    let lineChangeOriginalLength = 0;
    let originalEquivalentLineNumber = 0;
    let modifiedEquivalentLineNumber = 0;
    let originalEndEquivalentLineNumber = 0;
    let modifiedEndEquivalentLineNumber = 0;
    const sortMyViewZones = (a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    };
    const addAndCombineIfPossible = (destination, item) => {
      if (item.domNode === null && destination.length > 0) {
        const lastItem = destination[destination.length - 1];
        if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {
          lastItem.heightInLines += item.heightInLines;
          return;
        }
      }
      destination.push(item);
    };
    const modifiedForeignVZ = new ForeignViewZonesIterator(this._modifiedForeignVZ);
    const originalForeignVZ = new ForeignViewZonesIterator(this._originalForeignVZ);
    let lastOriginalLineNumber = 1;
    let lastModifiedLineNumber = 1;
    for (let i = 0, length = this._lineChanges.length; i <= length; i++) {
      const lineChange = i < length ? this._lineChanges[i] : null;
      if (lineChange !== null) {
        originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
        modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
        lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._originalEditor, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber) : 0;
        lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._modifiedEditor, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber) : 0;
        originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
        modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
      } else {
        originalEquivalentLineNumber += 1e7 + lineChangeOriginalLength;
        modifiedEquivalentLineNumber += 1e7 + lineChangeModifiedLength;
        originalEndEquivalentLineNumber = originalEquivalentLineNumber;
        modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;
      }
      let stepOriginal = [];
      let stepModified = [];
      if (hasWrapping) {
        let count;
        if (lineChange) {
          if (lineChange.originalEndLineNumber > 0) {
            count = lineChange.originalStartLineNumber - lastOriginalLineNumber;
          } else {
            count = lineChange.modifiedStartLineNumber - lastModifiedLineNumber;
          }
        } else {
          count = originalModel.getLineCount() - lastOriginalLineNumber;
        }
        for (let i2 = 0; i2 < count; i2++) {
          const originalLineNumber = lastOriginalLineNumber + i2;
          const modifiedLineNumber = lastModifiedLineNumber + i2;
          const originalViewLineCount = originalCoordinatesConverter.getModelLineViewLineCount(originalLineNumber);
          const modifiedViewLineCount = modifiedCoordinatesConverter.getModelLineViewLineCount(modifiedLineNumber);
          if (originalViewLineCount < modifiedViewLineCount) {
            stepOriginal.push({
              afterLineNumber: originalLineNumber,
              heightInLines: modifiedViewLineCount - originalViewLineCount,
              domNode: null,
              marginDomNode: null
            });
          } else if (originalViewLineCount > modifiedViewLineCount) {
            stepModified.push({
              afterLineNumber: modifiedLineNumber,
              heightInLines: originalViewLineCount - modifiedViewLineCount,
              domNode: null,
              marginDomNode: null
            });
          }
        }
        if (lineChange) {
          lastOriginalLineNumber = (lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber : lineChange.originalStartLineNumber) + 1;
          lastModifiedLineNumber = (lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber : lineChange.modifiedStartLineNumber) + 1;
        }
      }
      while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {
        let viewZoneLineNumber;
        if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {
          viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;
        } else {
          viewZoneLineNumber = originalEndEquivalentLineNumber;
        }
        let marginDomNode = null;
        if (lineChange && lineChange.modifiedStartLineNumber <= modifiedForeignVZ.current.afterLineNumber && modifiedForeignVZ.current.afterLineNumber <= lineChange.modifiedEndLineNumber) {
          marginDomNode = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion();
        }
        stepOriginal.push({
          afterLineNumber: viewZoneLineNumber,
          heightInLines: modifiedForeignVZ.current.height / modifiedLineHeight,
          domNode: null,
          marginDomNode
        });
        modifiedForeignVZ.advance();
      }
      while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {
        let viewZoneLineNumber;
        if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {
          viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;
        } else {
          viewZoneLineNumber = modifiedEndEquivalentLineNumber;
        }
        stepModified.push({
          afterLineNumber: viewZoneLineNumber,
          heightInLines: originalForeignVZ.current.height / originalLineHeight,
          domNode: null
        });
        originalForeignVZ.advance();
      }
      if (lineChange !== null && isChangeOrInsert(lineChange)) {
        const r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
        if (r) {
          stepOriginal.push(r);
        }
      }
      if (lineChange !== null && isChangeOrDelete(lineChange)) {
        const r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
        if (r) {
          stepModified.push(r);
        }
      }
      let stepOriginalIndex = 0;
      let stepModifiedIndex = 0;
      stepOriginal = stepOriginal.sort(sortMyViewZones);
      stepModified = stepModified.sort(sortMyViewZones);
      while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {
        const original = stepOriginal[stepOriginalIndex];
        const modified = stepModified[stepModifiedIndex];
        const originalDelta = original.afterLineNumber - originalEquivalentLineNumber;
        const modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;
        if (originalDelta < modifiedDelta) {
          addAndCombineIfPossible(result.original, original);
          stepOriginalIndex++;
        } else if (modifiedDelta < originalDelta) {
          addAndCombineIfPossible(result.modified, modified);
          stepModifiedIndex++;
        } else if (original.shouldNotShrink) {
          addAndCombineIfPossible(result.original, original);
          stepOriginalIndex++;
        } else if (modified.shouldNotShrink) {
          addAndCombineIfPossible(result.modified, modified);
          stepModifiedIndex++;
        } else {
          if (original.heightInLines >= modified.heightInLines) {
            original.heightInLines -= modified.heightInLines;
            stepModifiedIndex++;
          } else {
            modified.heightInLines -= original.heightInLines;
            stepOriginalIndex++;
          }
        }
      }
      while (stepOriginalIndex < stepOriginal.length) {
        addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);
        stepOriginalIndex++;
      }
      while (stepModifiedIndex < stepModified.length) {
        addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);
        stepModifiedIndex++;
      }
    }
    return {
      original: ViewZonesComputer._ensureDomNodes(result.original),
      modified: ViewZonesComputer._ensureDomNodes(result.modified)
    };
  }
  static _ensureDomNodes(zones) {
    return zones.map((z) => {
      if (!z.domNode) {
        z.domNode = createFakeLinesDiv();
      }
      return z;
    });
  }
};
function createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {
  return {
    range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),
    options
  };
}
var DECORATIONS = {
  charDelete: ModelDecorationOptions.register({
    description: "diff-editor-char-delete",
    className: "char-delete"
  }),
  charDeleteWholeLine: ModelDecorationOptions.register({
    description: "diff-editor-char-delete-whole-line",
    className: "char-delete",
    isWholeLine: true
  }),
  charInsert: ModelDecorationOptions.register({
    description: "diff-editor-char-insert",
    className: "char-insert"
  }),
  charInsertWholeLine: ModelDecorationOptions.register({
    description: "diff-editor-char-insert-whole-line",
    className: "char-insert",
    isWholeLine: true
  }),
  lineInsert: ModelDecorationOptions.register({
    description: "diff-editor-line-insert",
    className: "line-insert",
    marginClassName: "line-insert",
    isWholeLine: true
  }),
  lineInsertWithSign: ModelDecorationOptions.register({
    description: "diff-editor-line-insert-with-sign",
    className: "line-insert",
    linesDecorationsClassName: "insert-sign " + ThemeIcon.asClassName(diffInsertIcon),
    marginClassName: "line-insert",
    isWholeLine: true
  }),
  lineDelete: ModelDecorationOptions.register({
    description: "diff-editor-line-delete",
    className: "line-delete",
    marginClassName: "line-delete",
    isWholeLine: true
  }),
  lineDeleteWithSign: ModelDecorationOptions.register({
    description: "diff-editor-line-delete-with-sign",
    className: "line-delete",
    linesDecorationsClassName: "delete-sign " + ThemeIcon.asClassName(diffRemoveIcon),
    marginClassName: "line-delete",
    isWholeLine: true
  }),
  lineDeleteMargin: ModelDecorationOptions.register({
    description: "diff-editor-line-delete-margin",
    marginClassName: "line-delete"
  })
};
var DiffEditorWidgetSideBySide = class extends DiffEditorWidgetStyle {
  constructor(dataSource, enableSplitViewResizing) {
    super(dataSource);
    this._disableSash = enableSplitViewResizing === false;
    this._sashRatio = null;
    this._sashPosition = null;
    this._startSashPosition = null;
    this._sash = this._register(new Sash(this._dataSource.getContainerDomNode(), this, { orientation: 0 }));
    if (this._disableSash) {
      this._sash.state = 0;
    }
    this._sash.onDidStart(() => this._onSashDragStart());
    this._sash.onDidChange((e) => this._onSashDrag(e));
    this._sash.onDidEnd(() => this._onSashDragEnd());
    this._sash.onDidReset(() => this._onSashReset());
  }
  setEnableSplitViewResizing(enableSplitViewResizing) {
    const newDisableSash = enableSplitViewResizing === false;
    if (this._disableSash !== newDisableSash) {
      this._disableSash = newDisableSash;
      this._sash.state = this._disableSash ? 0 : 3;
    }
  }
  layout(sashRatio = this._sashRatio) {
    const w = this._dataSource.getWidth();
    const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
    let sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
    const midPoint = Math.floor(0.5 * contentWidth);
    sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;
    if (contentWidth > DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {
      if (sashPosition < DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
        sashPosition = DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
      }
      if (sashPosition > contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
        sashPosition = contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
      }
    } else {
      sashPosition = midPoint;
    }
    if (this._sashPosition !== sashPosition) {
      this._sashPosition = sashPosition;
      this._sash.layout();
    }
    return this._sashPosition;
  }
  _onSashDragStart() {
    this._startSashPosition = this._sashPosition;
  }
  _onSashDrag(e) {
    const w = this._dataSource.getWidth();
    const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
    const sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);
    this._sashRatio = sashPosition / contentWidth;
    this._dataSource.relayoutEditors();
  }
  _onSashDragEnd() {
    this._sash.layout();
  }
  _onSashReset() {
    this._sashRatio = 0.5;
    this._dataSource.relayoutEditors();
    this._sash.layout();
  }
  getVerticalSashTop(sash) {
    return 0;
  }
  getVerticalSashLeft(sash) {
    return this._sashPosition;
  }
  getVerticalSashHeight(sash) {
    return this._dataSource.getHeight();
  }
  _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ) {
    const originalEditor = this._dataSource.getOriginalEditor();
    const modifiedEditor = this._dataSource.getModifiedEditor();
    const c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);
    return c.getViewZones();
  }
  _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {
    const originalEditor = this._dataSource.getOriginalEditor();
    const overviewZoneColor = String(this._removeColor);
    const result = {
      decorations: [],
      overviewZones: []
    };
    const originalModel = originalEditor.getModel();
    const originalViewModel = originalEditor._getViewModel();
    for (const lineChange of lineChanges) {
      if (isChangeOrDelete(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete
        });
        if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {
          result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824, DECORATIONS.charDeleteWholeLine));
        }
        const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
        result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (const charChange of lineChange.charChanges) {
            if (isChangeOrDelete(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.originalStartLineNumber) {
                    startColumn = charChange.originalStartColumn;
                  } else {
                    startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.originalEndLineNumber) {
                    endColumn = charChange.originalEndColumn;
                  } else {
                    endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));
                }
              } else {
                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));
              }
            }
          }
        }
      }
    }
    return result;
  }
  _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {
    const modifiedEditor = this._dataSource.getModifiedEditor();
    const overviewZoneColor = String(this._insertColor);
    const result = {
      decorations: [],
      overviewZones: []
    };
    const modifiedModel = modifiedEditor.getModel();
    const modifiedViewModel = modifiedEditor._getViewModel();
    for (const lineChange of lineChanges) {
      if (isChangeOrInsert(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert
        });
        if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {
          result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824, DECORATIONS.charInsertWholeLine));
        }
        const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
        result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (const charChange of lineChange.charChanges) {
            if (isChangeOrInsert(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.modifiedStartLineNumber) {
                    startColumn = charChange.modifiedStartColumn;
                  } else {
                    startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.modifiedEndLineNumber) {
                    endColumn = charChange.modifiedEndColumn;
                  } else {
                    endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                }
              } else {
                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
              }
            }
          }
        }
      }
    }
    return result;
  }
};
DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;
var SideBySideViewZonesComputer = class extends ViewZonesComputer {
  constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
    super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    return null;
  }
  _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    if (lineChangeModifiedLength > lineChangeOriginalLength) {
      return {
        afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
        heightInLines: lineChangeModifiedLength - lineChangeOriginalLength,
        domNode: null
      };
    }
    return null;
  }
  _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    if (lineChangeOriginalLength > lineChangeModifiedLength) {
      return {
        afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),
        heightInLines: lineChangeOriginalLength - lineChangeModifiedLength,
        domNode: null
      };
    }
    return null;
  }
};
var DiffEditorWidgetInline = class extends DiffEditorWidgetStyle {
  constructor(dataSource, enableSplitViewResizing) {
    super(dataSource);
    this._decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;
    this._register(dataSource.getOriginalEditor().onDidLayoutChange((layoutInfo) => {
      if (this._decorationsLeft !== layoutInfo.decorationsLeft) {
        this._decorationsLeft = layoutInfo.decorationsLeft;
        dataSource.relayoutEditors();
      }
    }));
  }
  setEnableSplitViewResizing(enableSplitViewResizing) {
  }
  _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, renderIndicators) {
    const originalEditor = this._dataSource.getOriginalEditor();
    const modifiedEditor = this._dataSource.getModifiedEditor();
    const computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);
    return computer.getViewZones();
  }
  _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {
    const overviewZoneColor = String(this._removeColor);
    const result = {
      decorations: [],
      overviewZones: []
    };
    const originalEditor = this._dataSource.getOriginalEditor();
    const originalModel = originalEditor.getModel();
    const originalViewModel = originalEditor._getViewModel();
    for (const lineChange of lineChanges) {
      if (isChangeOrDelete(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824),
          options: DECORATIONS.lineDeleteMargin
        });
        const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
        result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));
      }
    }
    return result;
  }
  _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {
    const modifiedEditor = this._dataSource.getModifiedEditor();
    const overviewZoneColor = String(this._insertColor);
    const result = {
      decorations: [],
      overviewZones: []
    };
    const modifiedModel = modifiedEditor.getModel();
    const modifiedViewModel = modifiedEditor._getViewModel();
    for (const lineChange of lineChanges) {
      if (isChangeOrInsert(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert
        });
        const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
        result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (const charChange of lineChange.charChanges) {
            if (isChangeOrInsert(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.modifiedStartLineNumber) {
                    startColumn = charChange.modifiedStartColumn;
                  } else {
                    startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.modifiedEndLineNumber) {
                    endColumn = charChange.modifiedEndColumn;
                  } else {
                    endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                }
              } else {
                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
              }
            }
          }
        } else {
          result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824, DECORATIONS.charInsertWholeLine));
        }
      }
    }
    return result;
  }
  layout() {
    return Math.max(5, this._decorationsLeft);
  }
};
var InlineViewZonesComputer = class extends ViewZonesComputer {
  constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
    super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);
    this._originalModel = originalEditor.getModel();
    this._renderIndicators = renderIndicators;
    this._pendingLineChange = [];
    this._pendingViewZones = [];
    this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();
  }
  getViewZones() {
    const result = super.getViewZones();
    this._finalize(result);
    return result;
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    const result = document.createElement("div");
    result.className = "inline-added-margin-view-zone";
    return result;
  }
  _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    const marginDomNode = document.createElement("div");
    marginDomNode.className = "inline-added-margin-view-zone";
    return {
      afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
      heightInLines: lineChangeModifiedLength,
      domNode: document.createElement("div"),
      marginDomNode
    };
  }
  _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    const domNode = document.createElement("div");
    domNode.className = `view-lines line-delete ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`;
    const marginDomNode = document.createElement("div");
    marginDomNode.className = "inline-deleted-margin-view-zone";
    const viewZone = {
      shouldNotShrink: true,
      afterLineNumber: lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1,
      heightInLines: lineChangeOriginalLength,
      minWidthInPx: 0,
      domNode,
      marginDomNode,
      diff: {
        originalStartLineNumber: lineChange.originalStartLineNumber,
        originalEndLineNumber: lineChange.originalEndLineNumber,
        modifiedStartLineNumber: lineChange.modifiedStartLineNumber,
        modifiedEndLineNumber: lineChange.modifiedEndLineNumber,
        originalModel: this._originalModel,
        viewLineCounts: null
      }
    };
    for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
      this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(lineNumber), null, null);
    }
    this._pendingLineChange.push(lineChange);
    this._pendingViewZones.push(viewZone);
    return viewZone;
  }
  _finalize(result) {
    const modifiedEditorOptions = this._modifiedEditor.getOptions();
    const tabSize = this._modifiedEditor.getModel().getOptions().tabSize;
    const fontInfo = modifiedEditorOptions.get(41);
    const disableMonospaceOptimizations = modifiedEditorOptions.get(27);
    const typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    const scrollBeyondLastColumn = modifiedEditorOptions.get(92);
    const mightContainNonBasicASCII = this._originalModel.mightContainNonBasicASCII();
    const mightContainRTL = this._originalModel.mightContainRTL();
    const lineHeight = modifiedEditorOptions.get(57);
    const layoutInfo = modifiedEditorOptions.get(129);
    const lineDecorationsWidth = layoutInfo.decorationsWidth;
    const stopRenderingLineAfter = modifiedEditorOptions.get(104);
    const renderWhitespace = modifiedEditorOptions.get(87);
    const renderControlCharacters = modifiedEditorOptions.get(81);
    const fontLigatures = modifiedEditorOptions.get(42);
    const lineBreaks = this._lineBreaksComputer.finalize();
    let lineBreakIndex = 0;
    for (let i = 0; i < this._pendingLineChange.length; i++) {
      const lineChange = this._pendingLineChange[i];
      const viewZone = this._pendingViewZones[i];
      const domNode = viewZone.domNode;
      Configuration.applyFontInfoSlow(domNode, fontInfo);
      const marginDomNode = viewZone.marginDomNode;
      Configuration.applyFontInfoSlow(marginDomNode, fontInfo);
      const decorations = [];
      if (lineChange.charChanges) {
        for (const charChange of lineChange.charChanges) {
          if (isChangeOrDelete(charChange)) {
            decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), "char-delete", 0));
          }
        }
      }
      const hasCharChanges = decorations.length > 0;
      const sb = createStringBuilder(1e4);
      let maxCharsPerLine = 0;
      let renderedLineCount = 0;
      let viewLineCounts = null;
      for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
        const lineIndex = lineNumber - lineChange.originalStartLineNumber;
        const lineTokens = this._originalModel.getLineTokens(lineNumber);
        const lineContent = lineTokens.getLineContent();
        const lineBreakData = lineBreaks[lineBreakIndex++];
        const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);
        if (lineBreakData) {
          let lastBreakOffset = 0;
          for (const breakOffset of lineBreakData.breakOffsets) {
            const viewLineTokens = lineTokens.sliceAndInflate(lastBreakOffset, breakOffset, 0);
            const viewLineContent = lineContent.substring(lastBreakOffset, breakOffset);
            maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, viewLineContent, viewLineTokens, LineDecoration.extractWrapped(actualDecorations, lastBreakOffset, breakOffset), hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));
            lastBreakOffset = breakOffset;
          }
          if (!viewLineCounts) {
            viewLineCounts = [];
          }
          while (viewLineCounts.length < lineIndex) {
            viewLineCounts[viewLineCounts.length] = 1;
          }
          viewLineCounts[lineIndex] = lineBreakData.breakOffsets.length;
          viewZone.heightInLines += lineBreakData.breakOffsets.length - 1;
          const marginDomNode2 = document.createElement("div");
          marginDomNode2.className = "line-delete";
          result.original.push({
            afterLineNumber: lineNumber,
            afterColumn: 0,
            heightInLines: lineBreakData.breakOffsets.length - 1,
            domNode: createFakeLinesDiv(),
            marginDomNode: marginDomNode2
          });
        } else {
          maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, lineContent, lineTokens, actualDecorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));
        }
      }
      maxCharsPerLine += scrollBeyondLastColumn;
      const html = sb.build();
      const trustedhtml = ttPolicy3 ? ttPolicy3.createHTML(html) : html;
      domNode.innerHTML = trustedhtml;
      viewZone.minWidthInPx = maxCharsPerLine * typicalHalfwidthCharacterWidth;
      if (viewLineCounts) {
        const cnt = lineChange.originalEndLineNumber - lineChange.originalStartLineNumber;
        while (viewLineCounts.length <= cnt) {
          viewLineCounts[viewLineCounts.length] = 1;
        }
      }
      viewZone.diff.viewLineCounts = viewLineCounts;
    }
    result.original.sort((a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    });
  }
  _renderOriginalLine(renderedLineCount, lineContent, lineTokens, decorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode) {
    sb.appendASCIIString('<div class="view-line');
    if (!hasCharChanges) {
      sb.appendASCIIString(" char-delete");
    }
    sb.appendASCIIString('" style="top:');
    sb.appendASCIIString(String(renderedLineCount * lineHeight));
    sb.appendASCIIString('px;width:1000000px;">');
    const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, mightContainNonBasicASCII);
    const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, mightContainRTL);
    const output = renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
    sb.appendASCIIString("</div>");
    if (this._renderIndicators) {
      const marginElement = document.createElement("div");
      marginElement.className = `delete-sign ${ThemeIcon.asClassName(diffRemoveIcon)}`;
      marginElement.setAttribute("style", `position:absolute;top:${renderedLineCount * lineHeight}px;width:${lineDecorationsWidth}px;height:${lineHeight}px;right:0;`);
      marginDomNode.appendChild(marginElement);
    }
    return output.characterMapping.getAbsoluteOffset(output.characterMapping.length);
  }
};
function validateDiffWordWrap(value, defaultValue) {
  return stringSet(value, defaultValue, ["off", "on", "inherit"]);
}
function isChangeOrInsert(lineChange) {
  return lineChange.modifiedEndLineNumber > 0;
}
function isChangeOrDelete(lineChange) {
  return lineChange.originalEndLineNumber > 0;
}
function createFakeLinesDiv() {
  const r = document.createElement("div");
  r.className = "diagonal-fill";
  return r;
}
function getViewRange(model, viewModel, startLineNumber, endLineNumber) {
  const lineCount = model.getLineCount();
  startLineNumber = Math.min(lineCount, Math.max(1, startLineNumber));
  endLineNumber = Math.min(lineCount, Math.max(1, endLineNumber));
  return viewModel.coordinatesConverter.convertModelRangeToViewRange(new Range(startLineNumber, model.getLineMinColumn(startLineNumber), endLineNumber, model.getLineMaxColumn(endLineNumber)));
}
registerThemingParticipant((theme, collector) => {
  const added = theme.getColor(diffInserted);
  if (added) {
    collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { background-color: ${added}; }`);
    collector.addRule(`.monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: ${added}; }`);
    collector.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${added}; }`);
  }
  const removed = theme.getColor(diffRemoved);
  if (removed) {
    collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { background-color: ${removed}; }`);
    collector.addRule(`.monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: ${removed}; }`);
    collector.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${removed}; }`);
  }
  const addedOutline = theme.getColor(diffInsertedOutline);
  if (addedOutline) {
    collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${addedOutline}; }`);
  }
  const removedOutline = theme.getColor(diffRemovedOutline);
  if (removedOutline) {
    collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${removedOutline}; }`);
  }
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${shadow}; }`);
  }
  const border = theme.getColor(diffBorder);
  if (border) {
    collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${border}; }`);
  }
  const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);
  if (scrollbarSliderBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${scrollbarSliderBackgroundColor};
			}
		`);
  }
  const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);
  if (scrollbarSliderHoverBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${scrollbarSliderHoverBackgroundColor};
			}
		`);
  }
  const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);
  if (scrollbarSliderActiveBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${scrollbarSliderActiveBackgroundColor};
			}
		`);
  }
  const diffDiagonalFillColor = theme.getColor(diffDiagonalFill);
  collector.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${diffDiagonalFillColor} 12.5%,
			#0000 12.5%, #0000 50%,
			${diffDiagonalFillColor} 50%, ${diffDiagonalFillColor} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
});

// node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneThemeService.js
var IStandaloneThemeService = createDecorator("themeService");

// node_modules/monaco-editor/esm/vs/editor/browser/services/abstractCodeEditorService.js
var AbstractCodeEditorService = class extends Disposable {
  constructor() {
    super();
    this._onCodeEditorAdd = this._register(new Emitter());
    this.onCodeEditorAdd = this._onCodeEditorAdd.event;
    this._onCodeEditorRemove = this._register(new Emitter());
    this.onCodeEditorRemove = this._onCodeEditorRemove.event;
    this._onDiffEditorAdd = this._register(new Emitter());
    this._onDiffEditorRemove = this._register(new Emitter());
    this._onDecorationTypeRegistered = this._register(new Emitter());
    this._modelProperties = new Map();
    this._codeEditors = Object.create(null);
    this._diffEditors = Object.create(null);
  }
  addCodeEditor(editor2) {
    this._codeEditors[editor2.getId()] = editor2;
    this._onCodeEditorAdd.fire(editor2);
  }
  removeCodeEditor(editor2) {
    if (delete this._codeEditors[editor2.getId()]) {
      this._onCodeEditorRemove.fire(editor2);
    }
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((id) => this._codeEditors[id]);
  }
  addDiffEditor(editor2) {
    this._diffEditors[editor2.getId()] = editor2;
    this._onDiffEditorAdd.fire(editor2);
  }
  removeDiffEditor(editor2) {
    if (delete this._diffEditors[editor2.getId()]) {
      this._onDiffEditorRemove.fire(editor2);
    }
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((id) => this._diffEditors[id]);
  }
  getFocusedCodeEditor() {
    let editorWithWidgetFocus = null;
    const editors = this.listCodeEditors();
    for (const editor2 of editors) {
      if (editor2.hasTextFocus()) {
        return editor2;
      }
      if (editor2.hasWidgetFocus()) {
        editorWithWidgetFocus = editor2;
      }
    }
    return editorWithWidgetFocus;
  }
  setModelProperty(resource, key, value) {
    const key1 = resource.toString();
    let dest;
    if (this._modelProperties.has(key1)) {
      dest = this._modelProperties.get(key1);
    } else {
      dest = new Map();
      this._modelProperties.set(key1, dest);
    }
    dest.set(key, value);
  }
  getModelProperty(resource, key) {
    const key1 = resource.toString();
    if (this._modelProperties.has(key1)) {
      const innerMap = this._modelProperties.get(key1);
      return innerMap.get(key);
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorServiceImpl.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RefCountedStyleSheet = class {
  constructor(parent, editorId, styleSheet) {
    this._parent = parent;
    this._editorId = editorId;
    this._styleSheet = styleSheet;
    this._refCount = 0;
  }
  ref() {
    this._refCount++;
  }
  unref() {
    var _a6;
    this._refCount--;
    if (this._refCount === 0) {
      (_a6 = this._styleSheet.parentNode) === null || _a6 === void 0 ? void 0 : _a6.removeChild(this._styleSheet);
      this._parent._removeEditorStyleSheets(this._editorId);
    }
  }
  insertRule(rule, index) {
    const sheet = this._styleSheet.sheet;
    sheet.insertRule(rule, index);
  }
  removeRulesContainingSelector(ruleName) {
    removeCSSRulesContainingSelector(ruleName, this._styleSheet);
  }
};
var GlobalStyleSheet = class {
  constructor(styleSheet) {
    this._styleSheet = styleSheet;
  }
  ref() {
  }
  unref() {
  }
  insertRule(rule, index) {
    const sheet = this._styleSheet.sheet;
    sheet.insertRule(rule, index);
  }
  removeRulesContainingSelector(ruleName) {
    removeCSSRulesContainingSelector(ruleName, this._styleSheet);
  }
};
var CodeEditorServiceImpl = class CodeEditorServiceImpl2 extends AbstractCodeEditorService {
  constructor(styleSheet, themeService) {
    super();
    this._decorationOptionProviders = new Map();
    this._editorStyleSheets = new Map();
    this._globalStyleSheet = styleSheet ? styleSheet : null;
    this._themeService = themeService;
  }
  _getOrCreateGlobalStyleSheet() {
    if (!this._globalStyleSheet) {
      this._globalStyleSheet = new GlobalStyleSheet(createStyleSheet());
    }
    return this._globalStyleSheet;
  }
  _getOrCreateStyleSheet(editor2) {
    if (!editor2) {
      return this._getOrCreateGlobalStyleSheet();
    }
    const domNode = editor2.getContainerDomNode();
    if (!isInShadowDOM(domNode)) {
      return this._getOrCreateGlobalStyleSheet();
    }
    const editorId = editor2.getId();
    if (!this._editorStyleSheets.has(editorId)) {
      const refCountedStyleSheet = new RefCountedStyleSheet(this, editorId, createStyleSheet(domNode));
      this._editorStyleSheets.set(editorId, refCountedStyleSheet);
    }
    return this._editorStyleSheets.get(editorId);
  }
  _removeEditorStyleSheets(editorId) {
    this._editorStyleSheets.delete(editorId);
  }
  registerDecorationType(description, key, options, parentTypeKey, editor2) {
    let provider = this._decorationOptionProviders.get(key);
    if (!provider) {
      const styleSheet = this._getOrCreateStyleSheet(editor2);
      const providerArgs = {
        styleSheet,
        key,
        parentTypeKey,
        options: options || Object.create(null)
      };
      if (!parentTypeKey) {
        provider = new DecorationTypeOptionsProvider(description, this._themeService, styleSheet, providerArgs);
      } else {
        provider = new DecorationSubTypeOptionsProvider(this._themeService, styleSheet, providerArgs);
      }
      this._decorationOptionProviders.set(key, provider);
      this._onDecorationTypeRegistered.fire(key);
    }
    provider.refCount++;
  }
  removeDecorationType(key) {
    const provider = this._decorationOptionProviders.get(key);
    if (provider) {
      provider.refCount--;
      if (provider.refCount <= 0) {
        this._decorationOptionProviders.delete(key);
        provider.dispose();
        this.listCodeEditors().forEach((ed) => ed.removeDecorations(key));
      }
    }
  }
  resolveDecorationOptions(decorationTypeKey, writable) {
    const provider = this._decorationOptionProviders.get(decorationTypeKey);
    if (!provider) {
      throw new Error("Unknown decoration type key: " + decorationTypeKey);
    }
    return provider.getOptions(this, writable);
  }
};
CodeEditorServiceImpl = __decorate5([
  __param5(1, IThemeService)
], CodeEditorServiceImpl);
var DecorationSubTypeOptionsProvider = class {
  constructor(themeService, styleSheet, providerArgs) {
    this._styleSheet = styleSheet;
    this._styleSheet.ref();
    this._parentTypeKey = providerArgs.parentTypeKey;
    this.refCount = 0;
    this._beforeContentRules = new DecorationCSSRules(3, providerArgs, themeService);
    this._afterContentRules = new DecorationCSSRules(4, providerArgs, themeService);
  }
  getOptions(codeEditorService, writable) {
    const options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
    if (this._beforeContentRules) {
      options.beforeContentClassName = this._beforeContentRules.className;
    }
    if (this._afterContentRules) {
      options.afterContentClassName = this._afterContentRules.className;
    }
    return options;
  }
  dispose() {
    if (this._beforeContentRules) {
      this._beforeContentRules.dispose();
      this._beforeContentRules = null;
    }
    if (this._afterContentRules) {
      this._afterContentRules.dispose();
      this._afterContentRules = null;
    }
    this._styleSheet.unref();
  }
};
var DecorationTypeOptionsProvider = class {
  constructor(description, themeService, styleSheet, providerArgs) {
    this._disposables = new DisposableStore();
    this.description = description;
    this._styleSheet = styleSheet;
    this._styleSheet.ref();
    this.refCount = 0;
    const createCSSRules = (type) => {
      const rules = new DecorationCSSRules(type, providerArgs, themeService);
      this._disposables.add(rules);
      if (rules.hasContent) {
        return rules.className;
      }
      return void 0;
    };
    const createInlineCSSRules = (type) => {
      const rules = new DecorationCSSRules(type, providerArgs, themeService);
      this._disposables.add(rules);
      if (rules.hasContent) {
        return { className: rules.className, hasLetterSpacing: rules.hasLetterSpacing };
      }
      return null;
    };
    this.className = createCSSRules(0);
    const inlineData = createInlineCSSRules(1);
    if (inlineData) {
      this.inlineClassName = inlineData.className;
      this.inlineClassNameAffectsLetterSpacing = inlineData.hasLetterSpacing;
    }
    this.beforeContentClassName = createCSSRules(3);
    this.afterContentClassName = createCSSRules(4);
    if (providerArgs.options.beforeInjectedText && providerArgs.options.beforeInjectedText.contentText) {
      const beforeInlineData = createInlineCSSRules(5);
      this.beforeInjectedText = {
        content: providerArgs.options.beforeInjectedText.contentText,
        inlineClassName: beforeInlineData === null || beforeInlineData === void 0 ? void 0 : beforeInlineData.className,
        inlineClassNameAffectsLetterSpacing: (beforeInlineData === null || beforeInlineData === void 0 ? void 0 : beforeInlineData.hasLetterSpacing) || providerArgs.options.beforeInjectedText.affectsLetterSpacing
      };
    }
    if (providerArgs.options.afterInjectedText && providerArgs.options.afterInjectedText.contentText) {
      const afterInlineData = createInlineCSSRules(6);
      this.afterInjectedText = {
        content: providerArgs.options.afterInjectedText.contentText,
        inlineClassName: afterInlineData === null || afterInlineData === void 0 ? void 0 : afterInlineData.className,
        inlineClassNameAffectsLetterSpacing: (afterInlineData === null || afterInlineData === void 0 ? void 0 : afterInlineData.hasLetterSpacing) || providerArgs.options.afterInjectedText.affectsLetterSpacing
      };
    }
    this.glyphMarginClassName = createCSSRules(2);
    const options = providerArgs.options;
    this.isWholeLine = Boolean(options.isWholeLine);
    this.stickiness = options.rangeBehavior;
    const lightOverviewRulerColor = options.light && options.light.overviewRulerColor || options.overviewRulerColor;
    const darkOverviewRulerColor = options.dark && options.dark.overviewRulerColor || options.overviewRulerColor;
    if (typeof lightOverviewRulerColor !== "undefined" || typeof darkOverviewRulerColor !== "undefined") {
      this.overviewRuler = {
        color: lightOverviewRulerColor || darkOverviewRulerColor,
        darkColor: darkOverviewRulerColor || lightOverviewRulerColor,
        position: options.overviewRulerLane || OverviewRulerLane.Center
      };
    }
  }
  getOptions(codeEditorService, writable) {
    if (!writable) {
      return this;
    }
    return {
      description: this.description,
      inlineClassName: this.inlineClassName,
      beforeContentClassName: this.beforeContentClassName,
      afterContentClassName: this.afterContentClassName,
      className: this.className,
      glyphMarginClassName: this.glyphMarginClassName,
      isWholeLine: this.isWholeLine,
      overviewRuler: this.overviewRuler,
      stickiness: this.stickiness,
      before: this.beforeInjectedText
    };
  }
  dispose() {
    this._disposables.dispose();
    this._styleSheet.unref();
  }
};
var _CSS_MAP = {
  color: "color:{0} !important;",
  opacity: "opacity:{0};",
  backgroundColor: "background-color:{0};",
  outline: "outline:{0};",
  outlineColor: "outline-color:{0};",
  outlineStyle: "outline-style:{0};",
  outlineWidth: "outline-width:{0};",
  border: "border:{0};",
  borderColor: "border-color:{0};",
  borderRadius: "border-radius:{0};",
  borderSpacing: "border-spacing:{0};",
  borderStyle: "border-style:{0};",
  borderWidth: "border-width:{0};",
  fontStyle: "font-style:{0};",
  fontWeight: "font-weight:{0};",
  fontSize: "font-size:{0};",
  fontFamily: "font-family:{0};",
  textDecoration: "text-decoration:{0};",
  cursor: "cursor:{0};",
  letterSpacing: "letter-spacing:{0};",
  gutterIconPath: "background:{0} center center no-repeat;",
  gutterIconSize: "background-size:{0};",
  contentText: "content:'{0}';",
  contentIconPath: "content:{0};",
  margin: "margin:{0};",
  padding: "padding:{0};",
  width: "width:{0};",
  height: "height:{0};"
};
var DecorationCSSRules = class {
  constructor(ruleType, providerArgs, themeService) {
    this._theme = themeService.getColorTheme();
    this._ruleType = ruleType;
    this._providerArgs = providerArgs;
    this._usesThemeColors = false;
    this._hasContent = false;
    this._hasLetterSpacing = false;
    let className = CSSNameHelper.getClassName(this._providerArgs.key, ruleType);
    if (this._providerArgs.parentTypeKey) {
      className = className + " " + CSSNameHelper.getClassName(this._providerArgs.parentTypeKey, ruleType);
    }
    this._className = className;
    this._unThemedSelector = CSSNameHelper.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, ruleType);
    this._buildCSS();
    if (this._usesThemeColors) {
      this._themeListener = themeService.onDidColorThemeChange((theme) => {
        this._theme = themeService.getColorTheme();
        this._removeCSS();
        this._buildCSS();
      });
    } else {
      this._themeListener = null;
    }
  }
  dispose() {
    if (this._hasContent) {
      this._removeCSS();
      this._hasContent = false;
    }
    if (this._themeListener) {
      this._themeListener.dispose();
      this._themeListener = null;
    }
  }
  get hasContent() {
    return this._hasContent;
  }
  get hasLetterSpacing() {
    return this._hasLetterSpacing;
  }
  get className() {
    return this._className;
  }
  _buildCSS() {
    const options = this._providerArgs.options;
    let unthemedCSS, lightCSS, darkCSS;
    switch (this._ruleType) {
      case 0:
        unthemedCSS = this.getCSSTextForModelDecorationClassName(options);
        lightCSS = this.getCSSTextForModelDecorationClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationClassName(options.dark);
        break;
      case 1:
        unthemedCSS = this.getCSSTextForModelDecorationInlineClassName(options);
        lightCSS = this.getCSSTextForModelDecorationInlineClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationInlineClassName(options.dark);
        break;
      case 2:
        unthemedCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options);
        lightCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.dark);
        break;
      case 3:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.before);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.before);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.before);
        break;
      case 4:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.after);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.after);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.after);
        break;
      case 5:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.beforeInjectedText);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.beforeInjectedText);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.beforeInjectedText);
        break;
      case 6:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.afterInjectedText);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.afterInjectedText);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.afterInjectedText);
        break;
      default:
        throw new Error("Unknown rule type: " + this._ruleType);
    }
    const sheet = this._providerArgs.styleSheet;
    let hasContent = false;
    if (unthemedCSS.length > 0) {
      sheet.insertRule(`${this._unThemedSelector} {${unthemedCSS}}`, 0);
      hasContent = true;
    }
    if (lightCSS.length > 0) {
      sheet.insertRule(`.vs${this._unThemedSelector} {${lightCSS}}`, 0);
      hasContent = true;
    }
    if (darkCSS.length > 0) {
      sheet.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${darkCSS}}`, 0);
      hasContent = true;
    }
    this._hasContent = hasContent;
  }
  _removeCSS() {
    this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
  }
  getCSSTextForModelDecorationClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    this.collectCSSText(opts, ["backgroundColor"], cssTextArr);
    this.collectCSSText(opts, ["outline", "outlineColor", "outlineStyle", "outlineWidth"], cssTextArr);
    this.collectBorderSettingsCSSText(opts, cssTextArr);
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationInlineClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    this.collectCSSText(opts, ["fontStyle", "fontWeight", "textDecoration", "cursor", "color", "opacity", "letterSpacing"], cssTextArr);
    if (opts.letterSpacing) {
      this._hasLetterSpacing = true;
    }
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationContentClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    if (typeof opts !== "undefined") {
      this.collectBorderSettingsCSSText(opts, cssTextArr);
      if (typeof opts.contentIconPath !== "undefined") {
        cssTextArr.push(format(_CSS_MAP.contentIconPath, asCSSUrl(URI.revive(opts.contentIconPath))));
      }
      if (typeof opts.contentText === "string") {
        const truncated = opts.contentText.match(/^.*$/m)[0];
        const escaped = truncated.replace(/['\\]/g, "\\$&");
        cssTextArr.push(format(_CSS_MAP.contentText, escaped));
      }
      this.collectCSSText(opts, ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textDecoration", "color", "opacity", "backgroundColor", "margin", "padding"], cssTextArr);
      if (this.collectCSSText(opts, ["width", "height"], cssTextArr)) {
        cssTextArr.push("display:inline-block;");
      }
    }
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationGlyphMarginClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    if (typeof opts.gutterIconPath !== "undefined") {
      cssTextArr.push(format(_CSS_MAP.gutterIconPath, asCSSUrl(URI.revive(opts.gutterIconPath))));
      if (typeof opts.gutterIconSize !== "undefined") {
        cssTextArr.push(format(_CSS_MAP.gutterIconSize, opts.gutterIconSize));
      }
    }
    return cssTextArr.join("");
  }
  collectBorderSettingsCSSText(opts, cssTextArr) {
    if (this.collectCSSText(opts, ["border", "borderColor", "borderRadius", "borderSpacing", "borderStyle", "borderWidth"], cssTextArr)) {
      cssTextArr.push(format("box-sizing: border-box;"));
      return true;
    }
    return false;
  }
  collectCSSText(opts, properties, cssTextArr) {
    const lenBefore = cssTextArr.length;
    for (let property of properties) {
      const value = this.resolveValue(opts[property]);
      if (typeof value === "string") {
        cssTextArr.push(format(_CSS_MAP[property], value));
      }
    }
    return cssTextArr.length !== lenBefore;
  }
  resolveValue(value) {
    if (isThemeColor(value)) {
      this._usesThemeColors = true;
      const color = this._theme.getColor(value.id);
      if (color) {
        return color.toString();
      }
      return "transparent";
    }
    return value;
  }
};
var CSSNameHelper = class {
  static getClassName(key, type) {
    return "ced-" + key + "-" + type;
  }
  static getSelector(key, parentKey, ruleType) {
    let selector = ".monaco-editor ." + this.getClassName(key, ruleType);
    if (parentKey) {
      selector = selector + "." + this.getClassName(parentKey, ruleType);
    }
    if (ruleType === 3) {
      selector += "::before";
    } else if (ruleType === 4) {
      selector += "::after";
    }
    return selector;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeServiceImpl.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneCodeEditorServiceImpl = class StandaloneCodeEditorServiceImpl2 extends CodeEditorServiceImpl {
  constructor(styleSheet, contextKeyService, themeService) {
    super(styleSheet, themeService);
    this.onCodeEditorAdd(() => this._checkContextKey());
    this.onCodeEditorRemove(() => this._checkContextKey());
    this._editorIsOpen = contextKeyService.createKey("editorIsOpen", false);
    this._activeCodeEditor = null;
  }
  _checkContextKey() {
    let hasCodeEditor = false;
    for (const editor2 of this.listCodeEditors()) {
      if (!editor2.isSimpleWidget) {
        hasCodeEditor = true;
        break;
      }
    }
    this._editorIsOpen.set(hasCodeEditor);
  }
  setActiveCodeEditor(activeCodeEditor) {
    this._activeCodeEditor = activeCodeEditor;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  openCodeEditor(input, source, sideBySide) {
    if (!source) {
      return Promise.resolve(null);
    }
    return Promise.resolve(this.doOpenEditor(source, input));
  }
  doOpenEditor(editor2, input) {
    const model = this.findModel(editor2, input.resource);
    if (!model) {
      if (input.resource) {
        const schema = input.resource.scheme;
        if (schema === Schemas.http || schema === Schemas.https) {
          windowOpenNoOpener(input.resource.toString());
          return editor2;
        }
      }
      return null;
    }
    const selection = input.options ? input.options.selection : null;
    if (selection) {
      if (typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
        editor2.setSelection(selection);
        editor2.revealRangeInCenter(selection, 1);
      } else {
        const pos = {
          lineNumber: selection.startLineNumber,
          column: selection.startColumn
        };
        editor2.setPosition(pos);
        editor2.revealPositionInCenter(pos, 1);
      }
    }
    return editor2;
  }
  findModel(editor2, resource) {
    const model = editor2.getModel();
    if (model && model.uri.toString() !== resource.toString()) {
      return null;
    }
    return model;
  }
};
StandaloneCodeEditorServiceImpl = __decorate6([
  __param6(1, IContextKeyService),
  __param6(2, IThemeService)
], StandaloneCodeEditorServiceImpl);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LAST_GENERATED_COMMAND_ID = 0;
var ariaDomNodeCreated = false;
function createAriaDomNode() {
  if (ariaDomNodeCreated) {
    return;
  }
  ariaDomNodeCreated = true;
  setARIAContainer(document.body);
}
var StandaloneCodeEditor = class StandaloneCodeEditor2 extends CodeEditorWidget {
  constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService) {
    const options = Object.assign({}, _options);
    options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;
    options.ariaLabel = options.ariaLabel + ";" + StandaloneCodeEditorNLS.accessibilityHelpMessage;
    super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);
    if (keybindingService instanceof StandaloneKeybindingService) {
      this._standaloneKeybindingService = keybindingService;
    } else {
      this._standaloneKeybindingService = null;
    }
    createAriaDomNode();
  }
  addCommand(keybinding, handler, context) {
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService");
      return null;
    }
    let commandId = "DYNAMIC_" + ++LAST_GENERATED_COMMAND_ID;
    let whenExpression = ContextKeyExpr.deserialize(context);
    this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);
    return commandId;
  }
  createContextKey(key, defaultValue) {
    return this._contextKeyService.createKey(key, defaultValue);
  }
  addAction(_descriptor) {
    if (typeof _descriptor.id !== "string" || typeof _descriptor.label !== "string" || typeof _descriptor.run !== "function") {
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    }
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
      return Disposable.None;
    }
    const id = _descriptor.id;
    const label = _descriptor.label;
    const precondition = ContextKeyExpr.and(ContextKeyExpr.equals("editorId", this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));
    const keybindings = _descriptor.keybindings;
    const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));
    const contextMenuGroupId = _descriptor.contextMenuGroupId || null;
    const contextMenuOrder = _descriptor.contextMenuOrder || 0;
    const run = (accessor, ...args) => {
      return Promise.resolve(_descriptor.run(this, ...args));
    };
    const toDispose = new DisposableStore();
    const uniqueId = this.getId() + ":" + id;
    toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));
    if (contextMenuGroupId) {
      let menuItem = {
        command: {
          id: uniqueId,
          title: label
        },
        when: precondition,
        group: contextMenuGroupId,
        order: contextMenuOrder
      };
      toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
    }
    if (Array.isArray(keybindings)) {
      for (const kb of keybindings) {
        toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));
      }
    }
    let internalAction = new InternalEditorAction(uniqueId, label, label, precondition, run, this._contextKeyService);
    this._actions[id] = internalAction;
    toDispose.add(toDisposable(() => {
      delete this._actions[id];
    }));
    return toDispose;
  }
  _triggerCommand(handlerId, payload) {
    if (this._codeEditorService instanceof StandaloneCodeEditorServiceImpl) {
      try {
        this._codeEditorService.setActiveCodeEditor(this);
        super._triggerCommand(handlerId, payload);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    } else {
      super._triggerCommand(handlerId, payload);
    }
  }
};
StandaloneCodeEditor = __decorate7([
  __param7(2, IInstantiationService),
  __param7(3, ICodeEditorService),
  __param7(4, ICommandService),
  __param7(5, IContextKeyService),
  __param7(6, IKeybindingService),
  __param7(7, IThemeService),
  __param7(8, INotificationService),
  __param7(9, IAccessibilityService)
], StandaloneCodeEditor);
var StandaloneEditor = class StandaloneEditor2 extends StandaloneCodeEditor {
  constructor(domElement, _options, toDispose, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, contextViewService, themeService, notificationService, configurationService, accessibilityService, modelService, modeService) {
    const options = Object.assign({}, _options);
    updateConfigurationService(configurationService, options, false);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    if (typeof options.theme === "string") {
      themeService.setTheme(options.theme);
    }
    if (typeof options.autoDetectHighContrast !== "undefined") {
      themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
    }
    let _model = options.model;
    delete options.model;
    super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService);
    this._contextViewService = contextViewService;
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(toDispose);
    this._register(themeDomRegistration);
    let model;
    if (typeof _model === "undefined") {
      model = createTextModel(modelService, modeService, options.value || "", options.language || Mimes.text, void 0);
      this._ownsModel = true;
    } else {
      model = _model;
      this._ownsModel = false;
    }
    this._attachModel(model);
    if (model) {
      let e = {
        oldModelUrl: null,
        newModelUrl: model.uri
      };
      this._onDidChangeModel.fire(e);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    updateConfigurationService(this._configurationService, newOptions, false);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    if (typeof newOptions.autoDetectHighContrast !== "undefined") {
      this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
    }
    super.updateOptions(newOptions);
  }
  _attachModel(model) {
    super._attachModel(model);
    if (this._modelData) {
      this._contextViewService.setContainer(this._modelData.view.domNode.domNode);
    }
  }
  _postDetachModelCleanup(detachedModel) {
    super._postDetachModelCleanup(detachedModel);
    if (detachedModel && this._ownsModel) {
      detachedModel.dispose();
      this._ownsModel = false;
    }
  }
};
StandaloneEditor = __decorate7([
  __param7(3, IInstantiationService),
  __param7(4, ICodeEditorService),
  __param7(5, ICommandService),
  __param7(6, IContextKeyService),
  __param7(7, IKeybindingService),
  __param7(8, IContextViewService),
  __param7(9, IStandaloneThemeService),
  __param7(10, INotificationService),
  __param7(11, IConfigurationService),
  __param7(12, IAccessibilityService),
  __param7(13, IModelService),
  __param7(14, IModeService)
], StandaloneEditor);
var StandaloneDiffEditor = class StandaloneDiffEditor2 extends DiffEditorWidget {
  constructor(domElement, _options, toDispose, instantiationService, contextKeyService, keybindingService, contextViewService, editorWorkerService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService) {
    const options = Object.assign({}, _options);
    updateConfigurationService(configurationService, options, true);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    if (typeof options.theme === "string") {
      themeService.setTheme(options.theme);
    }
    if (typeof options.autoDetectHighContrast !== "undefined") {
      themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
    }
    super(domElement, options, {}, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, editorProgressService);
    this._contextViewService = contextViewService;
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(toDispose);
    this._register(themeDomRegistration);
    this._contextViewService.setContainer(this._containerDomElement);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    updateConfigurationService(this._configurationService, newOptions, true);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    if (typeof newOptions.autoDetectHighContrast !== "undefined") {
      this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
    }
    super.updateOptions(newOptions);
  }
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(StandaloneCodeEditor, container, options);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(keybinding, handler, context) {
    return this.getModifiedEditor().addCommand(keybinding, handler, context);
  }
  createContextKey(key, defaultValue) {
    return this.getModifiedEditor().createContextKey(key, defaultValue);
  }
  addAction(descriptor) {
    return this.getModifiedEditor().addAction(descriptor);
  }
};
StandaloneDiffEditor = __decorate7([
  __param7(3, IInstantiationService),
  __param7(4, IContextKeyService),
  __param7(5, IKeybindingService),
  __param7(6, IContextViewService),
  __param7(7, IEditorWorkerService),
  __param7(8, ICodeEditorService),
  __param7(9, IStandaloneThemeService),
  __param7(10, INotificationService),
  __param7(11, IConfigurationService),
  __param7(12, IContextMenuService),
  __param7(13, IEditorProgressService),
  __param7(14, IClipboardService)
], StandaloneDiffEditor);
function createTextModel(modelService, modeService, value, language, uri) {
  value = value || "";
  if (!language) {
    const firstLF = value.indexOf("\n");
    let firstLine = value;
    if (firstLF !== -1) {
      firstLine = value.substring(0, firstLF);
    }
    return doCreateModel(modelService, value, modeService.createByFilepathOrFirstLine(uri || null, firstLine), uri);
  }
  return doCreateModel(modelService, value, modeService.create(language), uri);
}
function doCreateModel(modelService, value, languageSelection, uri) {
  return modelService.createModel(value, languageSelection, uri);
}

// node_modules/monaco-editor/esm/vs/editor/common/modes/abstractMode.js
var FrankensteinMode = class {
  constructor(languageIdentifier) {
    this._languageIdentifier = languageIdentifier;
  }
  getId() {
    return this._languageIdentifier.language;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var LanguagesRegistry = class extends Disposable {
  constructor(useModesRegistry = true, warnOnOverwrite = false) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._warnOnOverwrite = warnOnOverwrite;
    this._nextLanguageId2 = 1;
    this._languageIdToLanguage = [];
    this._languageToLanguageId = Object.create(null);
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    if (useModesRegistry) {
      this._initializeFromRegistry();
      this._register(ModesRegistry.onDidChangeLanguages((m) => this._initializeFromRegistry()));
    }
  }
  _initializeFromRegistry() {
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    const desc = ModesRegistry.getLanguages();
    this._registerLanguages(desc);
  }
  _registerLanguages(desc) {
    for (const d of desc) {
      this._registerLanguage(d);
    }
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    Object.keys(this._languages).forEach((langId) => {
      let language = this._languages[langId];
      if (language.name) {
        this._nameMap[language.name] = language.identifier;
      }
      language.aliases.forEach((alias) => {
        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;
      });
      language.mimetypes.forEach((mimetype) => {
        this._mimeTypesMap[mimetype] = language.identifier;
      });
    });
    Registry.as(Extensions.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map((language) => language.id));
    this._onDidChange.fire();
  }
  _getLanguageId(language) {
    if (this._languageToLanguageId[language]) {
      return this._languageToLanguageId[language];
    }
    const languageId = this._nextLanguageId2++;
    this._languageIdToLanguage[languageId] = language;
    this._languageToLanguageId[language] = languageId;
    return languageId;
  }
  _registerLanguage(lang) {
    const langId = lang.id;
    let resolvedLanguage;
    if (hasOwnProperty.call(this._languages, langId)) {
      resolvedLanguage = this._languages[langId];
    } else {
      const languageId = this._getLanguageId(langId);
      resolvedLanguage = {
        identifier: new LanguageIdentifier(langId, languageId),
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: []
      };
      this._languages[langId] = resolvedLanguage;
    }
    this._mergeLanguage(resolvedLanguage, lang);
  }
  _mergeLanguage(resolvedLanguage, lang) {
    const langId = lang.id;
    let primaryMime = null;
    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {
      resolvedLanguage.mimetypes.push(...lang.mimetypes);
      primaryMime = lang.mimetypes[0];
    }
    if (!primaryMime) {
      primaryMime = `text/x-${langId}`;
      resolvedLanguage.mimetypes.push(primaryMime);
    }
    if (Array.isArray(lang.extensions)) {
      if (lang.configuration) {
        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);
      } else {
        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);
      }
      for (let extension of lang.extensions) {
        registerTextMime({ id: langId, mime: primaryMime, extension }, this._warnOnOverwrite);
      }
    }
    if (Array.isArray(lang.filenames)) {
      for (let filename of lang.filenames) {
        registerTextMime({ id: langId, mime: primaryMime, filename }, this._warnOnOverwrite);
        resolvedLanguage.filenames.push(filename);
      }
    }
    if (Array.isArray(lang.filenamePatterns)) {
      for (let filenamePattern of lang.filenamePatterns) {
        registerTextMime({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);
      }
    }
    if (typeof lang.firstLine === "string" && lang.firstLine.length > 0) {
      let firstLineRegexStr = lang.firstLine;
      if (firstLineRegexStr.charAt(0) !== "^") {
        firstLineRegexStr = "^" + firstLineRegexStr;
      }
      try {
        let firstLineRegex = new RegExp(firstLineRegexStr);
        if (!regExpLeadsToEndlessLoop(firstLineRegex)) {
          registerTextMime({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);
        }
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    resolvedLanguage.aliases.push(langId);
    let langAliases = null;
    if (typeof lang.aliases !== "undefined" && Array.isArray(lang.aliases)) {
      if (lang.aliases.length === 0) {
        langAliases = [null];
      } else {
        langAliases = lang.aliases;
      }
    }
    if (langAliases !== null) {
      for (const langAlias of langAliases) {
        if (!langAlias || langAlias.length === 0) {
          continue;
        }
        resolvedLanguage.aliases.push(langAlias);
      }
    }
    let containsAliases = langAliases !== null && langAliases.length > 0;
    if (containsAliases && langAliases[0] === null) {
    } else {
      let bestName = (containsAliases ? langAliases[0] : null) || langId;
      if (containsAliases || !resolvedLanguage.name) {
        resolvedLanguage.name = bestName;
      }
    }
    if (lang.configuration) {
      resolvedLanguage.configurationFiles.push(lang.configuration);
    }
  }
  isRegisteredMode(mimetypeOrModeId) {
    if (hasOwnProperty.call(this._mimeTypesMap, mimetypeOrModeId)) {
      return true;
    }
    return hasOwnProperty.call(this._languages, mimetypeOrModeId);
  }
  getModeIdForLanguageNameLowercase(languageNameLower) {
    if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {
      return null;
    }
    return this._lowercaseNameMap[languageNameLower].language;
  }
  extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds) {
    if (!commaSeparatedMimetypesOrCommaSeparatedIds) {
      return [];
    }
    return commaSeparatedMimetypesOrCommaSeparatedIds.split(",").map((mimeTypeOrId) => mimeTypeOrId.trim()).map((mimeTypeOrId) => {
      if (hasOwnProperty.call(this._mimeTypesMap, mimeTypeOrId)) {
        return this._mimeTypesMap[mimeTypeOrId].language;
      }
      return mimeTypeOrId;
    }).filter((modeId) => {
      return hasOwnProperty.call(this._languages, modeId);
    });
  }
  getLanguageIdentifier(_modeId) {
    if (_modeId === NULL_MODE_ID || _modeId === 0) {
      return NULL_LANGUAGE_IDENTIFIER;
    }
    let modeId;
    if (typeof _modeId === "string") {
      modeId = _modeId;
    } else {
      modeId = this._languageIdToLanguage[_modeId];
      if (!modeId) {
        return null;
      }
    }
    if (!hasOwnProperty.call(this._languages, modeId)) {
      return null;
    }
    return this._languages[modeId].identifier;
  }
  getModeIdsFromFilepathOrFirstLine(resource, firstLine) {
    if (!resource && !firstLine) {
      return [];
    }
    let mimeTypes = guessMimeTypes(resource, firstLine);
    return this.extractModeIds(mimeTypes.join(","));
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/modeServiceImpl.js
var LanguageSelection = class {
  constructor(onLanguagesMaybeChanged, selector) {
    this._selector = selector;
    this.languageIdentifier = this._selector();
    let listener;
    this._onDidChange = new Emitter({
      onFirstListenerAdd: () => {
        listener = onLanguagesMaybeChanged(() => this._evaluate());
      },
      onLastListenerRemove: () => {
        listener.dispose();
      }
    });
    this.onDidChange = this._onDidChange.event;
  }
  _evaluate() {
    let languageIdentifier = this._selector();
    if (languageIdentifier.id === this.languageIdentifier.id) {
      return;
    }
    this.languageIdentifier = languageIdentifier;
    this._onDidChange.fire(this.languageIdentifier);
  }
};
var ModeServiceImpl = class extends Disposable {
  constructor(warnOnOverwrite = false) {
    super();
    this._onDidCreateMode = this._register(new Emitter());
    this.onDidCreateMode = this._onDidCreateMode.event;
    this._onLanguagesMaybeChanged = this._register(new Emitter({ leakWarningThreshold: 200 }));
    this.onLanguagesMaybeChanged = this._onLanguagesMaybeChanged.event;
    this._instantiatedModes = {};
    this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));
    this._register(this._registry.onDidChange(() => this._onLanguagesMaybeChanged.fire()));
  }
  isRegisteredMode(mimetypeOrModeId) {
    return this._registry.isRegisteredMode(mimetypeOrModeId);
  }
  getModeIdForLanguageName(alias) {
    return this._registry.getModeIdForLanguageNameLowercase(alias);
  }
  getModeIdByFilepathOrFirstLine(resource, firstLine) {
    const modeIds = this._registry.getModeIdsFromFilepathOrFirstLine(resource, firstLine);
    return firstOrDefault(modeIds, null);
  }
  getModeId(commaSeparatedMimetypesOrCommaSeparatedIds) {
    const modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
    return firstOrDefault(modeIds, null);
  }
  getLanguageIdentifier(modeId) {
    return this._registry.getLanguageIdentifier(modeId);
  }
  create(commaSeparatedMimetypesOrCommaSeparatedIds) {
    return new LanguageSelection(this.onLanguagesMaybeChanged, () => {
      const modeId = this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
      return this._createModeAndGetLanguageIdentifier(modeId);
    });
  }
  createByFilepathOrFirstLine(resource, firstLine) {
    return new LanguageSelection(this.onLanguagesMaybeChanged, () => {
      const modeId = this.getModeIdByFilepathOrFirstLine(resource, firstLine);
      return this._createModeAndGetLanguageIdentifier(modeId);
    });
  }
  _createModeAndGetLanguageIdentifier(modeId) {
    const languageIdentifier = this.getLanguageIdentifier(modeId || "plaintext") || NULL_LANGUAGE_IDENTIFIER;
    this._getOrCreateMode(languageIdentifier.language);
    return languageIdentifier;
  }
  triggerMode(commaSeparatedMimetypesOrCommaSeparatedIds) {
    const modeId = this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
    this._getOrCreateMode(modeId || "plaintext");
  }
  _getOrCreateMode(modeId) {
    if (!this._instantiatedModes.hasOwnProperty(modeId)) {
      let languageIdentifier = this.getLanguageIdentifier(modeId) || NULL_LANGUAGE_IDENTIFIER;
      this._instantiatedModes[modeId] = new FrankensteinMode(languageIdentifier);
      this._onDidCreateMode.fire(this._instantiatedModes[modeId]);
    }
    return this._instantiatedModes[modeId];
  }
};

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js
var IUndoRedoService = createDecorator("undoRedoService");
var ResourceEditStackSnapshot = class {
  constructor(resource, elements) {
    this.resource = resource;
    this.elements = elements;
  }
};
var UndoRedoGroup = class {
  constructor() {
    this.id = UndoRedoGroup._ID++;
    this.order = 1;
  }
  nextOrder() {
    if (this.id === 0) {
      return 0;
    }
    return this.order++;
  }
};
UndoRedoGroup._ID = 0;
UndoRedoGroup.None = new UndoRedoGroup();
var UndoRedoSource = class {
  constructor() {
    this.id = UndoRedoSource._ID++;
    this.order = 1;
  }
  nextOrder() {
    if (this.id === 0) {
      return 0;
    }
    return this.order++;
  }
};
UndoRedoSource._ID = 0;
UndoRedoSource.None = new UndoRedoSource();

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js
var SemanticTokensProviderStyling = class {
  constructor(_legend, _themeService, _logService) {
    this._legend = _legend;
    this._themeService = _themeService;
    this._logService = _logService;
    this._hashTable = new HashTable();
    this._hasWarnedOverlappingTokens = false;
  }
  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);
    let metadata;
    if (entry) {
      metadata = entry.metadata;
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    } else {
      let tokenType = this._legend.tokenTypes[tokenTypeIndex];
      const tokenModifiers = [];
      if (tokenType) {
        let modifierSet = tokenModifierSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);
          tokenModifiers.push("not-in-legend");
        }
        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);
        if (typeof tokenStyle === "undefined") {
          metadata = 2147483647;
        } else {
          metadata = 0;
          if (typeof tokenStyle.italic !== "undefined") {
            const italicBit = (tokenStyle.italic ? 1 : 0) << 11;
            metadata |= italicBit | 1;
          }
          if (typeof tokenStyle.bold !== "undefined") {
            const boldBit = (tokenStyle.bold ? 2 : 0) << 11;
            metadata |= boldBit | 2;
          }
          if (typeof tokenStyle.underline !== "undefined") {
            const underlineBit = (tokenStyle.underline ? 4 : 0) << 11;
            metadata |= underlineBit | 4;
          }
          if (tokenStyle.foreground) {
            const foregroundBits = tokenStyle.foreground << 14;
            metadata |= foregroundBits | 8;
          }
          if (metadata === 0) {
            metadata = 2147483647;
          }
        }
      } else {
        if (this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);
        }
        metadata = 2147483647;
        tokenType = "not-in-legend";
      }
      this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(" ")}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    }
    return metadata;
  }
  warnOverlappingSemanticTokens(lineNumber, startColumn) {
    if (!this._hasWarnedOverlappingTokens) {
      this._hasWarnedOverlappingTokens = true;
      console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);
    }
  }
};
function toMultilineTokens2(tokens, styling, languageId) {
  const srcData = tokens.data;
  const tokenCount = tokens.data.length / 5 | 0;
  const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024), 400);
  const result = [];
  let tokenIndex = 0;
  let lastLineNumber = 1;
  let lastStartCharacter = 0;
  while (tokenIndex < tokenCount) {
    const tokenStartIndex = tokenIndex;
    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);
    if (tokenEndIndex < tokenCount) {
      let smallTokenEndIndex = tokenEndIndex;
      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {
        smallTokenEndIndex--;
      }
      if (smallTokenEndIndex - 1 === tokenStartIndex) {
        let bigTokenEndIndex = tokenEndIndex;
        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {
          bigTokenEndIndex++;
        }
        tokenEndIndex = bigTokenEndIndex;
      } else {
        tokenEndIndex = smallTokenEndIndex;
      }
    }
    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);
    let destOffset = 0;
    let areaLine = 0;
    let prevLineNumber = 0;
    let prevStartCharacter = 0;
    let prevEndCharacter = 0;
    while (tokenIndex < tokenEndIndex) {
      const srcOffset = 5 * tokenIndex;
      const deltaLine = srcData[srcOffset];
      const deltaCharacter = srcData[srcOffset + 1];
      const lineNumber = lastLineNumber + deltaLine;
      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter;
      const length = srcData[srcOffset + 2];
      const tokenTypeIndex = srcData[srcOffset + 3];
      const tokenModifierSet = srcData[srcOffset + 4];
      const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);
      if (metadata !== 2147483647) {
        if (areaLine === 0) {
          areaLine = lineNumber;
        }
        if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {
          styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);
          if (prevStartCharacter < startCharacter) {
            destData[destOffset - 4 + 2] = startCharacter;
          } else {
            destOffset -= 4;
          }
        }
        destData[destOffset] = lineNumber - areaLine;
        destData[destOffset + 1] = startCharacter;
        destData[destOffset + 2] = startCharacter + length;
        destData[destOffset + 3] = metadata;
        destOffset += 4;
        prevLineNumber = lineNumber;
        prevStartCharacter = startCharacter;
        prevEndCharacter = startCharacter + length;
      }
      lastLineNumber = lineNumber;
      lastStartCharacter = startCharacter;
      tokenIndex++;
    }
    if (destOffset !== destData.length) {
      destData = destData.subarray(0, destOffset);
    }
    const tokens2 = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));
    result.push(tokens2);
  }
  return result;
}
var HashTableEntry = class {
  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this.tokenTypeIndex = tokenTypeIndex;
    this.tokenModifierSet = tokenModifierSet;
    this.languageId = languageId;
    this.metadata = metadata;
    this.next = null;
  }
};
var HashTable = class {
  constructor() {
    this._elementsCount = 0;
    this._currentLengthIndex = 0;
    this._currentLength = HashTable._SIZES[this._currentLengthIndex];
    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
    this._elements = [];
    HashTable._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(entries, length) {
    for (let i = 0; i < length; i++) {
      entries[i] = null;
    }
  }
  _hash2(n1, n2) {
    return (n1 << 5) - n1 + n2 | 0;
  }
  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
  }
  get(tokenTypeIndex, tokenModifierSet, languageId) {
    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
    let p = this._elements[hash];
    while (p) {
      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {
        return p;
      }
      p = p.next;
    }
    return null;
  }
  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this._elementsCount++;
    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const oldElements = this._elements;
      this._currentLengthIndex++;
      this._currentLength = HashTable._SIZES[this._currentLengthIndex];
      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
      this._elements = [];
      HashTable._nullOutEntries(this._elements, this._currentLength);
      for (const first of oldElements) {
        let p = first;
        while (p) {
          const oldNext = p.next;
          p.next = null;
          this._add(p);
          p = oldNext;
        }
      }
    }
    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
  }
  _add(element) {
    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
    element.next = this._elements[hash];
    this._elements[hash] = element;
  }
};
HashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js
function reverseEndianness(arr) {
  for (let i = 0, len = arr.length; i < len; i += 4) {
    const b0 = arr[i + 0];
    const b1 = arr[i + 1];
    const b2 = arr[i + 2];
    const b3 = arr[i + 3];
    arr[i + 0] = b3;
    arr[i + 1] = b2;
    arr[i + 2] = b1;
    arr[i + 3] = b0;
  }
}
function toLittleEndianBuffer(arr) {
  const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  return VSBuffer.wrap(uint8Arr);
}
function encodeSemanticTokensDto(semanticTokens) {
  const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
  let offset = 0;
  dest[offset++] = semanticTokens.id;
  if (semanticTokens.type === "full") {
    dest[offset++] = 1;
    dest[offset++] = semanticTokens.data.length;
    dest.set(semanticTokens.data, offset);
    offset += semanticTokens.data.length;
  } else {
    dest[offset++] = 2;
    dest[offset++] = semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      dest[offset++] = delta.start;
      dest[offset++] = delta.deleteCount;
      if (delta.data) {
        dest[offset++] = delta.data.length;
        dest.set(delta.data, offset);
        offset += delta.data.length;
      } else {
        dest[offset++] = 0;
      }
    }
  }
  return toLittleEndianBuffer(dest);
}
function encodeSemanticTokensDtoSize(semanticTokens) {
  let result = 0;
  result += 1 + 1;
  if (semanticTokens.type === "full") {
    result += 1 + semanticTokens.data.length;
  } else {
    result += 1;
    result += (1 + 1 + 1) * semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      if (delta.data) {
        result += delta.data.length;
      }
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/common/services/getSemanticTokens.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isSemanticTokens(v) {
  return v && !!v.data;
}
function isSemanticTokensEdits(v) {
  return v && Array.isArray(v.edits);
}
function getDocumentSemanticTokens(model, lastResultId, token) {
  const provider = _getDocumentSemanticTokensProvider(model);
  if (!provider) {
    return null;
  }
  return {
    provider,
    request: Promise.resolve(provider.provideDocumentSemanticTokens(model, lastResultId, token))
  };
}
function _getDocumentSemanticTokensProvider(model) {
  const result = DocumentSemanticTokensProviderRegistry.ordered(model);
  return result.length > 0 ? result[0] : null;
}
function getDocumentRangeSemanticTokensProvider(model) {
  const result = DocumentRangeSemanticTokensProviderRegistry.ordered(model);
  return result.length > 0 ? result[0] : null;
}
CommandsRegistry.registerCommand("_provideDocumentSemanticTokensLegend", (accessor, ...args) => __awaiter7(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const provider = _getDocumentSemanticTokensProvider(model);
  if (!provider) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokensLegend", uri);
  }
  return provider.getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentSemanticTokens", (accessor, ...args) => __awaiter7(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const r = getDocumentSemanticTokens(model, null, CancellationToken.None);
  if (!r) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokens", uri, model.getFullModelRange());
  }
  const { provider, request } = r;
  let result;
  try {
    result = yield request;
  } catch (err) {
    onUnexpectedExternalError(err);
    return void 0;
  }
  if (!result || !isSemanticTokens(result)) {
    return void 0;
  }
  const buff = encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: result.data
  });
  if (result.resultId) {
    provider.releaseDocumentSemanticTokens(result.resultId);
  }
  return buff;
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokensLegend", (accessor, ...args) => __awaiter7(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const provider = getDocumentRangeSemanticTokensProvider(model);
  if (!provider) {
    return void 0;
  }
  return provider.getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokens", (accessor, ...args) => __awaiter7(void 0, void 0, void 0, function* () {
  const [uri, range2] = args;
  assertType(uri instanceof URI);
  assertType(Range.isIRange(range2));
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const provider = getDocumentRangeSemanticTokensProvider(model);
  if (!provider) {
    return void 0;
  }
  let result;
  try {
    result = yield provider.provideDocumentRangeSemanticTokens(model, Range.lift(range2), CancellationToken.None);
  } catch (err) {
    onUnexpectedExternalError(err);
    return void 0;
  }
  if (!result || !isSemanticTokens(result)) {
    return void 0;
  }
  return encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: result.data
  });
}));

// node_modules/monaco-editor/esm/vs/editor/common/services/modelServiceImpl.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function MODEL_ID(resource) {
  return resource.toString();
}
function computeModelSha1(model) {
  const shaComputer = new StringSHA1();
  const snapshot = model.createSnapshot();
  let text;
  while (text = snapshot.read()) {
    shaComputer.update(text);
  }
  return shaComputer.digest();
}
var ModelData = class {
  constructor(model, onWillDispose, onDidChangeLanguage) {
    this._modelEventListeners = new DisposableStore();
    this.model = model;
    this._languageSelection = null;
    this._languageSelectionListener = null;
    this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));
    this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));
  }
  _disposeLanguageSelection() {
    if (this._languageSelectionListener) {
      this._languageSelectionListener.dispose();
      this._languageSelectionListener = null;
    }
  }
  dispose() {
    this._modelEventListeners.dispose();
    this._disposeLanguageSelection();
  }
  setLanguage(languageSelection) {
    this._disposeLanguageSelection();
    this._languageSelection = languageSelection;
    this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(languageSelection.languageIdentifier));
    this.model.setMode(languageSelection.languageIdentifier);
  }
};
var DEFAULT_EOL = isLinux || isMacintosh ? 1 : 2;
var DisposedModelInfo = class {
  constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {
    this.uri = uri;
    this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;
    this.time = time;
    this.sharesUndoRedoStack = sharesUndoRedoStack;
    this.heapSize = heapSize;
    this.sha1 = sha1;
    this.versionId = versionId;
    this.alternativeVersionId = alternativeVersionId;
  }
};
function schemaShouldMaintainUndoRedoElements(resource) {
  return resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote || resource.scheme === Schemas.userData || resource.scheme === "fake-fs";
}
var ModelServiceImpl = class ModelServiceImpl2 extends Disposable {
  constructor(_configurationService, _resourcePropertiesService, _themeService, _logService, _undoRedoService) {
    super();
    this._configurationService = _configurationService;
    this._resourcePropertiesService = _resourcePropertiesService;
    this._themeService = _themeService;
    this._logService = _logService;
    this._undoRedoService = _undoRedoService;
    this._onModelAdded = this._register(new Emitter());
    this.onModelAdded = this._onModelAdded.event;
    this._onModelRemoved = this._register(new Emitter());
    this.onModelRemoved = this._onModelRemoved.event;
    this._onModelModeChanged = this._register(new Emitter());
    this.onModelModeChanged = this._onModelModeChanged.event;
    this._modelCreationOptionsByLanguageAndResource = Object.create(null);
    this._models = {};
    this._disposedModels = new Map();
    this._disposedModelsHeapSize = 0;
    this._semanticStyling = this._register(new SemanticStyling(this._themeService, this._logService));
    this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions()));
    this._updateModelOptions();
    this._register(new SemanticColoringFeature(this, this._themeService, this._configurationService, this._semanticStyling));
  }
  static _readModelOptions(config, isForSimpleWidget) {
    let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
    if (config.editor && typeof config.editor.tabSize !== "undefined") {
      const parsedTabSize = parseInt(config.editor.tabSize, 10);
      if (!isNaN(parsedTabSize)) {
        tabSize = parsedTabSize;
      }
      if (tabSize < 1) {
        tabSize = 1;
      }
    }
    let indentSize = tabSize;
    if (config.editor && typeof config.editor.indentSize !== "undefined" && config.editor.indentSize !== "tabSize") {
      const parsedIndentSize = parseInt(config.editor.indentSize, 10);
      if (!isNaN(parsedIndentSize)) {
        indentSize = parsedIndentSize;
      }
      if (indentSize < 1) {
        indentSize = 1;
      }
    }
    let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;
    if (config.editor && typeof config.editor.insertSpaces !== "undefined") {
      insertSpaces = config.editor.insertSpaces === "false" ? false : Boolean(config.editor.insertSpaces);
    }
    let newDefaultEOL = DEFAULT_EOL;
    const eol = config.eol;
    if (eol === "\r\n") {
      newDefaultEOL = 2;
    } else if (eol === "\n") {
      newDefaultEOL = 1;
    }
    let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
    if (config.editor && typeof config.editor.trimAutoWhitespace !== "undefined") {
      trimAutoWhitespace = config.editor.trimAutoWhitespace === "false" ? false : Boolean(config.editor.trimAutoWhitespace);
    }
    let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;
    if (config.editor && typeof config.editor.detectIndentation !== "undefined") {
      detectIndentation = config.editor.detectIndentation === "false" ? false : Boolean(config.editor.detectIndentation);
    }
    let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
    if (config.editor && typeof config.editor.largeFileOptimizations !== "undefined") {
      largeFileOptimizations = config.editor.largeFileOptimizations === "false" ? false : Boolean(config.editor.largeFileOptimizations);
    }
    return {
      isForSimpleWidget,
      tabSize,
      indentSize,
      insertSpaces,
      detectIndentation,
      defaultEOL: newDefaultEOL,
      trimAutoWhitespace,
      largeFileOptimizations
    };
  }
  _getEOL(resource, language) {
    if (resource) {
      return this._resourcePropertiesService.getEOL(resource, language);
    }
    const eol = this._configurationService.getValue("files.eol", { overrideIdentifier: language });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return OS === 3 || OS === 2 ? "\n" : "\r\n";
  }
  _shouldRestoreUndoStack() {
    const result = this._configurationService.getValue("files.restoreUndoStack");
    if (typeof result === "boolean") {
      return result;
    }
    return true;
  }
  getCreationOptions(language, resource, isForSimpleWidget) {
    let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
    if (!creationOptions) {
      const editor2 = this._configurationService.getValue("editor", { overrideIdentifier: language, resource });
      const eol = this._getEOL(resource, language);
      creationOptions = ModelServiceImpl2._readModelOptions({ editor: editor2, eol }, isForSimpleWidget);
      this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
    }
    return creationOptions;
  }
  _updateModelOptions() {
    const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = Object.create(null);
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      const modelData = this._models[modelId];
      const language = modelData.model.getLanguageIdentifier().language;
      const uri = modelData.model.uri;
      const oldOptions = oldOptionsByLanguageAndResource[language + uri];
      const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
      ModelServiceImpl2._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
    }
  }
  static _setModelOptionsForModel(model, newOptions, currentOptions) {
    if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {
      model.setEOL(newOptions.defaultEOL === 1 ? 0 : 1);
    }
    if (currentOptions && currentOptions.detectIndentation === newOptions.detectIndentation && currentOptions.insertSpaces === newOptions.insertSpaces && currentOptions.tabSize === newOptions.tabSize && currentOptions.indentSize === newOptions.indentSize && currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace) {
      return;
    }
    if (newOptions.detectIndentation) {
      model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
      model.updateOptions({
        trimAutoWhitespace: newOptions.trimAutoWhitespace
      });
    } else {
      model.updateOptions({
        insertSpaces: newOptions.insertSpaces,
        tabSize: newOptions.tabSize,
        indentSize: newOptions.indentSize,
        trimAutoWhitespace: newOptions.trimAutoWhitespace
      });
    }
  }
  _insertDisposedModel(disposedModelData) {
    this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);
    this._disposedModelsHeapSize += disposedModelData.heapSize;
  }
  _removeDisposedModel(resource) {
    const disposedModelData = this._disposedModels.get(MODEL_ID(resource));
    if (disposedModelData) {
      this._disposedModelsHeapSize -= disposedModelData.heapSize;
    }
    this._disposedModels.delete(MODEL_ID(resource));
    return disposedModelData;
  }
  _ensureDisposedModelsHeapSize(maxModelsHeapSize) {
    if (this._disposedModelsHeapSize > maxModelsHeapSize) {
      const disposedModels = [];
      this._disposedModels.forEach((entry) => {
        if (!entry.sharesUndoRedoStack) {
          disposedModels.push(entry);
        }
      });
      disposedModels.sort((a, b) => a.time - b.time);
      while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {
        const disposedModel = disposedModels.shift();
        this._removeDisposedModel(disposedModel.uri);
        if (disposedModel.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);
        }
      }
    }
  }
  _createModelData(value, languageIdentifier, resource, isForSimpleWidget) {
    const options = this.getCreationOptions(languageIdentifier.language, resource, isForSimpleWidget);
    const model = new TextModel(value, options, languageIdentifier, resource, this._undoRedoService);
    if (resource && this._disposedModels.has(MODEL_ID(resource))) {
      const disposedModelData = this._removeDisposedModel(resource);
      const elements = this._undoRedoService.getElements(resource);
      const sha1IsEqual = computeModelSha1(model) === disposedModelData.sha1;
      if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        this._undoRedoService.setElementsValidFlag(resource, true, (element) => isEditStackElement(element) && element.matchesResource(resource));
        if (sha1IsEqual) {
          model._overwriteVersionId(disposedModelData.versionId);
          model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);
          model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      } else {
        if (disposedModelData.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      }
    }
    const modelId = MODEL_ID(model.uri);
    if (this._models[modelId]) {
      throw new Error("ModelService: Cannot add model because it already exists!");
    }
    const modelData = new ModelData(model, (model2) => this._onWillDispose(model2), (model2, e) => this._onDidChangeLanguage(model2, e));
    this._models[modelId] = modelData;
    return modelData;
  }
  createModel(value, languageSelection, resource, isForSimpleWidget = false) {
    let modelData;
    if (languageSelection) {
      modelData = this._createModelData(value, languageSelection.languageIdentifier, resource, isForSimpleWidget);
      this.setMode(modelData.model, languageSelection);
    } else {
      modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_IDENTIFIER, resource, isForSimpleWidget);
    }
    this._onModelAdded.fire(modelData.model);
    return modelData.model;
  }
  setMode(model, languageSelection) {
    if (!languageSelection) {
      return;
    }
    const modelData = this._models[MODEL_ID(model.uri)];
    if (!modelData) {
      return;
    }
    modelData.setLanguage(languageSelection);
  }
  getModels() {
    const ret = [];
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      ret.push(this._models[modelId].model);
    }
    return ret;
  }
  getModel(resource) {
    const modelId = MODEL_ID(resource);
    const modelData = this._models[modelId];
    if (!modelData) {
      return null;
    }
    return modelData.model;
  }
  getSemanticTokensProviderStyling(provider) {
    return this._semanticStyling.get(provider);
  }
  _onWillDispose(model) {
    const modelId = MODEL_ID(model.uri);
    const modelData = this._models[modelId];
    const sharesUndoRedoStack = this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString();
    let maintainUndoRedoStack = false;
    let heapSize = 0;
    if (sharesUndoRedoStack || this._shouldRestoreUndoStack() && schemaShouldMaintainUndoRedoElements(model.uri)) {
      const elements = this._undoRedoService.getElements(model.uri);
      if (elements.past.length > 0 || elements.future.length > 0) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
      }
    }
    const maxMemory = ModelServiceImpl2.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    if (!maintainUndoRedoStack) {
      if (!sharesUndoRedoStack) {
        const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
        if (initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
        }
      }
    } else if (!sharesUndoRedoStack && heapSize > maxMemory) {
      const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
      if (initialUndoRedoSnapshot !== null) {
        this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
      }
    } else {
      this._ensureDisposedModelsHeapSize(maxMemory - heapSize);
      this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => isEditStackElement(element) && element.matchesResource(model.uri));
      this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, computeModelSha1(model), model.getVersionId(), model.getAlternativeVersionId()));
    }
    delete this._models[modelId];
    modelData.dispose();
    delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageIdentifier().language + model.uri];
    this._onModelRemoved.fire(model);
  }
  _onDidChangeLanguage(model, e) {
    const oldModeId = e.oldLanguage;
    const newModeId = model.getLanguageIdentifier().language;
    const oldOptions = this.getCreationOptions(oldModeId, model.uri, model.isForSimpleWidget);
    const newOptions = this.getCreationOptions(newModeId, model.uri, model.isForSimpleWidget);
    ModelServiceImpl2._setModelOptionsForModel(model, newOptions, oldOptions);
    this._onModelModeChanged.fire({ model, oldModeId });
  }
};
ModelServiceImpl.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
ModelServiceImpl = __decorate8([
  __param8(0, IConfigurationService),
  __param8(1, ITextResourcePropertiesService),
  __param8(2, IThemeService),
  __param8(3, ILogService),
  __param8(4, IUndoRedoService)
], ModelServiceImpl);
var SEMANTIC_HIGHLIGHTING_SETTING_ID = "editor.semanticHighlighting";
function isSemanticColoringEnabled(model, themeService, configurationService) {
  var _a6;
  const setting = (_a6 = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageIdentifier().language, resource: model.uri })) === null || _a6 === void 0 ? void 0 : _a6.enabled;
  if (typeof setting === "boolean") {
    return setting;
  }
  return themeService.getColorTheme().semanticHighlighting;
}
var SemanticColoringFeature = class extends Disposable {
  constructor(modelService, themeService, configurationService, semanticStyling) {
    super();
    this._watchers = Object.create(null);
    this._semanticStyling = semanticStyling;
    const register2 = (model) => {
      this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, themeService, this._semanticStyling);
    };
    const deregister = (model, modelSemanticColoring) => {
      modelSemanticColoring.dispose();
      delete this._watchers[model.uri.toString()];
    };
    const handleSettingOrThemeChange = () => {
      for (let model of modelService.getModels()) {
        const curr = this._watchers[model.uri.toString()];
        if (isSemanticColoringEnabled(model, themeService, configurationService)) {
          if (!curr) {
            register2(model);
          }
        } else {
          if (curr) {
            deregister(model, curr);
          }
        }
      }
    };
    this._register(modelService.onModelAdded((model) => {
      if (isSemanticColoringEnabled(model, themeService, configurationService)) {
        register2(model);
      }
    }));
    this._register(modelService.onModelRemoved((model) => {
      const curr = this._watchers[model.uri.toString()];
      if (curr) {
        deregister(model, curr);
      }
    }));
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        handleSettingOrThemeChange();
      }
    }));
    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));
  }
};
var SemanticStyling = class extends Disposable {
  constructor(_themeService, _logService) {
    super();
    this._themeService = _themeService;
    this._logService = _logService;
    this._caches = new WeakMap();
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = new WeakMap();
    }));
  }
  get(provider) {
    if (!this._caches.has(provider)) {
      this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._logService));
    }
    return this._caches.get(provider);
  }
};
var SemanticTokensResponse = class {
  constructor(_provider, resultId, data) {
    this._provider = _provider;
    this.resultId = resultId;
    this.data = data;
  }
  dispose() {
    this._provider.releaseDocumentSemanticTokens(this.resultId);
  }
};
var ModelSemanticColoring = class extends Disposable {
  constructor(model, themeService, stylingProvider) {
    super();
    this._isDisposed = false;
    this._model = model;
    this._semanticStyling = stylingProvider;
    this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY));
    this._currentDocumentResponse = null;
    this._currentDocumentRequestCancellationTokenSource = null;
    this._documentProvidersChangeListeners = [];
    this._register(this._model.onDidChangeContent(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule();
      }
    }));
    this._register(this._model.onDidChangeLanguage(() => {
      if (this._currentDocumentResponse) {
        this._currentDocumentResponse.dispose();
        this._currentDocumentResponse = null;
      }
      if (this._currentDocumentRequestCancellationTokenSource) {
        this._currentDocumentRequestCancellationTokenSource.cancel();
        this._currentDocumentRequestCancellationTokenSource = null;
      }
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const bindDocumentChangeListeners = () => {
      dispose(this._documentProvidersChangeListeners);
      this._documentProvidersChangeListeners = [];
      for (const provider of DocumentSemanticTokensProviderRegistry.all(model)) {
        if (typeof provider.onDidChange === "function") {
          this._documentProvidersChangeListeners.push(provider.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
        }
      }
    };
    bindDocumentChangeListeners();
    this._register(DocumentSemanticTokensProviderRegistry.onDidChange(() => {
      bindDocumentChangeListeners();
      this._fetchDocumentSemanticTokens.schedule();
    }));
    this._register(themeService.onDidColorThemeChange((_) => {
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule();
    }));
    this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._currentDocumentRequestCancellationTokenSource) {
      this._currentDocumentRequestCancellationTokenSource.cancel();
      this._currentDocumentRequestCancellationTokenSource = null;
    }
    this._setDocumentSemanticTokens(null, null, null, []);
    this._isDisposed = true;
    super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource) {
      return;
    }
    const cancellationTokenSource = new CancellationTokenSource();
    const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;
    const r = getDocumentSemanticTokens(this._model, lastResultId, cancellationTokenSource.token);
    if (!r) {
      if (this._currentDocumentResponse) {
        this._model.setSemanticTokens(null, false);
      }
      return;
    }
    const { provider, request } = r;
    this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;
    const pendingChanges = [];
    const contentChangeListener = this._model.onDidChangeContent((e) => {
      pendingChanges.push(e);
    });
    const styling = this._semanticStyling.get(provider);
    request.then((res) => {
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      this._setDocumentSemanticTokens(provider, res || null, styling, pendingChanges);
    }, (err) => {
      const isExpectedError = err && (isPromiseCanceledError(err) || typeof err.message === "string" && err.message.indexOf("busy") !== -1);
      if (!isExpectedError) {
        onUnexpectedError(err);
      }
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (pendingChanges.length > 0) {
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule();
        }
      }
    });
  }
  static _copy(src, srcOffset, dest, destOffset, length) {
    for (let i = 0; i < length; i++) {
      dest[destOffset + i] = src[srcOffset + i];
    }
  }
  _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {
    const currentResponse = this._currentDocumentResponse;
    const rescheduleIfNeeded = () => {
      if (pendingChanges.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule();
      }
    };
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._isDisposed) {
      if (provider && tokens) {
        provider.releaseDocumentSemanticTokens(tokens.resultId);
      }
      return;
    }
    if (!provider || !styling) {
      this._model.setSemanticTokens(null, false);
      return;
    }
    if (!tokens) {
      this._model.setSemanticTokens(null, true);
      rescheduleIfNeeded();
      return;
    }
    if (isSemanticTokensEdits(tokens)) {
      if (!currentResponse) {
        this._model.setSemanticTokens(null, true);
        return;
      }
      if (tokens.edits.length === 0) {
        tokens = {
          resultId: tokens.resultId,
          data: currentResponse.data
        };
      } else {
        let deltaLength = 0;
        for (const edit of tokens.edits) {
          deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;
        }
        const srcData = currentResponse.data;
        const destData = new Uint32Array(srcData.length + deltaLength);
        let srcLastStart = srcData.length;
        let destLastStart = destData.length;
        for (let i = tokens.edits.length - 1; i >= 0; i--) {
          const edit = tokens.edits[i];
          const copyCount = srcLastStart - (edit.start + edit.deleteCount);
          if (copyCount > 0) {
            ModelSemanticColoring._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);
            destLastStart -= copyCount;
          }
          if (edit.data) {
            ModelSemanticColoring._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);
            destLastStart -= edit.data.length;
          }
          srcLastStart = edit.start;
        }
        if (srcLastStart > 0) {
          ModelSemanticColoring._copy(srcData, 0, destData, 0, srcLastStart);
        }
        tokens = {
          resultId: tokens.resultId,
          data: destData
        };
      }
    }
    if (isSemanticTokens(tokens)) {
      this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);
      const result = toMultilineTokens2(tokens, styling, this._model.getLanguageIdentifier());
      if (pendingChanges.length > 0) {
        for (const change of pendingChanges) {
          for (const area of result) {
            for (const singleChange of change.changes) {
              area.applyEdit(singleChange.range, singleChange.text);
            }
          }
        }
      }
      this._model.setSemanticTokens(result, true);
    } else {
      this._model.setSemanticTokens(null, true);
    }
    rescheduleIfNeeded();
  }
};
ModelSemanticColoring.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY = 300;

// node_modules/monaco-editor/esm/vs/editor/common/modes/supports/tokenization.js
var ParsedTokenThemeRule = class {
  constructor(token, index, fontStyle, foreground, background) {
    this._parsedThemeRuleBrand = void 0;
    this.token = token;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
};
function parseTokenTheme(source) {
  if (!source || !Array.isArray(source)) {
    return [];
  }
  let result = [], resultLen = 0;
  for (let i = 0, len = source.length; i < len; i++) {
    let entry = source[i];
    let fontStyle = -1;
    if (typeof entry.fontStyle === "string") {
      fontStyle = 0;
      let segments = entry.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        let segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
        }
      }
    }
    let foreground = null;
    if (typeof entry.foreground === "string") {
      foreground = entry.foreground;
    }
    let background = null;
    if (typeof entry.background === "string") {
      background = entry.background;
    }
    result[resultLen++] = new ParsedTokenThemeRule(entry.token || "", i, fontStyle, foreground, background);
  }
  return result;
}
function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {
  parsedThemeRules.sort((a, b) => {
    let r = strcmp(a.token, b.token);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "000000";
  let defaultBackground = "ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === "") {
    let incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  let colorMap = new ColorMap();
  for (let color of customTokenColors) {
    colorMap.getId(color);
  }
  let foregroundColorId = colorMap.getId(defaultForeground);
  let backgroundColorId = colorMap.getId(defaultBackground);
  let defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);
  let root = new ThemeTrieElement(defaults);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    let rule = parsedThemeRules[i];
    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new TokenTheme(colorMap, root);
}
var colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
var ColorMap = class {
  constructor() {
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = new Map();
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    const match = color.match(colorRegExp);
    if (!match) {
      throw new Error("Illegal value for token color: " + color);
    }
    color = match[1].toUpperCase();
    let value = this._color2id.get(color);
    if (value) {
      return value;
    }
    value = ++this._lastColorId;
    this._color2id.set(color, value);
    this._id2color[value] = Color.fromHex("#" + color);
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var TokenTheme = class {
  constructor(colorMap, root) {
    this._colorMap = colorMap;
    this._root = root;
    this._cache = new Map();
  }
  static createFromRawTokenTheme(source, customTokenColors) {
    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);
  }
  static createFromParsedTokenTheme(source, customTokenColors) {
    return resolveParsedTokenThemeRules(source, customTokenColors);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(token) {
    return this._root.match(token);
  }
  match(languageId, token) {
    let result = this._cache.get(token);
    if (typeof result === "undefined") {
      let rule = this._match(token);
      let standardToken = toStandardTokenType(token);
      result = (rule.metadata | standardToken << 8) >>> 0;
      this._cache.set(token, result);
    }
    return (result | languageId << 0) >>> 0;
  }
};
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|regexp)\b/;
function toStandardTokenType(tokenType) {
  let m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
  if (!m) {
    return 0;
  }
  switch (m[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 4;
    case "regexp":
      return 4;
  }
  throw new Error("Unexpected match for standard token type!");
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
var ThemeTrieElementRule = class {
  constructor(fontStyle, foreground, background) {
    this._themeTrieElementRuleBrand = void 0;
    this._fontStyle = fontStyle;
    this._foreground = foreground;
    this._background = background;
    this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
  clone() {
    return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(fontStyle, foreground, background) {
    if (fontStyle !== -1) {
      this._fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      this._foreground = foreground;
    }
    if (background !== 0) {
      this._background = background;
    }
    this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
};
var ThemeTrieElement = class {
  constructor(mainRule) {
    this._themeTrieElementBrand = void 0;
    this._mainRule = mainRule;
    this._children = new Map();
  }
  match(token) {
    if (token === "") {
      return this._mainRule;
    }
    let dotIndex = token.indexOf(".");
    let head;
    let tail;
    if (dotIndex === -1) {
      head = token;
      tail = "";
    } else {
      head = token.substring(0, dotIndex);
      tail = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child !== "undefined") {
      return child.match(tail);
    }
    return this._mainRule;
  }
  insert(token, fontStyle, foreground, background) {
    if (token === "") {
      this._mainRule.acceptOverwrite(fontStyle, foreground, background);
      return;
    }
    let dotIndex = token.indexOf(".");
    let head;
    let tail;
    if (dotIndex === -1) {
      head = token;
      tail = "";
    } else {
      head = token.substring(0, dotIndex);
      tail = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child === "undefined") {
      child = new ThemeTrieElement(this._mainRule.clone());
      this._children.set(head, child);
    }
    child.insert(tail, fontStyle, foreground, background);
  }
};
function generateTokensCSSForColorMap(colorMap) {
  let rules = [];
  for (let i = 1, len = colorMap.length; i < len; i++) {
    let color = colorMap[i];
    rules[i] = `.mtk${i} { color: ${color}; }`;
  }
  rules.push(".mtki { font-style: italic; }");
  rules.push(".mtkb { font-weight: bold; }");
  rules.push(".mtku { text-decoration: underline; text-underline-position: under; }");
  return rules.join("\n");
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js
var vs = {
  base: "vs",
  inherit: false,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [editorBackground]: "#FFFFFE",
    [editorForeground]: "#000000",
    [editorInactiveSelection]: "#E5EBF1",
    [editorIndentGuides]: "#D3D3D3",
    [editorActiveIndentGuides]: "#939393",
    [editorSelectionHighlight]: "#ADD6FF4D"
  }
};
var vs_dark = {
  base: "vs-dark",
  inherit: false,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#1E1E1E",
    [editorForeground]: "#D4D4D4",
    [editorInactiveSelection]: "#3A3D41",
    [editorIndentGuides]: "#404040",
    [editorActiveIndentGuides]: "#707070",
    [editorSelectionHighlight]: "#ADD6FF26"
  }
};
var hc_black = {
  base: "hc-black",
  inherit: false,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#000000",
    [editorForeground]: "#FFFFFF",
    [editorIndentGuides]: "#FFFFFF",
    [editorActiveIndentGuides]: "#FFFFFF"
  }
};

// node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js
function getIconsStyleSheet() {
  const onDidChangeEmmiter = new Emitter();
  const iconRegistry = getIconRegistry();
  iconRegistry.onDidChange(() => onDidChangeEmmiter.fire());
  return {
    onDidChange: onDidChangeEmmiter.event,
    getCSS() {
      const usedFontIds = {};
      const formatIconRule = (contribution) => {
        let definition = contribution.defaults;
        while (ThemeIcon.isThemeIcon(definition)) {
          const c = iconRegistry.getIcon(definition.id);
          if (!c) {
            return void 0;
          }
          definition = c.defaults;
        }
        const fontId = definition.fontId;
        if (fontId) {
          const fontContribution = iconRegistry.getIconFont(fontId);
          if (fontContribution) {
            usedFontIds[fontId] = fontContribution;
            return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontId)}; }`;
          }
        }
        return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`;
      };
      const rules = [];
      for (let contribution of iconRegistry.getIcons()) {
        const rule = formatIconRule(contribution);
        if (rule) {
          rules.push(rule);
        }
      }
      for (let id in usedFontIds) {
        const fontContribution = usedFontIds[id];
        const src = fontContribution.definition.src.map((l) => `${asCSSUrl(l.location)} format('${l.format}')`).join(", ");
        rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)}; }`);
      }
      return rules.join("\n");
    }
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeServiceImpl.js
var VS_THEME_NAME = "vs";
var VS_DARK_THEME_NAME = "vs-dark";
var HC_BLACK_THEME_NAME = "hc-black";
var colorRegistry = Registry.as(Extensions3.ColorContribution);
var themingRegistry = Registry.as(Extensions2.ThemingContribution);
var StandaloneTheme = class {
  constructor(name, standaloneThemeData) {
    this.semanticHighlighting = false;
    this.themeData = standaloneThemeData;
    let base = standaloneThemeData.base;
    if (name.length > 0) {
      if (isBuiltinTheme(name)) {
        this.id = name;
      } else {
        this.id = base + " " + name;
      }
      this.themeName = name;
    } else {
      this.id = base;
      this.themeName = base;
    }
    this.colors = null;
    this.defaultColors = Object.create(null);
    this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    if (this.themeData.inherit) {
      this.colors = null;
      this._tokenTheme = null;
    }
  }
  getColors() {
    if (!this.colors) {
      const colors = new Map();
      for (let id in this.themeData.colors) {
        colors.set(id, Color.fromHex(this.themeData.colors[id]));
      }
      if (this.themeData.inherit) {
        let baseData = getBuiltinRules(this.themeData.base);
        for (let id in baseData.colors) {
          if (!colors.has(id)) {
            colors.set(id, Color.fromHex(baseData.colors[id]));
          }
        }
      }
      this.colors = colors;
    }
    return this.colors;
  }
  getColor(colorId, useDefault) {
    const color = this.getColors().get(colorId);
    if (color) {
      return color;
    }
    if (useDefault !== false) {
      return this.getDefault(colorId);
    }
    return void 0;
  }
  getDefault(colorId) {
    let color = this.defaultColors[colorId];
    if (color) {
      return color;
    }
    color = colorRegistry.resolveDefaultColor(colorId, this);
    this.defaultColors[colorId] = color;
    return color;
  }
  defines(colorId) {
    return Object.prototype.hasOwnProperty.call(this.getColors(), colorId);
  }
  get type() {
    switch (this.base) {
      case VS_THEME_NAME:
        return ColorScheme.LIGHT;
      case HC_BLACK_THEME_NAME:
        return ColorScheme.HIGH_CONTRAST;
      default:
        return ColorScheme.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let rules = [];
      let encodedTokensColors = [];
      if (this.themeData.inherit) {
        let baseData = getBuiltinRules(this.themeData.base);
        rules = baseData.rules;
        if (baseData.encodedTokensColors) {
          encodedTokensColors = baseData.encodedTokensColors;
        }
      }
      rules = rules.concat(this.themeData.rules);
      if (this.themeData.encodedTokensColors) {
        encodedTokensColors = this.themeData.encodedTokensColors;
      }
      this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(type, modifiers, modelLanguage) {
    const style = this.tokenTheme._match([type].concat(modifiers).join("."));
    const metadata = style.metadata;
    const foreground = TokenMetadata.getForeground(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    return {
      foreground,
      italic: Boolean(fontStyle & 1),
      bold: Boolean(fontStyle & 2),
      underline: Boolean(fontStyle & 4)
    };
  }
};
function isBuiltinTheme(themeName) {
  return themeName === VS_THEME_NAME || themeName === VS_DARK_THEME_NAME || themeName === HC_BLACK_THEME_NAME;
}
function getBuiltinRules(builtinTheme) {
  switch (builtinTheme) {
    case VS_THEME_NAME:
      return vs;
    case VS_DARK_THEME_NAME:
      return vs_dark;
    case HC_BLACK_THEME_NAME:
      return hc_black;
  }
}
function newBuiltInTheme(builtinTheme) {
  let themeData = getBuiltinRules(builtinTheme);
  return new StandaloneTheme(builtinTheme, themeData);
}
var StandaloneThemeServiceImpl = class extends Disposable {
  constructor() {
    super();
    this._onColorThemeChange = this._register(new Emitter());
    this.onDidColorThemeChange = this._onColorThemeChange.event;
    this._environment = Object.create(null);
    this._autoDetectHighContrast = true;
    this._knownThemes = new Map();
    this._knownThemes.set(VS_THEME_NAME, newBuiltInTheme(VS_THEME_NAME));
    this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));
    this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));
    const iconsStyleSheet = getIconsStyleSheet();
    this._codiconCSS = iconsStyleSheet.getCSS();
    this._themeCSS = "";
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._globalStyleElement = null;
    this._styleElements = [];
    this._colorMapOverride = null;
    this.setTheme(VS_THEME_NAME);
    iconsStyleSheet.onDidChange(() => {
      this._codiconCSS = iconsStyleSheet.getCSS();
      this._updateCSS();
    });
    addMatchMediaChangeListener("(forced-colors: active)", () => {
      this._updateActualTheme();
    });
  }
  registerEditorContainer(domNode) {
    if (isInShadowDOM(domNode)) {
      return this._registerShadowDomContainer(domNode);
    }
    return this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    if (!this._globalStyleElement) {
      this._globalStyleElement = createStyleSheet();
      this._globalStyleElement.className = "monaco-colors";
      this._globalStyleElement.textContent = this._allCSS;
      this._styleElements.push(this._globalStyleElement);
    }
    return Disposable.None;
  }
  _registerShadowDomContainer(domNode) {
    const styleElement = createStyleSheet(domNode);
    styleElement.className = "monaco-colors";
    styleElement.textContent = this._allCSS;
    this._styleElements.push(styleElement);
    return {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++) {
          if (this._styleElements[i] === styleElement) {
            this._styleElements.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  defineTheme(themeName, themeData) {
    if (!/^[a-z0-9\-]+$/i.test(themeName)) {
      throw new Error("Illegal theme name!");
    }
    if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
      throw new Error("Illegal theme base!");
    }
    this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));
    if (isBuiltinTheme(themeName)) {
      this._knownThemes.forEach((theme) => {
        if (theme.base === themeName) {
          theme.notifyBaseUpdated();
        }
      });
    }
    if (this._theme.themeName === themeName) {
      this.setTheme(themeName);
    }
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(colorMapOverride) {
    this._colorMapOverride = colorMapOverride;
    this._updateThemeOrColorMap();
  }
  setTheme(themeName) {
    let theme;
    if (this._knownThemes.has(themeName)) {
      theme = this._knownThemes.get(themeName);
    } else {
      theme = this._knownThemes.get(VS_THEME_NAME);
    }
    this._desiredTheme = theme;
    this._updateActualTheme();
  }
  _updateActualTheme() {
    const theme = this._autoDetectHighContrast && window.matchMedia(`(forced-colors: active)`).matches ? this._knownThemes.get(HC_BLACK_THEME_NAME) : this._desiredTheme;
    if (this._theme === theme) {
      return;
    }
    this._theme = theme;
    this._updateThemeOrColorMap();
  }
  setAutoDetectHighContrast(autoDetectHighContrast) {
    this._autoDetectHighContrast = autoDetectHighContrast;
    this._updateActualTheme();
  }
  _updateThemeOrColorMap() {
    let cssRules = [];
    let hasRule = {};
    let ruleCollector = {
      addRule: (rule) => {
        if (!hasRule[rule]) {
          cssRules.push(rule);
          hasRule[rule] = true;
        }
      }
    };
    themingRegistry.getThemingParticipants().forEach((p) => p(this._theme, ruleCollector, this._environment));
    const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));
    this._themeCSS = cssRules.join("\n");
    this._updateCSS();
    TokenizationRegistry.setColorMap(colorMap);
    this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._styleElements.forEach((styleElement) => styleElement.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: false,
      hasFolderIcons: false,
      hidesExplorerArrows: false
    };
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextkey/browser/contextKeyService.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KEYBINDING_CONTEXT_ATTR = "data-keybinding-context";
var Context = class {
  constructor(id, parent) {
    this._id = id;
    this._parent = parent;
    this._value = Object.create(null);
    this._value["_contextId"] = id;
  }
  setValue(key, value) {
    if (this._value[key] !== value) {
      this._value[key] = value;
      return true;
    }
    return false;
  }
  removeValue(key) {
    if (key in this._value) {
      delete this._value[key];
      return true;
    }
    return false;
  }
  getValue(key) {
    const ret = this._value[key];
    if (typeof ret === "undefined" && this._parent) {
      return this._parent.getValue(key);
    }
    return ret;
  }
};
var NullContext = class extends Context {
  constructor() {
    super(-1, null);
  }
  setValue(key, value) {
    return false;
  }
  removeValue(key) {
    return false;
  }
  getValue(key) {
    return void 0;
  }
};
NullContext.INSTANCE = new NullContext();
var ConfigAwareContextValuesContainer = class extends Context {
  constructor(id, _configurationService, emitter) {
    super(id, null);
    this._configurationService = _configurationService;
    this._values = TernarySearchTree.forConfigKeys();
    this._listener = this._configurationService.onDidChangeConfiguration((event) => {
      if (event.source === 6) {
        const allKeys = Array.from(Iterable.map(this._values, ([k]) => k));
        this._values.clear();
        emitter.fire(new ArrayContextKeyChangeEvent(allKeys));
      } else {
        const changedKeys = [];
        for (const configKey of event.affectedKeys) {
          const contextKey = `config.${configKey}`;
          const cachedItems = this._values.findSuperstr(contextKey);
          if (cachedItems !== void 0) {
            changedKeys.push(...Iterable.map(cachedItems, ([key]) => key));
            this._values.deleteSuperstr(contextKey);
          }
          if (this._values.has(contextKey)) {
            changedKeys.push(contextKey);
            this._values.delete(contextKey);
          }
        }
        emitter.fire(new ArrayContextKeyChangeEvent(changedKeys));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(key) {
    if (key.indexOf(ConfigAwareContextValuesContainer._keyPrefix) !== 0) {
      return super.getValue(key);
    }
    if (this._values.has(key)) {
      return this._values.get(key);
    }
    const configKey = key.substr(ConfigAwareContextValuesContainer._keyPrefix.length);
    const configValue = this._configurationService.getValue(configKey);
    let value = void 0;
    switch (typeof configValue) {
      case "number":
      case "boolean":
      case "string":
        value = configValue;
        break;
      default:
        if (Array.isArray(configValue)) {
          value = JSON.stringify(configValue);
        } else {
          value = configValue;
        }
    }
    this._values.set(key, value);
    return value;
  }
  setValue(key, value) {
    return super.setValue(key, value);
  }
  removeValue(key) {
    return super.removeValue(key);
  }
};
ConfigAwareContextValuesContainer._keyPrefix = "config.";
var ContextKey = class {
  constructor(service, key, defaultValue) {
    this._service = service;
    this._key = key;
    this._defaultValue = defaultValue;
    this.reset();
  }
  set(value) {
    this._service.setContext(this._key, value);
  }
  reset() {
    if (typeof this._defaultValue === "undefined") {
      this._service.removeContext(this._key);
    } else {
      this._service.setContext(this._key, this._defaultValue);
    }
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
};
var SimpleContextKeyChangeEvent = class {
  constructor(key) {
    this.key = key;
  }
  affectsSome(keys) {
    return keys.has(this.key);
  }
};
var ArrayContextKeyChangeEvent = class {
  constructor(keys) {
    this.keys = keys;
  }
  affectsSome(keys) {
    for (const key of this.keys) {
      if (keys.has(key)) {
        return true;
      }
    }
    return false;
  }
};
var CompositeContextKeyChangeEvent = class {
  constructor(events) {
    this.events = events;
  }
  affectsSome(keys) {
    for (const e of this.events) {
      if (e.affectsSome(keys)) {
        return true;
      }
    }
    return false;
  }
};
var AbstractContextKeyService = class {
  constructor(myContextId) {
    this._onDidChangeContext = new PauseableEmitter({ merge: (input) => new CompositeContextKeyChangeEvent(input) });
    this.onDidChangeContext = this._onDidChangeContext.event;
    this._isDisposed = false;
    this._myContextId = myContextId;
  }
  createKey(key, defaultValue) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ContextKey(this, key, defaultValue);
  }
  bufferChangeEvents(callback) {
    this._onDidChangeContext.pause();
    try {
      callback();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(domNode) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ScopedContextKeyService(this, domNode);
  }
  contextMatchesRules(rules) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    const context = this.getContextValuesContainer(this._myContextId);
    const result = KeybindingResolver.contextMatchesRules(context, rules);
    return result;
  }
  getContextKeyValue(key) {
    if (this._isDisposed) {
      return void 0;
    }
    return this.getContextValuesContainer(this._myContextId).getValue(key);
  }
  setContext(key, value) {
    if (this._isDisposed) {
      return;
    }
    const myContext = this.getContextValuesContainer(this._myContextId);
    if (!myContext) {
      return;
    }
    if (myContext.setValue(key, value)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  removeContext(key) {
    if (this._isDisposed) {
      return;
    }
    if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  getContext(target) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this.getContextValuesContainer(findContextAttr(target));
  }
};
var ContextKeyService = class ContextKeyService2 extends AbstractContextKeyService {
  constructor(configurationService) {
    super(0);
    this._contexts = new Map();
    this._toDispose = new DisposableStore();
    this._lastContextId = 0;
    const myContext = new ConfigAwareContextValuesContainer(this._myContextId, configurationService, this._onDidChangeContext);
    this._contexts.set(this._myContextId, myContext);
    this._toDispose.add(myContext);
  }
  dispose() {
    this._onDidChangeContext.dispose();
    this._isDisposed = true;
    this._toDispose.dispose();
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._contexts.get(contextId) || NullContext.INSTANCE;
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ContextKeyService has been disposed`);
    }
    let id = ++this._lastContextId;
    this._contexts.set(id, new Context(id, this.getContextValuesContainer(parentContextId)));
    return id;
  }
  disposeContext(contextId) {
    if (!this._isDisposed) {
      this._contexts.delete(contextId);
    }
  }
};
ContextKeyService = __decorate9([
  __param9(0, IConfigurationService)
], ContextKeyService);
var ScopedContextKeyService = class extends AbstractContextKeyService {
  constructor(parent, domNode) {
    super(parent.createChildContext());
    this._parentChangeListener = new MutableDisposable();
    this._parent = parent;
    this._updateParentChangeListener();
    this._domNode = domNode;
    if (this._domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      let extraInfo = "";
      if (this._domNode.classList) {
        extraInfo = Array.from(this._domNode.classList.values()).join(", ");
      }
      console.error(`Element already has context attribute${extraInfo ? ": " + extraInfo : ""}`);
    }
    this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext(this._onDidChangeContext.fire, this._onDidChangeContext);
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._onDidChangeContext.dispose();
    this._parent.disposeContext(this._myContextId);
    this._parentChangeListener.dispose();
    this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
    this._isDisposed = true;
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._parent.getContextValuesContainer(contextId);
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ScopedContextKeyService has been disposed`);
    }
    return this._parent.createChildContext(parentContextId);
  }
  disposeContext(contextId) {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(contextId);
  }
};
function findContextAttr(domNode) {
  while (domNode) {
    if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);
      if (attr) {
        return parseInt(attr, 10);
      }
      return NaN;
    }
    domNode = domNode.parentElement;
  }
  return 0;
}
CommandsRegistry.registerCommand(SET_CONTEXT_COMMAND_ID, function(accessor, contextKey, contextValue) {
  accessor.get(IContextKeyService).createKey(String(contextKey), contextValue);
});
CommandsRegistry.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...RawContextKey.all()].sort((a, b) => a.key.localeCompare(b.key));
  },
  description: {
    description: localize("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
CommandsRegistry.registerCommand("_generateContextKeyInfo", function() {
  const result = [];
  const seen = new Set();
  for (let info of RawContextKey.all()) {
    if (!seen.has(info.key)) {
      seen.add(info.key);
      result.push(info);
    }
  }
  result.sort((a, b) => a.key.localeCompare(b.key));
  console.log(JSON.stringify(result, void 0, 2));
});

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.css";
var LayoutAnchorMode;
(function(LayoutAnchorMode2) {
  LayoutAnchorMode2[LayoutAnchorMode2["AVOID"] = 0] = "AVOID";
  LayoutAnchorMode2[LayoutAnchorMode2["ALIGN"] = 1] = "ALIGN";
})(LayoutAnchorMode || (LayoutAnchorMode = {}));
function layout(viewportSize, viewSize, anchor) {
  const layoutAfterAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset : anchor.offset + anchor.size;
  const layoutBeforeAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset + anchor.size : anchor.offset;
  if (anchor.position === 0) {
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary;
    }
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize;
    }
    return Math.max(viewportSize - viewSize, 0);
  } else {
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize;
    }
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary;
    }
    return 0;
  }
}
var ContextView = class extends Disposable {
  constructor(container, domPosition) {
    super();
    this.container = null;
    this.delegate = null;
    this.toDisposeOnClean = Disposable.None;
    this.toDisposeOnSetContainer = Disposable.None;
    this.shadowRoot = null;
    this.shadowRootHostElement = null;
    this.view = $(".context-view");
    this.useFixedPosition = false;
    this.useShadowDOM = false;
    hide(this.view);
    this.setContainer(container, domPosition);
    this._register(toDisposable(() => this.setContainer(null, 1)));
  }
  setContainer(container, domPosition) {
    var _a6;
    if (this.container) {
      this.toDisposeOnSetContainer.dispose();
      if (this.shadowRoot) {
        this.shadowRoot.removeChild(this.view);
        this.shadowRoot = null;
        (_a6 = this.shadowRootHostElement) === null || _a6 === void 0 ? void 0 : _a6.remove();
        this.shadowRootHostElement = null;
      } else {
        this.container.removeChild(this.view);
      }
      this.container = null;
    }
    if (container) {
      this.container = container;
      this.useFixedPosition = domPosition !== 1;
      this.useShadowDOM = domPosition === 3;
      if (this.useShadowDOM) {
        this.shadowRootHostElement = $(".shadow-root-host");
        this.container.appendChild(this.shadowRootHostElement);
        this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const style = document.createElement("style");
        style.textContent = SHADOW_ROOT_CSS;
        this.shadowRoot.appendChild(style);
        this.shadowRoot.appendChild(this.view);
        this.shadowRoot.appendChild($("slot"));
      } else {
        this.container.appendChild(this.view);
      }
      const toDisposeOnSetContainer = new DisposableStore();
      ContextView.BUBBLE_UP_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, false);
        }));
      });
      ContextView.BUBBLE_DOWN_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, true);
        }, true));
      });
      this.toDisposeOnSetContainer = toDisposeOnSetContainer;
    }
  }
  show(delegate) {
    if (this.isVisible()) {
      this.hide();
    }
    clearNode(this.view);
    this.view.className = "context-view";
    this.view.style.top = "0px";
    this.view.style.left = "0px";
    this.view.style.zIndex = "2500";
    this.view.style.position = this.useFixedPosition ? "fixed" : "absolute";
    show(this.view);
    this.toDisposeOnClean = delegate.render(this.view) || Disposable.None;
    this.delegate = delegate;
    this.doLayout();
    if (this.delegate.focus) {
      this.delegate.focus();
    }
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (!this.isVisible()) {
      return;
    }
    if (this.delegate.canRelayout === false && !(isIOS && BrowserFeatures.pointerEvents)) {
      this.hide();
      return;
    }
    if (this.delegate.layout) {
      this.delegate.layout();
    }
    this.doLayout();
  }
  doLayout() {
    if (!this.isVisible()) {
      return;
    }
    let anchor = this.delegate.getAnchor();
    let around;
    if (isHTMLElement(anchor)) {
      let elementPosition = getDomNodePagePosition(anchor);
      around = {
        top: elementPosition.top,
        left: elementPosition.left,
        width: elementPosition.width,
        height: elementPosition.height
      };
    } else {
      around = {
        top: anchor.y,
        left: anchor.x,
        width: anchor.width || 1,
        height: anchor.height || 2
      };
    }
    const viewSizeWidth = getTotalWidth(this.view);
    const viewSizeHeight = getTotalHeight(this.view);
    const anchorPosition = this.delegate.anchorPosition || 0;
    const anchorAlignment = this.delegate.anchorAlignment || 0;
    const anchorAxisAlignment = this.delegate.anchorAxisAlignment || 0;
    let top;
    let left;
    if (anchorAxisAlignment === 0) {
      const verticalAnchor = { offset: around.top - window.pageYOffset, size: around.height, position: anchorPosition === 0 ? 0 : 1 };
      const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 ? 0 : 1, mode: LayoutAnchorMode.ALIGN };
      top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;
      if (Range2.intersects({ start: top, end: top + viewSizeHeight }, { start: verticalAnchor.offset, end: verticalAnchor.offset + verticalAnchor.size })) {
        horizontalAnchor.mode = LayoutAnchorMode.AVOID;
      }
      left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);
    } else {
      const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 ? 0 : 1 };
      const verticalAnchor = { offset: around.top, size: around.height, position: anchorPosition === 0 ? 0 : 1, mode: LayoutAnchorMode.ALIGN };
      left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);
      if (Range2.intersects({ start: left, end: left + viewSizeWidth }, { start: horizontalAnchor.offset, end: horizontalAnchor.offset + horizontalAnchor.size })) {
        verticalAnchor.mode = LayoutAnchorMode.AVOID;
      }
      top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right");
    this.view.classList.add(anchorPosition === 0 ? "bottom" : "top");
    this.view.classList.add(anchorAlignment === 0 ? "left" : "right");
    this.view.classList.toggle("fixed", this.useFixedPosition);
    const containerPosition = getDomNodePagePosition(this.container);
    this.view.style.top = `${top - (this.useFixedPosition ? getDomNodePagePosition(this.view).top : containerPosition.top)}px`;
    this.view.style.left = `${left - (this.useFixedPosition ? getDomNodePagePosition(this.view).left : containerPosition.left)}px`;
    this.view.style.width = "initial";
  }
  hide(data) {
    const delegate = this.delegate;
    this.delegate = null;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.onHide) {
      delegate.onHide(data);
    }
    this.toDisposeOnClean.dispose();
    hide(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, onCapture) {
    if (this.delegate) {
      if (this.delegate.onDOMEvent) {
        this.delegate.onDOMEvent(e, document.activeElement);
      } else if (onCapture && !isAncestor(e.target, this.container)) {
        this.hide();
      }
    }
  }
  dispose() {
    this.hide();
    super.dispose();
  }
};
ContextView.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
ContextView.BUBBLE_DOWN_EVENTS = ["click"];
var SHADOW_ROOT_CSS = `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;

// node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js
var MENU_MNEMONIC_REGEX = /\(&([^\s&])\)|(^|[^&])&([^\s&])/;
var MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\s&])/g;
var menuSelectionIcon = registerCodicon("menu-selection", Codicon.check);
var menuSubmenuIcon = registerCodicon("menu-submenu", Codicon.chevronRight);
var Direction;
(function(Direction2) {
  Direction2[Direction2["Right"] = 0] = "Right";
  Direction2[Direction2["Left"] = 1] = "Left";
})(Direction || (Direction = {}));
var Menu = class extends ActionBar {
  constructor(container, actions, options = {}) {
    container.classList.add("monaco-menu-container");
    container.setAttribute("role", "presentation");
    const menuElement = document.createElement("div");
    menuElement.classList.add("monaco-menu");
    menuElement.setAttribute("role", "presentation");
    super(menuElement, {
      orientation: 1,
      actionViewItemProvider: (action) => this.doGetActionViewItem(action, options, parentData),
      context: options.context,
      actionRunner: options.actionRunner,
      ariaLabel: options.ariaLabel,
      focusOnlyEnabledItems: true,
      triggerKeys: { keys: [3, ...isMacintosh || isLinux ? [10] : []], keyDown: true }
    });
    this.menuElement = menuElement;
    this.actionsList.setAttribute("role", "menu");
    this.actionsList.tabIndex = 0;
    this.menuDisposables = this._register(new DisposableStore());
    this.initializeStyleSheet(container);
    addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(2)) {
        e.preventDefault();
      }
    });
    if (options.enableMnemonics) {
      this.menuDisposables.add(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const key = e.key.toLocaleLowerCase();
        if (this.mnemonics.has(key)) {
          EventHelper.stop(e, true);
          const actions2 = this.mnemonics.get(key);
          if (actions2.length === 1) {
            if (actions2[0] instanceof SubmenuMenuActionViewItem && actions2[0].container) {
              this.focusItemByElement(actions2[0].container);
            }
            actions2[0].onClick(e);
          }
          if (actions2.length > 1) {
            const action = actions2.shift();
            if (action && action.container) {
              this.focusItemByElement(action.container);
              actions2.push(action);
            }
            this.mnemonics.set(key, actions2);
          }
        }
      }));
    }
    if (isLinux) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(14) || event.equals(11)) {
          this.focusedItem = this.viewItems.length - 1;
          this.focusNext();
          EventHelper.stop(e, true);
        } else if (event.equals(13) || event.equals(12)) {
          this.focusedItem = 0;
          this.focusPrevious();
          EventHelper.stop(e, true);
        }
      }));
    }
    this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, (e) => {
      let relatedTarget = e.relatedTarget;
      if (!isAncestor(relatedTarget, this.domNode)) {
        this.focusedItem = void 0;
        this.updateFocus();
        e.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, (e) => {
      let target = e.target;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (target.classList.contains("action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    let parentData = {
      parent: this
    };
    this.mnemonics = new Map();
    this.scrollableElement = this._register(new DomScrollableElement(menuElement, {
      alwaysConsumeMouseWheel: true,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: true,
      useShadows: true
    }));
    const scrollElement = this.scrollableElement.getDomNode();
    scrollElement.style.position = "";
    this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, (e) => {
      e.preventDefault();
    }));
    menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;
    actions = actions.filter((a) => {
      var _a6;
      if ((_a6 = options.submenuIds) === null || _a6 === void 0 ? void 0 : _a6.has(a.id)) {
        console.warn(`Found submenu cycle: ${a.id}`);
        return false;
      }
      return true;
    });
    this.push(actions, { icon: true, label: true, isMenu: true });
    container.appendChild(this.scrollableElement.getDomNode());
    this.scrollableElement.scanDomNode();
    this.viewItems.filter((item) => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {
      item.updatePositionInSet(index + 1, array.length);
    });
  }
  initializeStyleSheet(container) {
    if (isInShadowDOM(container)) {
      this.styleSheet = createStyleSheet(container);
      this.styleSheet.textContent = MENU_WIDGET_CSS;
    } else {
      if (!Menu.globalStyleSheet) {
        Menu.globalStyleSheet = createStyleSheet();
        Menu.globalStyleSheet.textContent = MENU_WIDGET_CSS;
      }
      this.styleSheet = Menu.globalStyleSheet;
    }
  }
  style(style) {
    const container = this.getContainer();
    const fgColor = style.foregroundColor ? `${style.foregroundColor}` : "";
    const bgColor = style.backgroundColor ? `${style.backgroundColor}` : "";
    const border = style.borderColor ? `1px solid ${style.borderColor}` : "";
    const shadow = style.shadowColor ? `0 2px 4px ${style.shadowColor}` : "";
    container.style.border = border;
    this.domNode.style.color = fgColor;
    this.domNode.style.backgroundColor = bgColor;
    container.style.boxShadow = shadow;
    if (this.viewItems) {
      this.viewItems.forEach((item) => {
        if (item instanceof BaseMenuActionViewItem || item instanceof MenuSeparatorActionViewItem) {
          item.style(style);
        }
      });
    }
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(element) {
    const lastFocusedItem = this.focusedItem;
    this.setFocusedItem(element);
    if (lastFocusedItem !== this.focusedItem) {
      this.updateFocus();
    }
  }
  setFocusedItem(element) {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      let elem = this.actionsList.children[i];
      if (element === elem) {
        this.focusedItem = i;
        break;
      }
    }
  }
  updateFocus(fromRight) {
    super.updateFocus(fromRight, true);
    if (typeof this.focusedItem !== "undefined") {
      this.scrollableElement.setScrollPosition({
        scrollTop: Math.round(this.menuElement.scrollTop)
      });
    }
  }
  doGetActionViewItem(action, options, parentData) {
    if (action instanceof Separator) {
      return new MenuSeparatorActionViewItem(options.context, action, { icon: true });
    } else if (action instanceof SubmenuAction) {
      const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, Object.assign(Object.assign({}, options), { submenuIds: new Set([...options.submenuIds || [], action.id]) }));
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    } else {
      const menuItemOptions = { enableMnemonics: options.enableMnemonics, useEventAsContext: options.useEventAsContext };
      if (options.getKeyBinding) {
        const keybinding = options.getKeyBinding(action);
        if (keybinding) {
          const keybindingLabel = keybinding.getLabel();
          if (keybindingLabel) {
            menuItemOptions.keybinding = keybindingLabel;
          }
        }
      }
      const menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions);
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    }
  }
};
var BaseMenuActionViewItem = class extends BaseActionViewItem {
  constructor(ctx, action, options = {}) {
    options.isMenu = true;
    super(action, action, options);
    this.options = options;
    this.options.icon = options.icon !== void 0 ? options.icon : false;
    this.options.label = options.label !== void 0 ? options.label : true;
    this.cssClass = "";
    if (this.options.label && options.enableMnemonics) {
      let label = this.getAction().label;
      if (label) {
        let matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();
        }
      }
    }
    this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {
      if (!this.element) {
        return;
      }
      this._register(addDisposableListener(this.element, EventType.MOUSE_UP, (e) => {
        EventHelper.stop(e, true);
        if (isFirefox) {
          const mouseEvent = new StandardMouseEvent(e);
          if (mouseEvent.rightButton) {
            return;
          }
          this.onClick(e);
        } else {
          setTimeout(() => {
            this.onClick(e);
          }, 0);
        }
      }));
      this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e) => {
        EventHelper.stop(e, true);
      }));
    }, 100);
    this._register(this.runOnceToEnableMouseUp);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    this.container = container;
    this.item = append(this.element, $("a.action-menu-item"));
    if (this._action.id === Separator.ID) {
      this.item.setAttribute("role", "presentation");
    } else {
      this.item.setAttribute("role", "menuitem");
      if (this.mnemonic) {
        this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`);
      }
    }
    this.check = append(this.item, $("span.menu-item-check" + menuSelectionIcon.cssSelector));
    this.check.setAttribute("role", "none");
    this.label = append(this.item, $("span.action-label"));
    if (this.options.label && this.options.keybinding) {
      append(this.item, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.runOnceToEnableMouseUp.schedule();
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  }
  blur() {
    super.blur();
    this.applyStyle();
  }
  focus() {
    super.focus();
    if (this.item) {
      this.item.focus();
    }
    this.applyStyle();
  }
  updatePositionInSet(pos, setSize) {
    if (this.item) {
      this.item.setAttribute("aria-posinset", `${pos}`);
      this.item.setAttribute("aria-setsize", `${setSize}`);
    }
  }
  updateLabel() {
    if (!this.label) {
      return;
    }
    if (this.options.label) {
      clearNode(this.label);
      let label = stripIcons(this.getAction().label);
      if (label) {
        const cleanLabel = cleanMnemonic(label);
        if (!this.options.enableMnemonics) {
          label = cleanLabel;
        }
        this.label.setAttribute("aria-label", cleanLabel.replace(/&&/g, "&"));
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          label = escape(label);
          MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;
          let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          while (escMatch && escMatch[1]) {
            escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          }
          const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, "&amp;");
          if (escMatch) {
            this.label.append(ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), " "), $("u", { "aria-hidden": "true" }, escMatch[3]), rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), " "));
          } else {
            this.label.innerText = replaceDoubleEscapes(label).trim();
          }
          if (this.item) {
            this.item.setAttribute("aria-keyshortcuts", (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
          }
        } else {
          this.label.innerText = label.replace(/&&/g, "&").trim();
        }
      }
    }
  }
  updateTooltip() {
    let title = null;
    if (this.getAction().tooltip) {
      title = this.getAction().tooltip;
    } else if (!this.options.label && this.getAction().label && this.options.icon) {
      title = this.getAction().label;
      if (this.options.keybinding) {
        title = localize({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", title, this.options.keybinding);
      }
    }
    if (title && this.item) {
      this.item.title = title;
    }
  }
  updateClass() {
    if (this.cssClass && this.item) {
      this.item.classList.remove(...this.cssClass.split(" "));
    }
    if (this.options.icon && this.label) {
      this.cssClass = this.getAction().class || "";
      this.label.classList.add("icon");
      if (this.cssClass) {
        this.label.classList.add(...this.cssClass.split(" "));
      }
      this.updateEnabled();
    } else if (this.label) {
      this.label.classList.remove("icon");
    }
  }
  updateEnabled() {
    if (this.getAction().enabled) {
      if (this.element) {
        this.element.classList.remove("disabled");
        this.element.removeAttribute("aria-disabled");
      }
      if (this.item) {
        this.item.classList.remove("disabled");
        this.item.removeAttribute("aria-disabled");
        this.item.tabIndex = 0;
      }
    } else {
      if (this.element) {
        this.element.classList.add("disabled");
        this.element.setAttribute("aria-disabled", "true");
      }
      if (this.item) {
        this.item.classList.add("disabled");
        this.item.setAttribute("aria-disabled", "true");
      }
    }
  }
  updateChecked() {
    if (!this.item) {
      return;
    }
    if (this.getAction().checked) {
      this.item.classList.add("checked");
      this.item.setAttribute("role", "menuitemcheckbox");
      this.item.setAttribute("aria-checked", "true");
    } else {
      this.item.classList.remove("checked");
      this.item.setAttribute("role", "menuitem");
      this.item.setAttribute("aria-checked", "false");
    }
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    if (!this.menuStyle) {
      return;
    }
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0;
    const border = isSelected && this.menuStyle.selectionBorderColor ? `thin solid ${this.menuStyle.selectionBorderColor}` : "";
    if (this.item) {
      this.item.style.color = fgColor ? fgColor.toString() : "";
      this.item.style.backgroundColor = bgColor ? bgColor.toString() : "";
    }
    if (this.check) {
      this.check.style.color = fgColor ? fgColor.toString() : "";
    }
    if (this.container) {
      this.container.style.border = border;
    }
  }
  style(style) {
    this.menuStyle = style;
    this.applyStyle();
  }
};
var SubmenuMenuActionViewItem = class extends BaseMenuActionViewItem {
  constructor(action, submenuActions, parentData, submenuOptions) {
    super(action, action, submenuOptions);
    this.submenuActions = submenuActions;
    this.parentData = parentData;
    this.submenuOptions = submenuOptions;
    this.mysubmenu = null;
    this.submenuDisposables = this._register(new DisposableStore());
    this.mouseOver = false;
    this.expandDirection = submenuOptions && submenuOptions.expandDirection !== void 0 ? submenuOptions.expandDirection : Direction.Right;
    this.showScheduler = new RunOnceScheduler(() => {
      if (this.mouseOver) {
        this.cleanupExistingSubmenu(false);
        this.createSubmenu(false);
      }
    }, 250);
    this.hideScheduler = new RunOnceScheduler(() => {
      if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }, 750);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    if (this.item) {
      this.item.classList.add("monaco-submenu-item");
      this.item.tabIndex = 0;
      this.item.setAttribute("aria-haspopup", "true");
      this.updateAriaExpanded("false");
      this.submenuIndicator = append(this.item, $("span.submenu-indicator" + menuSubmenuIcon.cssSelector));
      this.submenuIndicator.setAttribute("aria-hidden", "true");
    }
    this._register(addDisposableListener(this.element, EventType.KEY_UP, (e) => {
      let event = new StandardKeyboardEvent(e);
      if (event.equals(17) || event.equals(3)) {
        EventHelper.stop(e, true);
        this.createSubmenu(true);
      }
    }));
    this._register(addDisposableListener(this.element, EventType.KEY_DOWN, (e) => {
      let event = new StandardKeyboardEvent(e);
      if (getActiveElement() === this.item) {
        if (event.equals(17) || event.equals(3)) {
          EventHelper.stop(e, true);
        }
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, (e) => {
      if (!this.mouseOver) {
        this.mouseOver = true;
        this.showScheduler.schedule();
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, (e) => {
      this.mouseOver = false;
    }));
    this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, (e) => {
      if (this.element && !isAncestor(getActiveElement(), this.element)) {
        this.hideScheduler.schedule();
      }
    }));
    this._register(this.parentData.parent.onScroll(() => {
      this.parentData.parent.focus(false);
      this.cleanupExistingSubmenu(false);
    }));
  }
  updateEnabled() {
  }
  onClick(e) {
    EventHelper.stop(e, true);
    this.cleanupExistingSubmenu(false);
    this.createSubmenu(true);
  }
  cleanupExistingSubmenu(force) {
    if (this.parentData.submenu && (force || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch (_a6) {
      }
      this.parentData.submenu = void 0;
      this.updateAriaExpanded("false");
      if (this.submenuContainer) {
        this.submenuDisposables.clear();
        this.submenuContainer = void 0;
      }
    }
  }
  calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {
    const ret = { top: 0, left: 0 };
    ret.left = layout(windowDimensions.width, submenu.width, { position: expandDirection === Direction.Right ? 0 : 1, offset: entry.left, size: entry.width });
    if (ret.left >= entry.left && ret.left < entry.left + entry.width) {
      if (entry.left + 10 + submenu.width <= windowDimensions.width) {
        ret.left = entry.left + 10;
      }
      entry.top += 10;
      entry.height = 0;
    }
    ret.top = layout(windowDimensions.height, submenu.height, { position: 0, offset: entry.top, size: 0 });
    if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {
      ret.top += entry.height;
    }
    return ret;
  }
  createSubmenu(selectFirstItem = true) {
    if (!this.element) {
      return;
    }
    if (!this.parentData.submenu) {
      this.updateAriaExpanded("true");
      this.submenuContainer = append(this.element, $("div.monaco-submenu"));
      this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
      const computedStyles = getComputedStyle(this.parentData.parent.domNode);
      const paddingTop = parseFloat(computedStyles.paddingTop || "0") || 0;
      this.submenuContainer.style.zIndex = "1";
      this.submenuContainer.style.position = "fixed";
      this.submenuContainer.style.top = "0";
      this.submenuContainer.style.left = "0";
      this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new EmptySubmenuAction()], this.submenuOptions);
      if (this.menuStyle) {
        this.parentData.submenu.style(this.menuStyle);
      }
      const entryBox = this.element.getBoundingClientRect();
      const entryBoxUpdated = {
        top: entryBox.top - paddingTop,
        left: entryBox.left,
        height: entryBox.height + 2 * paddingTop,
        width: entryBox.width
      };
      const viewBox = this.submenuContainer.getBoundingClientRect();
      const { top, left } = this.calculateSubmenuMenuLayout(new Dimension(window.innerWidth, window.innerHeight), Dimension.lift(viewBox), entryBoxUpdated, this.expandDirection);
      this.submenuContainer.style.left = `${left}px`;
      this.submenuContainer.style.top = `${top}px`;
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, (e) => {
        let event = new StandardKeyboardEvent(e);
        if (event.equals(15)) {
          EventHelper.stop(e, true);
          this.parentData.parent.focus();
          this.cleanupExistingSubmenu(true);
        }
      }));
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, (e) => {
        let event = new StandardKeyboardEvent(e);
        if (event.equals(15)) {
          EventHelper.stop(e, true);
        }
      }));
      this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
        this.parentData.parent.focus();
        this.cleanupExistingSubmenu(true);
      }));
      this.parentData.submenu.focus(selectFirstItem);
      this.mysubmenu = this.parentData.submenu;
    } else {
      this.parentData.submenu.focus(false);
    }
  }
  updateAriaExpanded(value) {
    var _a6;
    if (this.item) {
      (_a6 = this.item) === null || _a6 === void 0 ? void 0 : _a6.setAttribute("aria-expanded", value);
    }
  }
  applyStyle() {
    super.applyStyle();
    if (!this.menuStyle) {
      return;
    }
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    if (this.submenuIndicator) {
      this.submenuIndicator.style.color = fgColor ? `${fgColor}` : "";
    }
    if (this.parentData.submenu) {
      this.parentData.submenu.style(this.menuStyle);
    }
  }
  dispose() {
    super.dispose();
    this.hideScheduler.dispose();
    if (this.mysubmenu) {
      this.mysubmenu.dispose();
      this.mysubmenu = null;
    }
    if (this.submenuContainer) {
      this.submenuContainer = void 0;
    }
  }
};
var MenuSeparatorActionViewItem = class extends ActionViewItem {
  style(style) {
    if (this.label) {
      this.label.style.borderBottomColor = style.separatorColor ? `${style.separatorColor}` : "";
    }
  }
};
function cleanMnemonic(label) {
  const regex = MENU_MNEMONIC_REGEX;
  const matches = regex.exec(label);
  if (!matches) {
    return label;
  }
  const mnemonicInText = !matches[1];
  return label.replace(regex, mnemonicInText ? "$2$3" : "").trim();
}
var MENU_WIDGET_CSS = `
.monaco-menu {
	font-size: 13px;

}

${formatRule(menuSelectionIcon)}
${formatRule(menuSubmenuIcon)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 = \u221A\u03C6 */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	opacity: 0.4;
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid #bbb;
	padding-top: 1px;
	margin-left: .8em;
	margin-right: .8em;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	padding: 0.5em 0 0 0;
	margin-bottom: 0.5em;
	width: 100%;
	height: 0px !important;
	margin-left: .8em !important;
	margin-right: .8em !important;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	border: thin solid transparent; /* prevents jumping behaviour on hover or focus */
}


/* High Contrast Theming */
:host-context(.hc-black) .context-view.monaco-menu-container {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .5em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 1.8em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	padding: 0.2em 0 0 0;
	margin-bottom: 0.2em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}

/* Arrows */
.monaco-scrollable-element > .scrollbar > .scra {
	cursor: pointer;
	font-size: 11px !important;
}

.monaco-scrollable-element > .visible {
	opacity: 1;

	/* Background rule added for IE9 - to allow clicks on dom node */
	background:rgba(0,0,0,0);

	transition: opacity 100ms linear;
}
.monaco-scrollable-element > .invisible {
	opacity: 0;
	pointer-events: none;
}
.monaco-scrollable-element > .invisible.fade {
	transition: opacity 800ms linear;
}

/* Scrollable Content Inset Shadow */
.monaco-scrollable-element > .shadow {
	position: absolute;
	display: none;
}
.monaco-scrollable-element > .shadow.top {
	display: block;
	top: 0;
	left: 3px;
	height: 3px;
	width: 100%;
	box-shadow: #DDD 0 6px 6px -6px inset;
}
.monaco-scrollable-element > .shadow.left {
	display: block;
	top: 3px;
	left: 0;
	height: 100%;
	width: 3px;
	box-shadow: #DDD 6px 0 6px -6px inset;
}
.monaco-scrollable-element > .shadow.top-left-corner {
	display: block;
	top: 0;
	left: 0;
	height: 3px;
	width: 3px;
}
.monaco-scrollable-element > .shadow.top.left {
	box-shadow: #DDD 6px 6px 6px -6px inset;
}

/* ---------- Default Style ---------- */

:host-context(.vs) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(100, 100, 100, .4);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(121, 121, 121, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(111, 195, 223, .6);
}

.monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(100, 100, 100, .7);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(111, 195, 223, .8);
}

.monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(0, 0, 0, .6);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(191, 191, 191, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(111, 195, 223, 1);
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.left {
	box-shadow: #000 6px 0 6px -6px inset;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top.left {
	box-shadow: #000 6px 6px 6px -6px inset;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.left {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top.left {
	box-shadow: none;
}
`;

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
var ContextMenuHandler = class {
  constructor(contextViewService, telemetryService, notificationService, keybindingService, themeService) {
    this.contextViewService = contextViewService;
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.keybindingService = keybindingService;
    this.themeService = themeService;
    this.focusToReturn = null;
    this.block = null;
    this.options = { blockMouse: true };
  }
  configure(options) {
    this.options = options;
  }
  showContextMenu(delegate) {
    const actions = delegate.getActions();
    if (!actions.length) {
      return;
    }
    this.focusToReturn = document.activeElement;
    let menu;
    let shadowRootElement = isHTMLElement(delegate.domForShadowRoot) ? delegate.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => delegate.getAnchor(),
      canRelayout: false,
      anchorAlignment: delegate.anchorAlignment,
      anchorAxisAlignment: delegate.anchorAxisAlignment,
      render: (container) => {
        let className = delegate.getMenuClassName ? delegate.getMenuClassName() : "";
        if (className) {
          container.className += " " + className;
        }
        if (this.options.blockMouse) {
          this.block = container.appendChild($(".context-view-block"));
          this.block.style.position = "fixed";
          this.block.style.cursor = "initial";
          this.block.style.left = "0";
          this.block.style.top = "0";
          this.block.style.width = "100%";
          this.block.style.height = "100%";
          this.block.style.zIndex = "-1";
          addDisposableListener(this.block, EventType.MOUSE_DOWN, (e) => e.stopPropagation());
        }
        const menuDisposables = new DisposableStore();
        const actionRunner = delegate.actionRunner || new ActionRunner();
        actionRunner.onBeforeRun(this.onActionRun, this, menuDisposables);
        actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);
        menu = new Menu(container, actions, {
          actionViewItemProvider: delegate.getActionViewItem,
          context: delegate.getActionsContext ? delegate.getActionsContext() : null,
          actionRunner,
          getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : (action) => this.keybindingService.lookupKeybinding(action.id)
        });
        menuDisposables.add(attachMenuStyler(menu, this.themeService));
        menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        menuDisposables.add(addDisposableListener(window, EventType.BLUR, () => this.contextViewService.hideContextView(true)));
        menuDisposables.add(addDisposableListener(window, EventType.MOUSE_DOWN, (e) => {
          if (e.defaultPrevented) {
            return;
          }
          let event = new StandardMouseEvent(e);
          let element = event.target;
          if (event.rightButton) {
            return;
          }
          while (element) {
            if (element === container) {
              return;
            }
            element = element.parentElement;
          }
          this.contextViewService.hideContextView(true);
        }));
        return combinedDisposable(menuDisposables, menu);
      },
      focus: () => {
        if (menu) {
          menu.focus(!!delegate.autoSelectFirstItem);
        }
      },
      onHide: (didCancel) => {
        if (delegate.onHide) {
          delegate.onHide(!!didCancel);
        }
        if (this.block) {
          this.block.remove();
          this.block = null;
        }
        if (this.focusToReturn) {
          this.focusToReturn.focus();
        }
      }
    }, shadowRootElement, !!shadowRootElement);
  }
  onActionRun(e) {
    this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" });
    this.contextViewService.hideContextView(false);
    if (this.focusToReturn) {
      this.focusToReturn.focus();
    }
  }
  onDidActionRun(e) {
    if (e.error && !isPromiseCanceledError(e.error)) {
      this.notificationService.error(e.error);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuService = class ContextMenuService2 extends Disposable {
  constructor(telemetryService, notificationService, contextViewService, keybindingService, themeService) {
    super();
    this.contextMenuHandler = new ContextMenuHandler(contextViewService, telemetryService, notificationService, keybindingService, themeService);
  }
  configure(options) {
    this.contextMenuHandler.configure(options);
  }
  showContextMenu(delegate) {
    this.contextMenuHandler.showContextMenu(delegate);
    ModifierKeyEmitter.getInstance().resetKeyStatus();
  }
};
ContextMenuService = __decorate10([
  __param10(0, ITelemetryService),
  __param10(1, INotificationService),
  __param10(2, IContextViewService),
  __param10(3, IKeybindingService),
  __param10(4, IThemeService)
], ContextMenuService);

// node_modules/monaco-editor/esm/vs/platform/layout/browser/layoutService.js
var ILayoutService = createDecorator("layoutService");

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextViewService.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextViewService = class ContextViewService2 extends Disposable {
  constructor(layoutService) {
    super();
    this.layoutService = layoutService;
    this.currentViewDisposable = Disposable.None;
    this.container = layoutService.container;
    this.contextView = this._register(new ContextView(this.container, 1));
    this.layout();
    this._register(layoutService.onDidLayout(() => this.layout()));
  }
  setContainer(container, domPosition) {
    this.contextView.setContainer(container, domPosition || 1);
  }
  showContextView(delegate, container, shadowRoot) {
    if (container) {
      if (container !== this.container) {
        this.container = container;
        this.setContainer(container, shadowRoot ? 3 : 2);
      }
    } else {
      if (this.container !== this.layoutService.container) {
        this.container = this.layoutService.container;
        this.setContainer(this.container, 1);
      }
    }
    this.contextView.show(delegate);
    const disposable = toDisposable(() => {
      if (this.currentViewDisposable === disposable) {
        this.hideContextView();
      }
    });
    this.currentViewDisposable = disposable;
    return disposable;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(data) {
    this.contextView.hide(data);
  }
};
ContextViewService = __decorate11([
  __param11(0, ILayoutService)
], ContextViewService);

// node_modules/monaco-editor/esm/vs/platform/dialogs/common/dialogs.js
var IDialogService = createDecorator("dialogService");

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js
var Node = class {
  constructor(data) {
    this.incoming = new Map();
    this.outgoing = new Map();
    this.data = data;
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = new Map();
  }
  roots() {
    const ret = [];
    for (let node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(this._hashFn(to), toNode);
    toNode.incoming.set(this._hashFn(from), fromNode);
  }
  removeNode(data) {
    const key = this._hashFn(data);
    this._nodes.delete(key);
    for (let node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data) {
    const key = this._hashFn(data);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node(data);
      this._nodes.set(key, node);
    }
    return node;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    let data = [];
    for (let [key, value] of this._nodes) {
      data.push(`${key}, (incoming)[${[...value.incoming.keys()].join(", ")}], (outgoing)[${[...value.outgoing.keys()].join(",")}]`);
    }
    return data.join("\n");
  }
  findCycleSlow() {
    for (let [id, node] of this._nodes) {
      const seen = new Set([id]);
      const res = this._findCycle(node, seen);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen) {
    for (let [id, outgoing] of node.outgoing) {
      if (seen.has(id)) {
        return [...seen, id].join(" -> ");
      }
      seen.add(id);
      const value = this._findCycle(outgoing, seen);
      if (value) {
        return value;
      }
      seen.delete(id);
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
var _enableTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    var _a6;
    super("cyclic dependency between services");
    this.message = (_a6 = graph.findCycleSlow()) !== null && _a6 !== void 0 ? _a6 : `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
};
var InstantiationService = class {
  constructor(services = new ServiceCollection(), strict = false, parent) {
    this._activeInstantiations = new Set();
    this._services = services;
    this._strict = strict;
    this._parent = parent;
    this._services.set(IInstantiationService, this);
  }
  createChild(services) {
    return new InstantiationService(services, this._strict, this);
  }
  invokeFunction(fn, ...args) {
    let _trace = Trace.traceInvocation(fn);
    let _done = false;
    try {
      const accessor = {
        get: (id, isOptional) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id, _trace);
          if (!result && isOptional !== optional) {
            throw new Error(`[invokeFunction] unknown service '${id}'`);
          }
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    let serviceArgs = [];
    for (const dependency of serviceDependencies) {
      let service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service && this._strict && !dependency.optional) {
        throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);
      }
      serviceArgs.push(service);
    }
    let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      let delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return new ctor(...[...args, ...serviceArgs]);
  }
  _setServiceInstance(id, instance) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      this._services.set(id, instance);
    } else if (this._parent) {
      this._parent._setServiceInstance(id, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id) {
    let instanceOrDesc = this._services.get(id);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id, _trace) {
    let thing = this._getServiceInstanceOrDescriptor(id);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));
    } else {
      _trace.branch(id, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id, desc, _trace) {
    if (this._activeInstantiations.has(id)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);
    }
    this._activeInstantiations.add(id);
    try {
      return this._createAndCacheServiceInstance(id, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id);
    }
  }
  _createAndCacheServiceInstance(id, desc, _trace) {
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{ id, desc, _trace }];
    while (stack.length) {
      const item = stack.pop();
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {
        let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc && !dependency.optional) {
          console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);
        }
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
          this._setServiceInstance(data.id, instance);
        }
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id);
  }
  _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {
    if (!_supportsDelayedInstantiation) {
      return this._createInstance(ctor, args, _trace);
    } else {
      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));
      return new Proxy(Object.create(null), {
        get(target, key) {
          if (key in target) {
            return target[key];
          }
          let obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        }
      });
    }
  }
};
var Trace = class {
  constructor(type, name) {
    this.type = type;
    this.name = name;
    this._start = Date.now();
    this._dep = [];
  }
  static traceInvocation(ctor) {
    return !_enableTracing ? Trace._None : new Trace(1, ctor.name || ctor.toString().substring(0, 42).replace(/\n/g, ""));
  }
  static traceCreation(ctor) {
    return !_enableTracing ? Trace._None : new Trace(0, ctor.name);
  }
  branch(id, first) {
    let child = new Trace(2, id.toString());
    this._dep.push([id, first, child]);
    return child;
  }
  stop() {
    let dur = Date.now() - this._start;
    Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      let res = [];
      let prefix = new Array(n + 1).join("	");
      for (const [id, first, child] of trace._dep) {
        if (first && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id}`);
          let nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id}`);
        }
      }
      return res.join("\n");
    }
    let lines = [
      `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      console.log(lines.join("\n"));
    }
  }
};
Trace._None = new class extends Trace {
  constructor() {
    super(-1, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
Trace._totals = 0;

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listPaging.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.css";
var PagedRenderer = class {
  constructor(renderer, modelProvider) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
  }
  get templateId() {
    return this.renderer.templateId;
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return { data, disposable: Disposable.None };
  }
  renderElement(index, _, data, height) {
    if (data.disposable) {
      data.disposable.dispose();
    }
    if (!data.data) {
      return;
    }
    const model = this.modelProvider();
    if (model.isResolved(index)) {
      return this.renderer.renderElement(model.get(index), index, data.data, height);
    }
    const cts = new CancellationTokenSource();
    const promise = model.resolve(index, cts.token);
    data.disposable = { dispose: () => cts.cancel() };
    this.renderer.renderPlaceholder(index, data.data);
    promise.then((entry) => this.renderer.renderElement(entry, index, data.data, height));
  }
  disposeTemplate(data) {
    if (data.disposable) {
      data.disposable.dispose();
      data.disposable = void 0;
    }
    if (data.data) {
      this.renderer.disposeTemplate(data.data);
      data.data = void 0;
    }
  }
};
var PagedAccessibilityProvider = class {
  constructor(modelProvider, accessibilityProvider) {
    this.modelProvider = modelProvider;
    this.accessibilityProvider = accessibilityProvider;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(index) {
    const model = this.modelProvider();
    if (!model.isResolved(index)) {
      return null;
    }
    return this.accessibilityProvider.getAriaLabel(model.get(index));
  }
};
function fromPagedListOptions(modelProvider, options) {
  return Object.assign(Object.assign({}, options), { accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider) });
}
var PagedList = class {
  constructor(user, container, virtualDelegate, renderers, options = {}) {
    const modelProvider = () => this.model;
    const pagedRenderers = renderers.map((r) => new PagedRenderer(r, modelProvider));
    this.list = new List(user, container, virtualDelegate, pagedRenderers, fromPagedListOptions(modelProvider, options));
  }
  updateOptions(options) {
    this.list.updateOptions(options);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent }));
  }
  get onPointer() {
    return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent }));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map((e) => this._model.get(e)), indexes, browserEvent }));
  }
  get model() {
    return this._model;
  }
  set model(model) {
    this._model = model;
    this.list.splice(0, this.list.length, range(model.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((i) => this.model.get(i));
  }
  style(styles) {
    this.list.style(styles);
  }
  dispose() {
    this.list.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js
var IsWindowsContext = new RawContextKey("isWindows", isWindows, localize("isWindows", "Whether the operating system is Windows"));
var InputFocusedContextKey = "inputFocus";

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/media/tree.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/tree.js
var TreeMouseEventTarget;
(function(TreeMouseEventTarget2) {
  TreeMouseEventTarget2[TreeMouseEventTarget2["Unknown"] = 0] = "Unknown";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Twistie"] = 1] = "Twistie";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Element"] = 2] = "Element";
})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));
var TreeError = class extends Error {
  constructor(user, message) {
    super(`TreeError [${user}] ${message}`);
  }
};
var WeakMapper = class {
  constructor(fn) {
    this.fn = fn;
    this._map = new WeakMap();
  }
  map(key) {
    let result = this._map.get(key);
    if (!result) {
      result = this.fn(key);
      this._map.set(key, result);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js
function isFilterResult(obj) {
  return typeof obj === "object" && "visibility" in obj && "data" in obj;
}
function getVisibleState(visibility) {
  switch (visibility) {
    case true:
      return 1;
    case false:
      return 0;
    default:
      return visibility;
  }
}
function isCollapsibleStateUpdate(update) {
  return typeof update.collapsible === "boolean";
}
var IndexTreeModel = class {
  constructor(user, list, rootElement, options = {}) {
    this.user = user;
    this.list = list;
    this.rootRef = [];
    this.eventBufferer = new EventBufferer();
    this._onDidChangeCollapseState = new Emitter();
    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);
    this._onDidChangeRenderNodeCount = new Emitter();
    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);
    this._onDidSplice = new Emitter();
    this.onDidSplice = this._onDidSplice.event;
    this.collapseByDefault = typeof options.collapseByDefault === "undefined" ? false : options.collapseByDefault;
    this.filter = options.filter;
    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? false : options.autoExpandSingleChildren;
    this.root = {
      parent: void 0,
      element: rootElement,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: false,
      collapsed: false,
      renderNodeCount: 0,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
  }
  splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    if (options.diffIdentityProvider) {
      this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);
    } else {
      this.spliceSimple(location, deleteCount, toInsert, options);
    }
  }
  spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {
    var _a6;
    if (toInsertIterable === void 0) {
      toInsertIterable = Iterable.empty();
    }
    if (recurseLevels === void 0) {
      recurseLevels = (_a6 = options.diffDepth) !== null && _a6 !== void 0 ? _a6 : 0;
    }
    const { parentNode } = this.getParentNodeWithListIndex(location);
    const toInsert = [...toInsertIterable];
    const index = location[location.length - 1];
    const diff = new LcsDiff({ getElements: () => parentNode.children.map((e) => identity.getId(e.element).toString()) }, {
      getElements: () => [
        ...parentNode.children.slice(0, index),
        ...toInsert,
        ...parentNode.children.slice(index + deleteCount)
      ].map((e) => identity.getId(e.element).toString())
    }).ComputeDiff(false);
    if (diff.quitEarly) {
      return this.spliceSimple(location, deleteCount, toInsert, options);
    }
    const locationPrefix = location.slice(0, -1);
    const recurseSplice = (fromOriginal, fromModified, count) => {
      if (recurseLevels > 0) {
        for (let i = 0; i < count; i++) {
          fromOriginal--;
          fromModified--;
          this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);
        }
      }
    };
    let lastStartO = Math.min(parentNode.children.length, index + deleteCount);
    let lastStartM = toInsert.length;
    for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {
      recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));
      lastStartO = change.originalStart;
      lastStartM = change.modifiedStart - index;
      this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);
    }
    recurseSplice(lastStartO, lastStartM, lastStartO);
  }
  spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode }) {
    const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);
    const treeListElementsToInsert = [];
    const nodesToInsertIterator = Iterable.map(toInsert, (el) => this.createTreeNode(el, parentNode, parentNode.visible ? 1 : 0, revealed, treeListElementsToInsert, onDidCreateNode));
    const lastIndex = location[location.length - 1];
    const lastHadChildren = parentNode.children.length > 0;
    let visibleChildStartIndex = 0;
    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {
      const child = parentNode.children[i];
      if (child.visible) {
        visibleChildStartIndex = child.visibleChildIndex;
        break;
      }
    }
    const nodesToInsert = [];
    let insertedVisibleChildrenCount = 0;
    let renderNodeCount = 0;
    for (const child of nodesToInsertIterator) {
      nodesToInsert.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;
      }
    }
    const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);
    let deletedVisibleChildrenCount = 0;
    for (const child of deletedNodes) {
      if (child.visible) {
        deletedVisibleChildrenCount++;
      }
    }
    if (deletedVisibleChildrenCount !== 0) {
      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {
        const child = parentNode.children[i];
        if (child.visible) {
          child.visibleChildIndex -= deletedVisibleChildrenCount;
        }
      }
    }
    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;
    if (revealed && visible) {
      const visibleDeleteCount = deletedNodes.reduce((r, node2) => r + (node2.visible ? node2.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);
      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);
    }
    if (deletedNodes.length > 0 && onDidDeleteNode) {
      const visit = (node2) => {
        onDidDeleteNode(node2);
        node2.children.forEach(visit);
      };
      deletedNodes.forEach(visit);
    }
    const currentlyHasChildren = parentNode.children.length > 0;
    if (lastHadChildren !== currentlyHasChildren) {
      this.setCollapsible(location.slice(0, -1), currentlyHasChildren);
    }
    this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });
    let node = parentNode;
    while (node) {
      if (node.visibility === 2) {
        this.refilter();
        break;
      }
      node = node.parent;
    }
  }
  rerender(location) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);
    if (node.visible && revealed) {
      this.list.splice(listIndex, 1, [node]);
    }
  }
  has(location) {
    return this.hasTreeNode(location);
  }
  getListIndex(location) {
    const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);
    return visible && revealed ? listIndex : -1;
  }
  getListRenderCount(location) {
    return this.getTreeNode(location).renderNodeCount;
  }
  isCollapsible(location) {
    return this.getTreeNode(location).collapsible;
  }
  setCollapsible(location, collapsible) {
    const node = this.getTreeNode(location);
    if (typeof collapsible === "undefined") {
      collapsible = !node.collapsible;
    }
    const update = { collapsible };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  isCollapsed(location) {
    return this.getTreeNode(location).collapsed;
  }
  setCollapsed(location, collapsed, recursive) {
    const node = this.getTreeNode(location);
    if (typeof collapsed === "undefined") {
      collapsed = !node.collapsed;
    }
    const update = { collapsed, recursive: recursive || false };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  _setCollapseState(location, update) {
    const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);
    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);
    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {
      let onlyVisibleChildIndex = -1;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.visible) {
          if (onlyVisibleChildIndex > -1) {
            onlyVisibleChildIndex = -1;
            break;
          } else {
            onlyVisibleChildIndex = i;
          }
        }
      }
      if (onlyVisibleChildIndex > -1) {
        this._setCollapseState([...location, onlyVisibleChildIndex], update);
      }
    }
    return result;
  }
  _setListNodeCollapseState(node, listIndex, revealed, update) {
    const result = this._setNodeCollapseState(node, update, false);
    if (!revealed || !node.visible || !result) {
      return result;
    }
    const previousRenderNodeCount = node.renderNodeCount;
    const toInsert = this.updateNodeAfterCollapseChange(node);
    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);
    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));
    return result;
  }
  _setNodeCollapseState(node, update, deep) {
    let result;
    if (node === this.root) {
      result = false;
    } else {
      if (isCollapsibleStateUpdate(update)) {
        result = node.collapsible !== update.collapsible;
        node.collapsible = update.collapsible;
      } else if (!node.collapsible) {
        result = false;
      } else {
        result = node.collapsed !== update.collapsed;
        node.collapsed = update.collapsed;
      }
      if (result) {
        this._onDidChangeCollapseState.fire({ node, deep });
      }
    }
    if (!isCollapsibleStateUpdate(update) && update.recursive) {
      for (const child of node.children) {
        result = this._setNodeCollapseState(child, update, true) || result;
      }
    }
    return result;
  }
  expandTo(location) {
    this.eventBufferer.bufferEvents(() => {
      let node = this.getTreeNode(location);
      while (node.parent) {
        node = node.parent;
        location = location.slice(0, location.length - 1);
        if (node.collapsed) {
          this._setCollapseState(location, { collapsed: false, recursive: false });
        }
      }
    });
  }
  refilter() {
    const previousRenderNodeCount = this.root.renderNodeCount;
    const toInsert = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, previousRenderNodeCount, toInsert);
  }
  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {
    const node = {
      parent,
      element: treeElement.element,
      children: [],
      depth: parent.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : typeof treeElement.collapsed !== "undefined",
      collapsed: typeof treeElement.collapsed === "undefined" ? this.collapseByDefault : treeElement.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
    const visibility = this._filterNode(node, parentVisibility);
    node.visibility = visibility;
    if (revealed) {
      treeListElements.push(node);
    }
    const childElements = treeElement.children || Iterable.empty();
    const childRevealed = revealed && visibility !== 0 && !node.collapsed;
    const childNodes = Iterable.map(childElements, (el) => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));
    let visibleChildrenCount = 0;
    let renderNodeCount = 1;
    for (const child of childNodes) {
      node.children.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildrenCount++;
      }
    }
    node.collapsible = node.collapsible || node.children.length > 0;
    node.visibleChildrenCount = visibleChildrenCount;
    node.visible = visibility === 2 ? visibleChildrenCount > 0 : visibility === 1;
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        treeListElements.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount = renderNodeCount;
    }
    if (onDidCreateNode) {
      onDidCreateNode(node);
    }
    return node;
  }
  updateNodeAfterCollapseChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterCollapseChange(node, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterCollapseChange(node, result) {
    if (node.visible === false) {
      return 0;
    }
    result.push(node);
    node.renderNodeCount = 1;
    if (!node.collapsed) {
      for (const child of node.children) {
        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);
      }
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.renderNodeCount;
  }
  updateNodeAfterFilterChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterFilterChange(node, node.visible ? 1 : 0, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {
    let visibility;
    if (node !== this.root) {
      visibility = this._filterNode(node, parentVisibility);
      if (visibility === 0) {
        node.visible = false;
        node.renderNodeCount = 0;
        return false;
      }
      if (revealed) {
        result.push(node);
      }
    }
    const resultStartLength = result.length;
    node.renderNodeCount = node === this.root ? 0 : 1;
    let hasVisibleDescendants = false;
    if (!node.collapsed || visibility !== 0) {
      let visibleChildIndex = 0;
      for (const child of node.children) {
        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;
        if (child.visible) {
          child.visibleChildIndex = visibleChildIndex++;
        }
      }
      node.visibleChildrenCount = visibleChildIndex;
    } else {
      node.visibleChildrenCount = 0;
    }
    if (node !== this.root) {
      node.visible = visibility === 2 ? hasVisibleDescendants : visibility === 1;
    }
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        result.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount += result.length - resultStartLength;
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.visible;
  }
  _updateAncestorsRenderNodeCount(node, diff) {
    if (diff === 0) {
      return;
    }
    while (node) {
      node.renderNodeCount += diff;
      this._onDidChangeRenderNodeCount.fire(node);
      node = node.parent;
    }
  }
  _filterNode(node, parentVisibility) {
    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1;
    if (typeof result === "boolean") {
      node.filterData = void 0;
      return result ? 1 : 0;
    } else if (isFilterResult(result)) {
      node.filterData = result.data;
      return getVisibleState(result.visibility);
    } else {
      node.filterData = void 0;
      return getVisibleState(result);
    }
  }
  hasTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return true;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      return false;
    }
    return this.hasTreeNode(rest, node.children[index]);
  }
  getTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return node;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    return this.getTreeNode(rest, node.children[index]);
  }
  getTreeNodeWithListIndex(location) {
    if (location.length === 0) {
      return { node: this.root, listIndex: -1, revealed: true, visible: false };
    }
    const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);
    const index = location[location.length - 1];
    if (index < 0 || index > parentNode.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const node = parentNode.children[index];
    return { node, listIndex, revealed, visible: visible && node.visible };
  }
  getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    for (let i = 0; i < index; i++) {
      listIndex += node.children[i].renderNodeCount;
    }
    revealed = revealed && !node.collapsed;
    visible = visible && node.visible;
    if (rest.length === 0) {
      return { parentNode: node, listIndex, revealed, visible };
    }
    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);
  }
  getNode(location = []) {
    return this.getTreeNode(location);
  }
  getNodeLocation(node) {
    const location = [];
    let indexTreeNode = node;
    while (indexTreeNode.parent) {
      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));
      indexTreeNode = indexTreeNode.parent;
    }
    return location.reverse();
  }
  getParentNodeLocation(location) {
    if (location.length === 0) {
      return void 0;
    } else if (location.length === 1) {
      return [];
    } else {
      return tail2(location)[0];
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/treeIcons.js
var treeItemExpandedIcon = registerCodicon("tree-item-expanded", Codicon.chevronDown);
var treeFilterOnTypeOnIcon = registerCodicon("tree-filter-on-type-on", Codicon.listFilter);
var treeFilterOnTypeOffIcon = registerCodicon("tree-filter-on-type-off", Codicon.listSelection);
var treeFilterClearIcon = registerCodicon("tree-filter-clear", Codicon.close);
var treeItemLoadingIcon = registerCodicon("tree-item-loading", Codicon.loading);

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js
var TreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new TreeElementsDragAndDropData(data);
  }
  return data;
}
var TreeNodeListDragAndDrop = class {
  constructor(modelProvider, dnd) {
    this.modelProvider = modelProvider;
    this.dnd = dnd;
    this.autoExpandDisposable = Disposable.None;
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);
    }
  }
  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
    const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;
    if (didChangeAutoExpandNode) {
      this.autoExpandDisposable.dispose();
      this.autoExpandNode = targetNode;
    }
    if (typeof targetNode === "undefined") {
      return result;
    }
    if (didChangeAutoExpandNode && typeof result !== "boolean" && result.autoExpand) {
      this.autoExpandDisposable = disposableTimeout(() => {
        const model2 = this.modelProvider();
        const ref2 = model2.getNodeLocation(targetNode);
        if (model2.isCollapsed(ref2)) {
          model2.setCollapsed(ref2, false);
        }
        this.autoExpandNode = void 0;
      }, 500);
    }
    if (typeof result === "boolean" || !result.accept || typeof result.bubble === "undefined" || result.feedback) {
      if (!raw) {
        const accept = typeof result === "boolean" ? result : result.accept;
        const effect = typeof result === "boolean" ? void 0 : result.effect;
        return { accept, effect, feedback: [targetIndex] };
      }
      return result;
    }
    if (result.bubble === 1) {
      const model2 = this.modelProvider();
      const ref2 = model2.getNodeLocation(targetNode);
      const parentRef = model2.getParentNodeLocation(ref2);
      const parentNode = model2.getNode(parentRef);
      const parentIndex = parentRef && model2.getListIndex(parentRef);
      return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);
    }
    const model = this.modelProvider();
    const ref = model.getNodeLocation(targetNode);
    const start = model.getListIndex(ref);
    const length = model.getListRenderCount(ref);
    return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });
  }
  drop(data, targetNode, targetIndex, originalEvent) {
    this.autoExpandDisposable.dispose();
    this.autoExpandNode = void 0;
    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(originalEvent);
    }
  }
};
function asListOptions(modelProvider, options) {
  return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {
    getId(el) {
      return options.identityProvider.getId(el.element);
    }
  }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    },
    isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    }
  }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {
    getSetSize(node) {
      const model = modelProvider();
      const ref = model.getNodeLocation(node);
      const parentRef = model.getParentNodeLocation(ref);
      const parentNode = model.getNode(parentRef);
      return parentNode.visibleChildrenCount;
    },
    getPosInSet(node) {
      return node.visibleChildIndex + 1;
    },
    isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {
      return options.accessibilityProvider.isChecked(node.element);
    } : void 0,
    getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {
      return options.accessibilityProvider.getRole(node.element);
    } : () => "treeitem",
    getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {
      return node.depth;
    },
    getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && ((node) => {
      return options.accessibilityProvider.getActiveDescendantId(node.element);
    })
  }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {
    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
  } }), enableKeyboardNavigation: options.simpleKeyboardNavigation });
}
var ComposedTreeDelegate = class {
  constructor(delegate) {
    this.delegate = delegate;
  }
  getHeight(element) {
    return this.delegate.getHeight(element.element);
  }
  getTemplateId(element) {
    return this.delegate.getTemplateId(element.element);
  }
  hasDynamicHeight(element) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
  }
  setDynamicHeight(element, height) {
    if (this.delegate.setDynamicHeight) {
      this.delegate.setDynamicHeight(element.element, height);
    }
  }
};
var RenderIndentGuides;
(function(RenderIndentGuides2) {
  RenderIndentGuides2["None"] = "none";
  RenderIndentGuides2["OnHover"] = "onHover";
  RenderIndentGuides2["Always"] = "always";
})(RenderIndentGuides || (RenderIndentGuides = {}));
var EventCollection = class {
  constructor(onDidChange, _elements = []) {
    this._elements = _elements;
    this.onDidChange = Event.forEach(onDidChange, (elements) => this._elements = elements);
  }
  get elements() {
    return this._elements;
  }
};
var TreeRenderer = class {
  constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
    this.activeNodes = activeNodes;
    this.renderedElements = new Map();
    this.renderedNodes = new Map();
    this.indent = TreeRenderer.DefaultIndent;
    this.hideTwistiesOfChildlessElements = false;
    this.shouldRenderIndentGuides = false;
    this.renderedIndentGuides = new SetMap();
    this.activeIndentNodes = new Set();
    this.indentGuidesDisposable = Disposable.None;
    this.disposables = new DisposableStore();
    this.templateId = renderer.templateId;
    this.updateOptions(options);
    Event.map(onDidChangeCollapseState, (e) => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
    if (renderer.onDidChangeTwistieState) {
      renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);
    }
  }
  updateOptions(options = {}) {
    if (typeof options.indent !== "undefined") {
      this.indent = clamp(options.indent, 0, 40);
    }
    if (typeof options.renderIndentGuides !== "undefined") {
      const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;
      if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = shouldRenderIndentGuides;
        this.indentGuidesDisposable.dispose();
        if (shouldRenderIndentGuides) {
          const disposables = new DisposableStore();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);
          this.indentGuidesDisposable = disposables;
          this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    if (typeof options.hideTwistiesOfChildlessElements !== "undefined") {
      this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;
    }
  }
  renderTemplate(container) {
    const el = append(container, $(".monaco-tl-row"));
    const indent = append(el, $(".monaco-tl-indent"));
    const twistie = append(el, $(".monaco-tl-twistie"));
    const contents = append(el, $(".monaco-tl-contents"));
    const templateData = this.renderer.renderTemplate(contents);
    return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };
  }
  renderElement(node, index, templateData, height) {
    if (typeof height === "number") {
      this.renderedNodes.set(node, { templateData, height });
      this.renderedElements.set(node.element, node);
    }
    const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;
    templateData.twistie.style.paddingLeft = `${indent}px`;
    templateData.indent.style.width = `${indent + this.indent - 16}px`;
    this.renderTwistie(node, templateData);
    if (typeof height === "number") {
      this.renderIndentGuides(node, templateData);
    }
    this.renderer.renderElement(node, index, templateData.templateData, height);
  }
  disposeElement(node, index, templateData, height) {
    templateData.indentGuidesDisposable.dispose();
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(node, index, templateData.templateData, height);
    }
    if (typeof height === "number") {
      this.renderedNodes.delete(node);
      this.renderedElements.delete(node.element);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  onDidChangeTwistieState(element) {
    const node = this.renderedElements.get(element);
    if (!node) {
      return;
    }
    this.onDidChangeNodeTwistieState(node);
  }
  onDidChangeNodeTwistieState(node) {
    const data = this.renderedNodes.get(node);
    if (!data) {
      return;
    }
    this.renderTwistie(node, data.templateData);
    this._onDidChangeActiveNodes(this.activeNodes.elements);
    this.renderIndentGuides(node, data.templateData);
  }
  renderTwistie(node, templateData) {
    templateData.twistie.classList.remove(...treeItemExpandedIcon.classNamesArray);
    let twistieRendered = false;
    if (this.renderer.renderTwistie) {
      twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);
    }
    if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {
      if (!twistieRendered) {
        templateData.twistie.classList.add(...treeItemExpandedIcon.classNamesArray);
      }
      templateData.twistie.classList.add("collapsible");
      templateData.twistie.classList.toggle("collapsed", node.collapsed);
    } else {
      templateData.twistie.classList.remove("collapsible", "collapsed");
    }
    if (node.collapsible) {
      templateData.container.setAttribute("aria-expanded", String(!node.collapsed));
    } else {
      templateData.container.removeAttribute("aria-expanded");
    }
  }
  renderIndentGuides(target, templateData) {
    clearNode(templateData.indent);
    templateData.indentGuidesDisposable.dispose();
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const disposableStore = new DisposableStore();
    const model = this.modelProvider();
    let node = target;
    while (true) {
      const ref = model.getNodeLocation(node);
      const parentRef = model.getParentNodeLocation(ref);
      if (!parentRef) {
        break;
      }
      const parent = model.getNode(parentRef);
      const guide = $(".indent-guide", { style: `width: ${this.indent}px` });
      if (this.activeIndentNodes.has(parent)) {
        guide.classList.add("active");
      }
      if (templateData.indent.childElementCount === 0) {
        templateData.indent.appendChild(guide);
      } else {
        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);
      }
      this.renderedIndentGuides.add(parent, guide);
      disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));
      node = parent;
    }
    templateData.indentGuidesDisposable = disposableStore;
  }
  _onDidChangeActiveNodes(nodes) {
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const set = new Set();
    const model = this.modelProvider();
    nodes.forEach((node) => {
      const ref = model.getNodeLocation(node);
      try {
        const parentRef = model.getParentNodeLocation(ref);
        if (node.collapsible && node.children.length > 0 && !node.collapsed) {
          set.add(node);
        } else if (parentRef) {
          set.add(model.getNode(parentRef));
        }
      } catch (_a6) {
      }
    });
    this.activeIndentNodes.forEach((node) => {
      if (!set.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => line.classList.remove("active"));
      }
    });
    set.forEach((node) => {
      if (!this.activeIndentNodes.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => line.classList.add("active"));
      }
    });
    this.activeIndentNodes = set;
  }
  dispose() {
    this.renderedNodes.clear();
    this.renderedElements.clear();
    this.indentGuidesDisposable.dispose();
    dispose(this.disposables);
  }
};
TreeRenderer.DefaultIndent = 8;
var TypeFilter = class {
  constructor(tree, keyboardNavigationLabelProvider, _filter) {
    this.tree = tree;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this._filter = _filter;
    this._totalCount = 0;
    this._matchCount = 0;
    this._pattern = "";
    this._lowercasePattern = "";
    this.disposables = new DisposableStore();
    tree.onWillRefilter(this.reset, this, this.disposables);
  }
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  set pattern(pattern) {
    this._pattern = pattern;
    this._lowercasePattern = pattern.toLowerCase();
  }
  filter(element, parentVisibility) {
    if (this._filter) {
      const result = this._filter.filter(element, parentVisibility);
      if (this.tree.options.simpleKeyboardNavigation) {
        return result;
      }
      let visibility;
      if (typeof result === "boolean") {
        visibility = result ? 1 : 0;
      } else if (isFilterResult(result)) {
        visibility = getVisibleState(result.visibility);
      } else {
        visibility = result;
      }
      if (visibility === 0) {
        return false;
      }
    }
    this._totalCount++;
    if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {
      this._matchCount++;
      return { data: FuzzyScore.Default, visibility: true };
    }
    const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);
    const labels = Array.isArray(label) ? label : [label];
    for (const l of labels) {
      const labelStr = l && l.toString();
      if (typeof labelStr === "undefined") {
        return { data: FuzzyScore.Default, visibility: true };
      }
      const score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);
      if (score) {
        this._matchCount++;
        return labels.length === 1 ? { data: score, visibility: true } : { data: { label: labelStr, score }, visibility: true };
      }
    }
    if (this.tree.options.filterOnType) {
      return 2;
    } else {
      return { data: FuzzyScore.Default, visibility: true };
    }
  }
  reset() {
    this._totalCount = 0;
    this._matchCount = 0;
  }
  dispose() {
    dispose(this.disposables);
  }
};
var TypeFilterController = class {
  constructor(tree, model, view, filter, keyboardNavigationDelegate) {
    this.tree = tree;
    this.view = view;
    this.filter = filter;
    this.keyboardNavigationDelegate = keyboardNavigationDelegate;
    this._enabled = false;
    this._pattern = "";
    this._empty = false;
    this._onDidChangeEmptyState = new Emitter();
    this.positionClassName = "ne";
    this.automaticKeyboardNavigation = true;
    this.triggered = false;
    this._onDidChangePattern = new Emitter();
    this.enabledDisposables = new DisposableStore();
    this.disposables = new DisposableStore();
    this.domNode = $(`.monaco-list-type-filter.${this.positionClassName}`);
    this.domNode.draggable = true;
    this.disposables.add(addDisposableListener(this.domNode, "dragstart", () => this.onDragStart()));
    this.messageDomNode = append(view.getHTMLElement(), $(`.monaco-list-type-filter-message`));
    this.labelDomNode = append(this.domNode, $("span.label"));
    const controls = append(this.domNode, $(".controls"));
    this._filterOnType = !!tree.options.filterOnType;
    this.filterOnTypeDomNode = append(controls, $("input.filter"));
    this.filterOnTypeDomNode.type = "checkbox";
    this.filterOnTypeDomNode.checked = this._filterOnType;
    this.filterOnTypeDomNode.tabIndex = -1;
    this.updateFilterOnTypeTitleAndIcon();
    this.disposables.add(addDisposableListener(this.filterOnTypeDomNode, "input", () => this.onDidChangeFilterOnType()));
    this.clearDomNode = append(controls, $("button.clear" + treeFilterClearIcon.cssSelector));
    this.clearDomNode.tabIndex = -1;
    this.clearDomNode.title = localize("clear", "Clear");
    this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;
    model.onDidSplice(this.onDidSpliceModel, this, this.disposables);
    this.updateOptions(tree.options);
  }
  get enabled() {
    return this._enabled;
  }
  get pattern() {
    return this._pattern;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  updateOptions(options) {
    if (options.simpleKeyboardNavigation) {
      this.disable();
    } else {
      this.enable();
    }
    if (typeof options.filterOnType !== "undefined") {
      this._filterOnType = !!options.filterOnType;
      this.filterOnTypeDomNode.checked = this._filterOnType;
      this.updateFilterOnTypeTitleAndIcon();
    }
    if (typeof options.automaticKeyboardNavigation !== "undefined") {
      this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;
    }
    this.tree.refilter();
    this.render();
    if (!this.automaticKeyboardNavigation) {
      this.onEventOrInput("");
    }
  }
  enable() {
    if (this._enabled) {
      return;
    }
    const onRawKeyDown = this.enabledDisposables.add(new DomEmitter(this.view.getHTMLElement(), "keydown"));
    const onKeyDown = Event.chain(onRawKeyDown.event).filter((e) => !isInputElement(e.target) || e.target === this.filterOnTypeDomNode).filter((e) => e.key !== "Dead" && !/^Media/.test(e.key)).map((e) => new StandardKeyboardEvent(e)).filter(this.keyboardNavigationEventFilter || (() => true)).filter(() => this.automaticKeyboardNavigation || this.triggered).filter((e) => this.keyboardNavigationDelegate.mightProducePrintableCharacter(e) && !(e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 15 || e.keyCode === 17) || ((this.pattern.length > 0 || this.triggered) && ((e.keyCode === 9 || e.keyCode === 1) && !e.altKey && !e.ctrlKey && !e.metaKey) || e.keyCode === 1 && (isMacintosh ? e.altKey && !e.metaKey : e.ctrlKey) && !e.shiftKey)).forEach((e) => {
      e.stopPropagation();
      e.preventDefault();
    }).event;
    const onClearClick = this.enabledDisposables.add(new DomEmitter(this.clearDomNode, "click"));
    Event.chain(Event.any(onKeyDown, onClearClick.event)).event(this.onEventOrInput, this, this.enabledDisposables);
    this.filter.pattern = "";
    this.tree.refilter();
    this.render();
    this._enabled = true;
    this.triggered = false;
  }
  disable() {
    if (!this._enabled) {
      return;
    }
    this.domNode.remove();
    this.enabledDisposables.clear();
    this.tree.refilter();
    this.render();
    this._enabled = false;
    this.triggered = false;
  }
  onEventOrInput(e) {
    if (typeof e === "string") {
      this.onInput(e);
    } else if (e instanceof MouseEvent || e.keyCode === 9 || e.keyCode === 1 && (isMacintosh ? e.altKey : e.ctrlKey)) {
      this.onInput("");
    } else if (e.keyCode === 1) {
      this.onInput(this.pattern.length === 0 ? "" : this.pattern.substr(0, this.pattern.length - 1));
    } else {
      this.onInput(this.pattern + e.browserEvent.key);
    }
  }
  onInput(pattern) {
    const container = this.view.getHTMLElement();
    if (pattern && !this.domNode.parentElement) {
      container.append(this.domNode);
    } else if (!pattern && this.domNode.parentElement) {
      this.domNode.remove();
      this.tree.domFocus();
    }
    this._pattern = pattern;
    this._onDidChangePattern.fire(pattern);
    this.filter.pattern = pattern;
    this.tree.refilter();
    if (pattern) {
      this.tree.focusNext(0, true, void 0, (node) => !FuzzyScore.isDefault(node.filterData));
    }
    const focus = this.tree.getFocus();
    if (focus.length > 0) {
      const element = focus[0];
      if (this.tree.getRelativeTop(element) === null) {
        this.tree.reveal(element, 0.5);
      }
    }
    this.render();
    if (!pattern) {
      this.triggered = false;
    }
  }
  onDragStart() {
    const container = this.view.getHTMLElement();
    const { left } = getDomNodePagePosition(container);
    const containerWidth = container.clientWidth;
    const midContainerWidth = containerWidth / 2;
    const width = this.domNode.clientWidth;
    const disposables = new DisposableStore();
    let positionClassName = this.positionClassName;
    const updatePosition = () => {
      switch (positionClassName) {
        case "nw":
          this.domNode.style.top = `4px`;
          this.domNode.style.left = `4px`;
          break;
        case "ne":
          this.domNode.style.top = `4px`;
          this.domNode.style.left = `${containerWidth - width - 6}px`;
          break;
      }
    };
    const onDragOver = (event) => {
      event.preventDefault();
      const x = event.clientX - left;
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = "none";
      }
      if (x < midContainerWidth) {
        positionClassName = "nw";
      } else {
        positionClassName = "ne";
      }
      updatePosition();
    };
    const onDragEnd = () => {
      this.positionClassName = positionClassName;
      this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`;
      this.domNode.style.top = "";
      this.domNode.style.left = "";
      dispose(disposables);
    };
    updatePosition();
    this.domNode.classList.remove(positionClassName);
    this.domNode.classList.add("dragging");
    disposables.add(toDisposable(() => this.domNode.classList.remove("dragging")));
    disposables.add(addDisposableListener(document, "dragover", (e) => onDragOver(e)));
    disposables.add(addDisposableListener(this.domNode, "dragend", () => onDragEnd()));
    StaticDND.CurrentDragAndDropData = new DragAndDropData("vscode-ui");
    disposables.add(toDisposable(() => StaticDND.CurrentDragAndDropData = void 0));
  }
  onDidSpliceModel() {
    if (!this._enabled || this.pattern.length === 0) {
      return;
    }
    this.tree.refilter();
    this.render();
  }
  onDidChangeFilterOnType() {
    this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked });
    this.tree.refilter();
    this.tree.domFocus();
    this.render();
    this.updateFilterOnTypeTitleAndIcon();
  }
  updateFilterOnTypeTitleAndIcon() {
    if (this.filterOnType) {
      this.filterOnTypeDomNode.classList.remove(...treeFilterOnTypeOffIcon.classNamesArray);
      this.filterOnTypeDomNode.classList.add(...treeFilterOnTypeOnIcon.classNamesArray);
      this.filterOnTypeDomNode.title = localize("disable filter on type", "Disable Filter on Type");
    } else {
      this.filterOnTypeDomNode.classList.remove(...treeFilterOnTypeOnIcon.classNamesArray);
      this.filterOnTypeDomNode.classList.add(...treeFilterOnTypeOffIcon.classNamesArray);
      this.filterOnTypeDomNode.title = localize("enable filter on type", "Enable Filter on Type");
    }
  }
  render() {
    const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    if (this.pattern && this.tree.options.filterOnType && noMatches) {
      this.messageDomNode.textContent = localize("empty", "No elements found");
      this._empty = true;
    } else {
      this.messageDomNode.innerText = "";
      this._empty = false;
    }
    this.domNode.classList.toggle("no-matches", noMatches);
    this.domNode.title = localize("found", "Matched {0} out of {1} elements", this.filter.matchCount, this.filter.totalCount);
    this.labelDomNode.textContent = this.pattern.length > 16 ? "\u2026" + this.pattern.substr(this.pattern.length - 16) : this.pattern;
    this._onDidChangeEmptyState.fire(this._empty);
  }
  shouldAllowFocus(node) {
    if (!this.enabled || !this.pattern || this.filterOnType) {
      return true;
    }
    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {
      return true;
    }
    return !FuzzyScore.isDefault(node.filterData);
  }
  dispose() {
    if (this._enabled) {
      this.domNode.remove();
      this.enabledDisposables.dispose();
      this._enabled = false;
      this.triggered = false;
    }
    this._onDidChangePattern.dispose();
    dispose(this.disposables);
  }
};
function asTreeMouseEvent(event) {
  let target = TreeMouseEventTarget.Unknown;
  if (hasParentWithClass(event.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Twistie;
  } else if (hasParentWithClass(event.browserEvent.target, "monaco-tl-contents", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Element;
  }
  return {
    browserEvent: event.browserEvent,
    element: event.element ? event.element.element : null,
    target
  };
}
function dfs(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs(child, fn));
}
var Trait = class {
  constructor(getFirstViewElementWithTrait, identityProvider) {
    this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;
    this.identityProvider = identityProvider;
    this.nodes = [];
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  get nodeSet() {
    if (!this._nodeSet) {
      this._nodeSet = this.createNodeSet();
    }
    return this._nodeSet;
  }
  set(nodes, browserEvent) {
    var _a6;
    if (!((_a6 = browserEvent) === null || _a6 === void 0 ? void 0 : _a6.__forceEvent) && equals2(this.nodes, nodes)) {
      return;
    }
    this._set(nodes, false, browserEvent);
  }
  _set(nodes, silent, browserEvent) {
    this.nodes = [...nodes];
    this.elements = void 0;
    this._nodeSet = void 0;
    if (!silent) {
      const that = this;
      this._onDidChange.fire({ get elements() {
        return that.get();
      }, browserEvent });
    }
  }
  get() {
    if (!this.elements) {
      this.elements = this.nodes.map((node) => node.element);
    }
    return [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(node) {
    return this.nodeSet.has(node);
  }
  onDidModelSplice({ insertedNodes, deletedNodes }) {
    if (!this.identityProvider) {
      const set = this.createNodeSet();
      const visit = (node) => set.delete(node);
      deletedNodes.forEach((node) => dfs(node, visit));
      this.set([...set.values()]);
      return;
    }
    const deletedNodesIdSet = new Set();
    const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());
    deletedNodes.forEach((node) => dfs(node, deletedNodesVisitor));
    const insertedNodesMap = new Map();
    const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);
    insertedNodes.forEach((node) => dfs(node, insertedNodesVisitor));
    const nodes = [];
    for (const node of this.nodes) {
      const id = this.identityProvider.getId(node.element).toString();
      const wasDeleted = deletedNodesIdSet.has(id);
      if (!wasDeleted) {
        nodes.push(node);
      } else {
        const insertedNode = insertedNodesMap.get(id);
        if (insertedNode) {
          nodes.push(insertedNode);
        }
      }
    }
    if (this.nodes.length > 0 && nodes.length === 0) {
      const node = this.getFirstViewElementWithTrait();
      if (node) {
        nodes.push(node);
      }
    }
    this._set(nodes, true);
  }
  createNodeSet() {
    const set = new Set();
    for (const node of this.nodes) {
      set.add(node);
    }
    return set;
  }
};
var TreeNodeListMouseController = class extends MouseController {
  constructor(list, tree) {
    super(list);
    this.tree = tree;
  }
  onViewPointer(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    const node = e.element;
    if (!node) {
      return super.onViewPointer(e);
    }
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {
      return super.onViewPointer(e);
    }
    const target = e.browserEvent.target;
    const onTwistie = target.classList.contains("monaco-tl-twistie") || target.classList.contains("monaco-icon-label") && target.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
    let expandOnlyOnTwistieClick = false;
    if (typeof this.tree.expandOnlyOnTwistieClick === "function") {
      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);
    } else {
      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;
    }
    if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {
      return super.onViewPointer(e);
    }
    if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {
      return super.onViewPointer(e);
    }
    if (node.collapsible) {
      const model = this.tree.model;
      const location = model.getNodeLocation(node);
      const recursive = e.browserEvent.altKey;
      this.tree.setFocus([location]);
      model.setCollapsed(location, void 0, recursive);
      if (expandOnlyOnTwistieClick && onTwistie) {
        return;
      }
    }
    super.onViewPointer(e);
  }
  onDoubleClick(e) {
    const onTwistie = e.browserEvent.target.classList.contains("monaco-tl-twistie");
    if (onTwistie || !this.tree.expandOnDoubleClick) {
      return;
    }
    super.onDoubleClick(e);
  }
};
var TreeNodeList = class extends List {
  constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {
    super(user, container, virtualDelegate, renderers, options);
    this.focusTrait = focusTrait;
    this.selectionTrait = selectionTrait;
    this.anchorTrait = anchorTrait;
  }
  createMouseController(options) {
    return new TreeNodeListMouseController(this, options.tree);
  }
  splice(start, deleteCount, elements = []) {
    super.splice(start, deleteCount, elements);
    if (elements.length === 0) {
      return;
    }
    const additionalFocus = [];
    const additionalSelection = [];
    let anchor;
    elements.forEach((node, index) => {
      if (this.focusTrait.has(node)) {
        additionalFocus.push(start + index);
      }
      if (this.selectionTrait.has(node)) {
        additionalSelection.push(start + index);
      }
      if (this.anchorTrait.has(node)) {
        anchor = start + index;
      }
    });
    if (additionalFocus.length > 0) {
      super.setFocus(distinctES6([...super.getFocus(), ...additionalFocus]));
    }
    if (additionalSelection.length > 0) {
      super.setSelection(distinctES6([...super.getSelection(), ...additionalSelection]));
    }
    if (typeof anchor === "number") {
      super.setAnchor(anchor);
    }
  }
  setFocus(indexes, browserEvent, fromAPI = false) {
    super.setFocus(indexes, browserEvent);
    if (!fromAPI) {
      this.focusTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
  setSelection(indexes, browserEvent, fromAPI = false) {
    super.setSelection(indexes, browserEvent);
    if (!fromAPI) {
      this.selectionTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
  setAnchor(index, fromAPI = false) {
    super.setAnchor(index);
    if (!fromAPI) {
      if (typeof index === "undefined") {
        this.anchorTrait.set([]);
      } else {
        this.anchorTrait.set([this.element(index)]);
      }
    }
  }
};
var AbstractTree = class {
  constructor(user, container, delegate, renderers, _options = {}) {
    this._options = _options;
    this.eventBufferer = new EventBufferer();
    this.disposables = new DisposableStore();
    this._onWillRefilter = new Emitter();
    this.onWillRefilter = this._onWillRefilter.event;
    this._onDidUpdateOptions = new Emitter();
    const treeDelegate = new ComposedTreeDelegate(delegate);
    const onDidChangeCollapseStateRelay = new Relay();
    const onDidChangeActiveNodes = new Relay();
    const activeNodes = new EventCollection(onDidChangeActiveNodes.event);
    this.renderers = renderers.map((r) => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));
    for (let r of this.renderers) {
      this.disposables.add(r);
    }
    let filter;
    if (_options.keyboardNavigationLabelProvider) {
      filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);
      _options = Object.assign(Object.assign({}, _options), { filter });
      this.disposables.add(filter);
    }
    this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);
    this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);
    this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);
    this.view = new TreeNodeList(user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));
    this.model = this.createModel(user, this.view, _options);
    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
    const onDidModelSplice = Event.forEach(this.model.onDidSplice, (e) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(e);
        this.selection.onDidModelSplice(e);
      });
    });
    onDidModelSplice(() => null, null, this.disposables);
    onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const set = new Set();
      for (const node of this.focus.getNodes()) {
        set.add(node);
      }
      for (const node of this.selection.getNodes()) {
        set.add(node);
      }
      return [...set.values()];
    }).event;
    if (_options.keyboardSupport !== false) {
      const onKeyDown = Event.chain(this.view.onKeyDown).filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e));
      onKeyDown.filter((e) => e.keyCode === 15).on(this.onLeftArrow, this, this.disposables);
      onKeyDown.filter((e) => e.keyCode === 17).on(this.onRightArrow, this, this.disposables);
      onKeyDown.filter((e) => e.keyCode === 10).on(this.onSpace, this, this.disposables);
    }
    if (_options.keyboardNavigationLabelProvider) {
      const delegate2 = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
      this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, delegate2);
      this.focusNavigationFilter = (node) => this.typeFilterController.shouldAllowFocus(node);
      this.disposables.add(this.typeFilterController);
    }
    this.styleElement = createStyleSheet(this.view.getHTMLElement());
    this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return Event.map(this.view.onMouseDblClick, asTreeMouseEvent);
  }
  get onPointer() {
    return Event.map(this.view.onPointer, asTreeMouseEvent);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick === "undefined" ? true : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick === "undefined" ? true : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  updateOptions(optionsUpdate = {}) {
    this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);
    for (const renderer of this.renderers) {
      renderer.updateOptions(optionsUpdate);
    }
    this.view.updateOptions(Object.assign(Object.assign({}, this._options), { enableKeyboardNavigation: this._options.simpleKeyboardNavigation }));
    if (this.typeFilterController) {
      this.typeFilterController.updateOptions(this._options);
    }
    this._onDidUpdateOptions.fire(this._options);
    this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  get options() {
    return this._options;
  }
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.view.scrollTop = scrollTop;
  }
  domFocus() {
    this.view.domFocus();
  }
  layout(height, width) {
    this.view.layout(height, width);
  }
  style(styles) {
    const suffix = `.${this.view.domId}`;
    const content = [];
    if (styles.treeIndentGuidesStroke) {
      content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);
      content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);
    }
    this.styleElement.textContent = content.join("\n");
    this.view.style(styles);
  }
  collapse(location, recursive = false) {
    return this.model.setCollapsed(location, true, recursive);
  }
  expand(location, recursive = false) {
    return this.model.setCollapsed(location, false, recursive);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsible) {
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  refilter() {
    this._onWillRefilter.fire(void 0);
    this.model.refilter();
  }
  setSelection(elements, browserEvent) {
    const nodes = elements.map((e) => this.model.getNode(e));
    this.selection.set(nodes, browserEvent);
    const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
    this.view.setSelection(indexes, browserEvent, true);
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(elements, browserEvent) {
    const nodes = elements.map((e) => this.model.getNode(e));
    this.focus.set(nodes, browserEvent);
    const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
    this.view.setFocus(indexes, browserEvent, true);
  }
  focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusNext(n, loop, browserEvent, filter);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(location, relativeTop) {
    this.model.expandTo(location);
    const index = this.model.getListIndex(location);
    if (index === -1) {
      return;
    }
    this.view.reveal(index, relativeTop);
  }
  getRelativeTop(location) {
    const index = this.model.getListIndex(location);
    if (index === -1) {
      return null;
    }
    return this.view.getRelativeTop(index);
  }
  onLeftArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, true);
    if (!didChange) {
      const parentLocation = this.model.getParentNodeLocation(location);
      if (!parentLocation) {
        return;
      }
      const parentListIndex = this.model.getListIndex(parentLocation);
      this.view.reveal(parentListIndex);
      this.view.setFocus([parentListIndex]);
    }
  }
  onRightArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, false);
    if (!didChange) {
      if (!node.children.some((child) => child.visible)) {
        return;
      }
      const [focusedIndex] = this.view.getFocus();
      const firstChildIndex = focusedIndex + 1;
      this.view.reveal(firstChildIndex);
      this.view.setFocus([firstChildIndex]);
    }
  }
  onSpace(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const recursive = e.browserEvent.altKey;
    this.model.setCollapsed(location, void 0, recursive);
  }
  dispose() {
    dispose(this.disposables);
    this.view.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTreeModel.js
var ObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = new Map();
    this.nodesByIdentity = new Map();
    this.model = new IndexTreeModel(user, list, null, options);
    this.onDidSplice = this.model.onDidSplice;
    this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;
    this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;
    if (options.sorter) {
      this.sorter = {
        compare(a, b) {
          return options.sorter.compare(a.element, b.element);
        }
      };
    }
    this.identityProvider = options.identityProvider;
  }
  setChildren(element, children = Iterable.empty(), options = {}) {
    const location = this.getElementLocation(element);
    this._setChildren(location, this.preserveCollapseState(children), options);
  }
  _setChildren(location, children = Iterable.empty(), options) {
    const insertedElements = new Set();
    const insertedElementIds = new Set();
    const onDidCreateNode = (node) => {
      var _a6;
      if (node.element === null) {
        return;
      }
      const tnode = node;
      insertedElements.add(tnode.element);
      this.nodes.set(tnode.element, tnode);
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        insertedElementIds.add(id);
        this.nodesByIdentity.set(id, tnode);
      }
      (_a6 = options.onDidCreateNode) === null || _a6 === void 0 ? void 0 : _a6.call(options, tnode);
    };
    const onDidDeleteNode = (node) => {
      var _a6;
      if (node.element === null) {
        return;
      }
      const tnode = node;
      if (!insertedElements.has(tnode.element)) {
        this.nodes.delete(tnode.element);
      }
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        if (!insertedElementIds.has(id)) {
          this.nodesByIdentity.delete(id);
        }
      }
      (_a6 = options.onDidDeleteNode) === null || _a6 === void 0 ? void 0 : _a6.call(options, tnode);
    };
    this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));
  }
  preserveCollapseState(elements = Iterable.empty()) {
    if (this.sorter) {
      elements = [...elements].sort(this.sorter.compare.bind(this.sorter));
    }
    return Iterable.map(elements, (treeElement) => {
      let node = this.nodes.get(treeElement.element);
      if (!node && this.identityProvider) {
        const id = this.identityProvider.getId(treeElement.element).toString();
        node = this.nodesByIdentity.get(id);
      }
      if (!node) {
        return Object.assign(Object.assign({}, treeElement), { children: this.preserveCollapseState(treeElement.children) });
      }
      const collapsible = typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : node.collapsible;
      const collapsed = typeof treeElement.collapsed !== "undefined" ? treeElement.collapsed : node.collapsed;
      return Object.assign(Object.assign({}, treeElement), {
        collapsible,
        collapsed,
        children: this.preserveCollapseState(treeElement.children)
      });
    });
  }
  rerender(element) {
    const location = this.getElementLocation(element);
    this.model.rerender(location);
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(element) {
    const location = this.getElementLocation(element);
    return this.model.getListIndex(location);
  }
  getListRenderCount(element) {
    const location = this.getElementLocation(element);
    return this.model.getListRenderCount(location);
  }
  isCollapsible(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsible(location);
  }
  setCollapsible(element, collapsible) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsed(location);
  }
  setCollapsed(element, collapsed, recursive) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(element) {
    const location = this.getElementLocation(element);
    this.model.expandTo(location);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(element = null) {
    if (element === null) {
      return this.model.getNode(this.model.rootRef);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(element) {
    if (element === null) {
      throw new TreeError(this.user, `Invalid getParentNodeLocation call`);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    const location = this.model.getNodeLocation(node);
    const parentLocation = this.model.getParentNodeLocation(location);
    const parent = this.model.getNode(parentLocation);
    return parent.element;
  }
  getElementLocation(element) {
    if (element === null) {
      return [];
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return this.model.getNodeLocation(node);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js
function noCompress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  return {
    element: { elements, incompressible },
    children: Iterable.map(Iterable.from(element.children), noCompress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function compress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  let childrenIterator;
  let children;
  while (true) {
    [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);
    if (children.length !== 1) {
      break;
    }
    if (children[0].incompressible) {
      break;
    }
    element = children[0];
    elements.push(element.element);
  }
  return {
    element: { elements, incompressible },
    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function _decompress(element, index = 0) {
  let children;
  if (index < element.element.elements.length - 1) {
    children = [_decompress(element, index + 1)];
  } else {
    children = Iterable.map(Iterable.from(element.children), (el) => _decompress(el, 0));
  }
  if (index === 0 && element.element.incompressible) {
    return {
      element: element.element.elements[index],
      children,
      incompressible: true,
      collapsible: element.collapsible,
      collapsed: element.collapsed
    };
  }
  return {
    element: element.element.elements[index],
    children,
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function decompress(element) {
  return _decompress(element, 0);
}
function splice2(treeElement, element, children) {
  if (treeElement.element === element) {
    return Object.assign(Object.assign({}, treeElement), { children });
  }
  return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), (e) => splice2(e, element, children)) });
}
var wrapIdentityProvider = (base) => ({
  getId(node) {
    return node.elements.map((e) => base.getId(e).toString()).join("\0");
  }
});
var CompressedObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = new Map();
    this.model = new ObjectTreeModel(user, list, options);
    this.enabled = typeof options.compressionEnabled === "undefined" ? true : options.compressionEnabled;
    this.identityProvider = options.identityProvider;
  }
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  setChildren(element, children = Iterable.empty(), options) {
    const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);
    if (element === null) {
      const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);
      this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });
      return;
    }
    const compressedNode = this.nodes.get(element);
    if (!compressedNode) {
      throw new Error("Unknown compressed tree node");
    }
    const node = this.model.getNode(compressedNode);
    const compressedParentNode = this.model.getParentNodeLocation(compressedNode);
    const parent = this.model.getNode(compressedParentNode);
    const decompressedElement = decompress(node);
    const splicedElement = splice2(decompressedElement, element, children);
    const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);
    const parentChildren = parent.children.map((child) => child === node ? recompressedElement : child);
    this._setChildren(parent.element, parentChildren, {
      diffIdentityProvider,
      diffDepth: node.depth - parent.depth
    });
  }
  setCompressionEnabled(enabled) {
    if (enabled === this.enabled) {
      return;
    }
    this.enabled = enabled;
    const root = this.model.getNode();
    const rootChildren = root.children;
    const decompressedRootChildren = Iterable.map(rootChildren, decompress);
    const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);
    this._setChildren(null, recompressedRootChildren, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: Infinity
    });
  }
  _setChildren(node, children, options) {
    const insertedElements = new Set();
    const onDidCreateNode = (node2) => {
      for (const element of node2.element.elements) {
        insertedElements.add(element);
        this.nodes.set(element, node2.element);
      }
    };
    const onDidDeleteNode = (node2) => {
      for (const element of node2.element.elements) {
        if (!insertedElements.has(element)) {
          this.nodes.delete(element);
        }
      }
    };
    this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListIndex(node);
  }
  getListRenderCount(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListRenderCount(node);
  }
  getNode(location) {
    if (typeof location === "undefined") {
      return this.model.getNode();
    }
    const node = this.getCompressedNode(location);
    return this.model.getNode(node);
  }
  getNodeLocation(node) {
    const compressedNode = this.model.getNodeLocation(node);
    if (compressedNode === null) {
      return null;
    }
    return compressedNode.elements[compressedNode.elements.length - 1];
  }
  getParentNodeLocation(location) {
    const compressedNode = this.getCompressedNode(location);
    const parentNode = this.model.getParentNodeLocation(compressedNode);
    if (parentNode === null) {
      return null;
    }
    return parentNode.elements[parentNode.elements.length - 1];
  }
  isCollapsible(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsible(compressedNode);
  }
  setCollapsible(location, collapsible) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsible(compressedNode, collapsible);
  }
  isCollapsed(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsed(compressedNode);
  }
  setCollapsed(location, collapsed, recursive) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsed(compressedNode, collapsed, recursive);
  }
  expandTo(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.expandTo(compressedNode);
  }
  rerender(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.rerender(compressedNode);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(element) {
    if (element === null) {
      return null;
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
};
var DefaultElementMapper = (elements) => elements[elements.length - 1];
var CompressedTreeNodeWrapper = class {
  constructor(unwrapper, node) {
    this.unwrapper = unwrapper;
    this.node = node;
  }
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((node) => new CompressedTreeNodeWrapper(this.unwrapper, node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
function mapList(nodeMapper, list) {
  return {
    splice(start, deleteCount, toInsert) {
      list.splice(start, deleteCount, toInsert.map((node) => nodeMapper.map(node)));
    },
    updateElementHeight(index, height) {
      list.updateElementHeight(index, height);
    }
  };
}
function mapOptions(compressedNodeUnwrapper, options) {
  return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {
    getId(node) {
      return options.identityProvider.getId(compressedNodeUnwrapper(node));
    }
  }, sorter: options.sorter && {
    compare(node, otherNode) {
      return options.sorter.compare(node.elements[0], otherNode.elements[0]);
    }
  }, filter: options.filter && {
    filter(node, parentVisibility) {
      return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);
    }
  } });
}
var CompressibleObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.rootRef = null;
    this.elementMapper = options.elementMapper || DefaultElementMapper;
    const compressedNodeUnwrapper = (node) => this.elementMapper(node.elements);
    this.nodeMapper = new WeakMapper((node) => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));
    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));
  }
  get onDidSplice() {
    return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({
      insertedNodes: insertedNodes.map((node) => this.nodeMapper.map(node)),
      deletedNodes: deletedNodes.map((node) => this.nodeMapper.map(node))
    }));
  }
  get onDidChangeCollapseState() {
    return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({
      node: this.nodeMapper.map(node),
      deep
    }));
  }
  get onDidChangeRenderNodeCount() {
    return Event.map(this.model.onDidChangeRenderNodeCount, (node) => this.nodeMapper.map(node));
  }
  setChildren(element, children = Iterable.empty(), options = {}) {
    this.model.setChildren(element, children, options);
  }
  setCompressionEnabled(enabled) {
    this.model.setCompressionEnabled(enabled);
  }
  has(location) {
    return this.model.has(location);
  }
  getListIndex(location) {
    return this.model.getListIndex(location);
  }
  getListRenderCount(location) {
    return this.model.getListRenderCount(location);
  }
  getNode(location) {
    return this.nodeMapper.map(this.model.getNode(location));
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(location) {
    return this.model.getParentNodeLocation(location);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsed) {
    return this.model.setCollapsible(location, collapsed);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  setCollapsed(location, collapsed, recursive) {
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(location) {
    return this.model.expandTo(location);
  }
  rerender(location) {
    return this.model.rerender(location);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(location = null) {
    return this.model.getNode(location);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTree.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ObjectTree = class extends AbstractTree {
  constructor(user, container, delegate, renderers, options = {}) {
    super(user, container, delegate, renderers, options);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  setChildren(element, children = Iterable.empty(), options) {
    this.model.setChildren(element, children, options);
  }
  rerender(element) {
    if (element === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(element);
  }
  hasElement(element) {
    return this.model.has(element);
  }
  createModel(user, view, options) {
    return new ObjectTreeModel(user, view, options);
  }
};
var CompressibleRenderer = class {
  constructor(_compressedTreeNodeProvider, renderer) {
    this._compressedTreeNodeProvider = _compressedTreeNodeProvider;
    this.renderer = renderer;
    this.templateId = renderer.templateId;
    if (renderer.onDidChangeTwistieState) {
      this.onDidChangeTwistieState = renderer.onDidChangeTwistieState;
    }
  }
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return { compressedTreeNode: void 0, data };
  }
  renderElement(node, index, templateData, height) {
    const compressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element);
    if (compressedTreeNode.element.elements.length === 1) {
      templateData.compressedTreeNode = void 0;
      this.renderer.renderElement(node, index, templateData.data, height);
    } else {
      templateData.compressedTreeNode = compressedTreeNode;
      this.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);
    }
  }
  disposeElement(node, index, templateData, height) {
    if (templateData.compressedTreeNode) {
      if (this.renderer.disposeCompressedElements) {
        this.renderer.disposeCompressedElements(templateData.compressedTreeNode, index, templateData.data, height);
      }
    } else {
      if (this.renderer.disposeElement) {
        this.renderer.disposeElement(node, index, templateData.data, height);
      }
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.data);
  }
  renderTwistie(element, twistieElement) {
    if (this.renderer.renderTwistie) {
      return this.renderer.renderTwistie(element, twistieElement);
    }
    return false;
  }
};
__decorate12([
  memoize
], CompressibleRenderer.prototype, "compressedTreeNodeProvider", null);
function asObjectTreeOptions(compressedTreeNodeProvider, options) {
  return options && Object.assign(Object.assign({}, options), { keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
    getKeyboardNavigationLabel(e) {
      let compressedTreeNode;
      try {
        compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);
      } catch (_a6) {
        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
      }
      if (compressedTreeNode.element.elements.length === 1) {
        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
      } else {
        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);
      }
    }
  } });
}
var CompressibleObjectTree = class extends ObjectTree {
  constructor(user, container, delegate, renderers, options = {}) {
    const compressedTreeNodeProvider = () => this;
    const compressibleRenderers = renderers.map((r) => new CompressibleRenderer(compressedTreeNodeProvider, r));
    super(user, container, delegate, compressibleRenderers, asObjectTreeOptions(compressedTreeNodeProvider, options));
  }
  setChildren(element, children = Iterable.empty(), options) {
    this.model.setChildren(element, children, options);
  }
  createModel(user, view, options) {
    return new CompressibleObjectTreeModel(user, view, options);
  }
  updateOptions(optionsUpdate = {}) {
    super.updateOptions(optionsUpdate);
    if (typeof optionsUpdate.compressionEnabled !== "undefined") {
      this.model.setCompressionEnabled(optionsUpdate.compressionEnabled);
    }
  }
  getCompressedTreeNode(element = null) {
    return this.model.getCompressedTreeNode(element);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createAsyncDataTreeNode(props) {
  return Object.assign(Object.assign({}, props), { children: [], refreshPromise: void 0, stale: true, slow: false, collapsedByDefault: void 0 });
}
function isAncestor2(ancestor, descendant) {
  if (!descendant.parent) {
    return false;
  } else if (descendant.parent === ancestor) {
    return true;
  } else {
    return isAncestor2(ancestor, descendant.parent);
  }
}
function intersects(node, other) {
  return node === other || isAncestor2(node, other) || isAncestor2(other, node);
}
var AsyncDataTreeNodeWrapper = class {
  constructor(node) {
    this.node = node;
  }
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((node) => new AsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
var AsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = new Map();
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return { templateData };
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);
      return true;
    } else {
      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);
      return false;
    }
  }
  disposeElement(node, index, templateData, height) {
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
};
function asTreeEvent(e) {
  return {
    browserEvent: e.browserEvent,
    elements: e.elements.map((e2) => e2.element)
  };
}
function asTreeMouseEvent2(e) {
  return {
    browserEvent: e.browserEvent,
    element: e.element && e.element.element,
    target: e.target
  };
}
var AsyncDataTreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asAsyncDataTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new AsyncDataTreeElementsDragAndDropData(data);
  }
  return data;
}
var AsyncDataTreeNodeListDragAndDrop = class {
  constructor(dnd) {
    this.dnd = dnd;
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);
    }
  }
  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  drop(data, targetNode, targetIndex, originalEvent) {
    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(originalEvent);
    }
  }
};
function asObjectTreeOptions2(options) {
  return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {
    getId(el) {
      return options.identityProvider.getId(el.element);
    }
  }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    },
    isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    }
  }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {
    getPosInSet: void 0,
    getSetSize: void 0,
    getRole: options.accessibilityProvider.getRole ? (el) => {
      return options.accessibilityProvider.getRole(el.element);
    } : () => "treeitem",
    isChecked: options.accessibilityProvider.isChecked ? (e) => {
      var _a6;
      return !!((_a6 = options.accessibilityProvider) === null || _a6 === void 0 ? void 0 : _a6.isChecked(e.element));
    } : void 0,
    getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: options.accessibilityProvider.getAriaLevel && ((node) => {
      return options.accessibilityProvider.getAriaLevel(node.element);
    }),
    getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && ((node) => {
      return options.accessibilityProvider.getActiveDescendantId(node.element);
    })
  }), filter: options.filter && {
    filter(e, parentVisibility) {
      return options.filter.filter(e.element, parentVisibility);
    }
  }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
  } }), sorter: void 0, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === "undefined" ? void 0 : typeof options.expandOnlyOnTwistieClick !== "function" ? options.expandOnlyOnTwistieClick : (e) => options.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: options.additionalScrollHeight });
}
function dfs2(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs2(child, fn));
}
var AsyncDataTree = class {
  constructor(user, container, delegate, renderers, dataSource, options = {}) {
    this.user = user;
    this.dataSource = dataSource;
    this.nodes = new Map();
    this.subTreeRefreshPromises = new Map();
    this.refreshPromises = new Map();
    this._onDidRender = new Emitter();
    this._onDidChangeNodeSlowState = new Emitter();
    this.nodeMapper = new WeakMapper((node) => new AsyncDataTreeNodeWrapper(node));
    this.disposables = new DisposableStore();
    this.identityProvider = options.identityProvider;
    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? false : options.autoExpandSingleChildren;
    this.sorter = options.sorter;
    this.collapseByDefault = options.collapseByDefault;
    this.tree = this.createTree(user, container, delegate, renderers, options);
    this.root = createAsyncDataTreeNode({
      element: void 0,
      parent: null,
      hasChildren: true
    });
    if (this.identityProvider) {
      this.root = Object.assign(Object.assign({}, this.root), { id: null });
    }
    this.nodes.set(null, this.root);
    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  get onDidChangeFocus() {
    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);
  }
  get onDidChangeSelection() {
    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);
  }
  get onMouseDblClick() {
    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent2);
  }
  get onPointer() {
    return Event.map(this.tree.onPointer, asTreeMouseEvent2);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  createTree(user, container, delegate, renderers, options) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asObjectTreeOptions2(options) || {};
    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  updateOptions(options = {}) {
    this.tree.updateOptions(options);
  }
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.tree.scrollTop = scrollTop;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(height, width) {
    this.tree.layout(height, width);
  }
  style(styles) {
    this.tree.style(styles);
  }
  getInput() {
    return this.root.element;
  }
  setInput(input, viewState) {
    return __awaiter8(this, void 0, void 0, function* () {
      this.refreshPromises.forEach((promise) => promise.cancel());
      this.refreshPromises.clear();
      this.root.element = input;
      const viewStateContext = viewState && { viewState, focus: [], selection: [] };
      yield this._updateChildren(input, true, false, viewStateContext);
      if (viewStateContext) {
        this.tree.setFocus(viewStateContext.focus);
        this.tree.setSelection(viewStateContext.selection);
      }
      if (viewState && typeof viewState.scrollTop === "number") {
        this.scrollTop = viewState.scrollTop;
      }
    });
  }
  _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (typeof this.root.element === "undefined") {
        throw new TreeError(this.user, "Tree input not set");
      }
      if (this.root.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      const node = this.getDataNode(element);
      yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);
      if (rerender) {
        try {
          this.tree.rerender(node);
        } catch (_a6) {
        }
      }
    });
  }
  rerender(element) {
    if (element === void 0 || element === this.root.element) {
      this.tree.rerender();
      return;
    }
    const node = this.getDataNode(element);
    this.tree.rerender(node);
  }
  collapse(element, recursive = false) {
    const node = this.getDataNode(element);
    return this.tree.collapse(node === this.root ? null : node, recursive);
  }
  expand(element, recursive = false) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (typeof this.root.element === "undefined") {
        throw new TreeError(this.user, "Tree input not set");
      }
      if (this.root.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      const node = this.getDataNode(element);
      if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {
        return false;
      }
      if (node.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {
        return false;
      }
      const result = this.tree.expand(node === this.root ? null : node, recursive);
      if (node.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      return result;
    });
  }
  setSelection(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setSelection(nodes, browserEvent);
  }
  getSelection() {
    const nodes = this.tree.getSelection();
    return nodes.map((n) => n.element);
  }
  setFocus(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setFocus(nodes, browserEvent);
  }
  getFocus() {
    const nodes = this.tree.getFocus();
    return nodes.map((n) => n.element);
  }
  reveal(element, relativeTop) {
    this.tree.reveal(this.getDataNode(element), relativeTop);
  }
  getDataNode(element) {
    const node = this.nodes.get(element === this.root.element ? null : element);
    if (!node) {
      throw new TreeError(this.user, `Data tree node not found: ${element}`);
    }
    return node;
  }
  refreshAndRenderNode(node, recursive, viewStateContext, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      yield this.refreshNode(node, recursive, viewStateContext);
      this.render(node, viewStateContext, options);
    });
  }
  refreshNode(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      let result;
      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
        if (!result && intersects(refreshNode, node)) {
          result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));
        }
      });
      if (result) {
        return result;
      }
      return this.doRefreshSubTree(node, recursive, viewStateContext);
    });
  }
  doRefreshSubTree(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      let done;
      node.refreshPromise = new Promise((c) => done = c);
      this.subTreeRefreshPromises.set(node, node.refreshPromise);
      node.refreshPromise.finally(() => {
        node.refreshPromise = void 0;
        this.subTreeRefreshPromises.delete(node);
      });
      try {
        const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);
        node.stale = false;
        yield Promises.settled(childrenToRefresh.map((child) => this.doRefreshSubTree(child, recursive, viewStateContext)));
      } finally {
        done();
      }
    });
  }
  doRefreshNode(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      node.hasChildren = !!this.dataSource.hasChildren(node.element);
      let childrenPromise;
      if (!node.hasChildren) {
        childrenPromise = Promise.resolve(Iterable.empty());
      } else {
        const slowTimeout = timeout(800);
        slowTimeout.then(() => {
          node.slow = true;
          this._onDidChangeNodeSlowState.fire(node);
        }, (_) => null);
        childrenPromise = this.doGetChildren(node).finally(() => slowTimeout.cancel());
      }
      try {
        const children = yield childrenPromise;
        return this.setChildren(node, children, recursive, viewStateContext);
      } catch (err) {
        if (node !== this.root && this.tree.hasElement(node)) {
          this.tree.collapse(node);
        }
        if (isPromiseCanceledError(err)) {
          return [];
        }
        throw err;
      } finally {
        if (node.slow) {
          node.slow = false;
          this._onDidChangeNodeSlowState.fire(node);
        }
      }
    });
  }
  doGetChildren(node) {
    let result = this.refreshPromises.get(node);
    if (result) {
      return result;
    }
    result = createCancelablePromise(() => __awaiter8(this, void 0, void 0, function* () {
      const children = yield this.dataSource.getChildren(node.element);
      return this.processChildren(children);
    }));
    this.refreshPromises.set(node, result);
    return result.finally(() => {
      this.refreshPromises.delete(node);
    });
  }
  _onDidChangeCollapseState({ node, deep }) {
    if (node.element === null) {
      return;
    }
    if (!node.collapsed && node.element.stale) {
      if (deep) {
        this.collapse(node.element.element);
      } else {
        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);
      }
    }
  }
  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {
    const childrenElements = [...childrenElementsIterable];
    if (node.children.length === 0 && childrenElements.length === 0) {
      return [];
    }
    const nodesToForget = new Map();
    const childrenTreeNodesById = new Map();
    for (const child of node.children) {
      nodesToForget.set(child.element, child);
      if (this.identityProvider) {
        const collapsed = this.tree.isCollapsed(child);
        childrenTreeNodesById.set(child.id, { node: child, collapsed });
      }
    }
    const childrenToRefresh = [];
    const children = childrenElements.map((element) => {
      const hasChildren = !!this.dataSource.hasChildren(element);
      if (!this.identityProvider) {
        const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });
        if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
          asyncDataTreeNode.collapsedByDefault = false;
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const id = this.identityProvider.getId(element).toString();
      const result = childrenTreeNodesById.get(id);
      if (result) {
        const asyncDataTreeNode = result.node;
        nodesToForget.delete(asyncDataTreeNode.element);
        this.nodes.delete(asyncDataTreeNode.element);
        this.nodes.set(element, asyncDataTreeNode);
        asyncDataTreeNode.element = element;
        asyncDataTreeNode.hasChildren = hasChildren;
        if (recursive) {
          if (result.collapsed) {
            asyncDataTreeNode.children.forEach((node2) => dfs2(node2, (node3) => this.nodes.delete(node3.element)));
            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);
            asyncDataTreeNode.stale = true;
          } else {
            childrenToRefresh.push(asyncDataTreeNode);
          }
        } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
          asyncDataTreeNode.collapsedByDefault = false;
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });
      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {
        viewStateContext.focus.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {
        viewStateContext.selection.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {
        childrenToRefresh.push(childAsyncDataTreeNode);
      } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
        childAsyncDataTreeNode.collapsedByDefault = false;
        childrenToRefresh.push(childAsyncDataTreeNode);
      }
      return childAsyncDataTreeNode;
    });
    for (const node2 of nodesToForget.values()) {
      dfs2(node2, (node3) => this.nodes.delete(node3.element));
    }
    for (const child of children) {
      this.nodes.set(child.element, child);
    }
    node.children.splice(0, node.children.length, ...children);
    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {
      children[0].collapsedByDefault = false;
      childrenToRefresh.push(children[0]);
    }
    return childrenToRefresh;
  }
  render(node, viewStateContext, options) {
    const children = node.children.map((node2) => this.asTreeElement(node2, viewStateContext));
    const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {
      getId(node2) {
        return options.diffIdentityProvider.getId(node2.element);
      }
    } });
    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);
    if (node !== this.root) {
      this.tree.setCollapsible(node, node.hasChildren);
    }
    this._onDidRender.fire();
  }
  asTreeElement(node, viewStateContext) {
    if (node.stale) {
      return {
        element: node,
        collapsible: node.hasChildren,
        collapsed: true
      };
    }
    let collapsed;
    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {
      collapsed = false;
    } else {
      collapsed = node.collapsedByDefault;
    }
    node.collapsedByDefault = void 0;
    return {
      element: node,
      children: node.hasChildren ? Iterable.map(node.children, (child) => this.asTreeElement(child, viewStateContext)) : [],
      collapsible: node.hasChildren,
      collapsed
    };
  }
  processChildren(children) {
    if (this.sorter) {
      children = [...children].sort(this.sorter.compare.bind(this.sorter));
    }
    return children;
  }
  dispose() {
    this.disposables.dispose();
  }
};
var CompressibleAsyncDataTreeNodeWrapper = class {
  constructor(node) {
    this.node = node;
  }
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((node) => new CompressibleAsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
var CompressibleAsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = new Map();
    this.disposables = [];
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return { templateData };
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderCompressedElements(node, index, templateData, height) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);
      return true;
    } else {
      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);
      return false;
    }
  }
  disposeElement(node, index, templateData, height) {
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
  }
  disposeCompressedElements(node, index, templateData, height) {
    if (this.renderer.disposeCompressedElements) {
      this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
    this.disposables = dispose(this.disposables);
  }
};
function asCompressibleObjectTreeOptions(options) {
  const objectTreeOptions = options && asObjectTreeOptions2(options);
  return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {
    return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map((e) => e.element));
  } }) });
}
var CompressibleAsyncDataTree = class extends AsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {
    super(user, container, virtualDelegate, renderers, dataSource, options);
    this.compressionDelegate = compressionDelegate;
    this.compressibleNodeMapper = new WeakMapper((node) => new CompressibleAsyncDataTreeNodeWrapper(node));
    this.filter = options.filter;
  }
  createTree(user, container, delegate, renderers, options) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};
    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  asTreeElement(node, viewStateContext) {
    return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));
  }
  updateOptions(options = {}) {
    this.tree.updateOptions(options);
  }
  render(node, viewStateContext) {
    if (!this.identityProvider) {
      return super.render(node, viewStateContext);
    }
    const getId = (element) => this.identityProvider.getId(element).toString();
    const getUncompressedIds = (nodes) => {
      const result = new Set();
      for (const node2 of nodes) {
        const compressedNode = this.tree.getCompressedTreeNode(node2 === this.root ? null : node2);
        if (!compressedNode.element) {
          continue;
        }
        for (const node3 of compressedNode.element.elements) {
          result.add(getId(node3.element));
        }
      }
      return result;
    };
    const oldSelection = getUncompressedIds(this.tree.getSelection());
    const oldFocus = getUncompressedIds(this.tree.getFocus());
    super.render(node, viewStateContext);
    const selection = this.getSelection();
    let didChangeSelection = false;
    const focus = this.getFocus();
    let didChangeFocus = false;
    const visit = (node2) => {
      const compressedNode = node2.element;
      if (compressedNode) {
        for (let i = 0; i < compressedNode.elements.length; i++) {
          const id = getId(compressedNode.elements[i].element);
          const element = compressedNode.elements[compressedNode.elements.length - 1].element;
          if (oldSelection.has(id) && selection.indexOf(element) === -1) {
            selection.push(element);
            didChangeSelection = true;
          }
          if (oldFocus.has(id) && focus.indexOf(element) === -1) {
            focus.push(element);
            didChangeFocus = true;
          }
        }
      }
      node2.children.forEach(visit);
    };
    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));
    if (didChangeSelection) {
      this.setSelection(selection);
    }
    if (didChangeFocus) {
      this.setFocus(focus);
    }
  }
  processChildren(children) {
    if (this.filter) {
      children = Iterable.filter(children, (e) => {
        const result = this.filter.filter(e, 1);
        const visibility = getVisibility(result);
        if (visibility === 2) {
          throw new Error("Recursive tree visibility not supported in async data compressed trees");
        }
        return visibility === 1;
      });
    }
    return super.processChildren(children);
  }
};
function getVisibility(filterResult) {
  if (typeof filterResult === "boolean") {
    return filterResult ? 1 : 0;
  } else if (isFilterResult(filterResult)) {
    return getVisibleState(filterResult.visibility);
  } else {
    return getVisibleState(filterResult);
  }
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/dataTree.js
var DataTree = class extends AbstractTree {
  constructor(user, container, delegate, renderers, dataSource, options = {}) {
    super(user, container, delegate, renderers, options);
    this.user = user;
    this.dataSource = dataSource;
    this.identityProvider = options.identityProvider;
  }
  createModel(user, view, options) {
    return new ObjectTreeModel(user, view, options);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/table/table.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.css";
var defaultStyles = {
  separatorBorder: Color.transparent
};
var ViewItem = class {
  constructor(container, view, size, disposable) {
    this.container = container;
    this.view = view;
    this.disposable = disposable;
    this._cachedVisibleSize = void 0;
    if (typeof size === "number") {
      this._size = size;
      this._cachedVisibleSize = void 0;
      container.classList.add("visible");
    } else {
      this._size = 0;
      this._cachedVisibleSize = size.cachedVisibleSize;
    }
  }
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize === "undefined";
  }
  setVisible(visible, size) {
    if (visible === this.visible) {
      return;
    }
    if (visible) {
      this.size = clamp(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);
      this._cachedVisibleSize = void 0;
    } else {
      this._cachedVisibleSize = typeof size === "number" ? size : this.size;
      this.size = 0;
    }
    this.container.classList.toggle("visible", visible);
    if (this.view.setVisible) {
      this.view.setVisible(visible);
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(enabled) {
    this.container.style.pointerEvents = enabled ? "" : "none";
  }
  layout(offset, layoutContext) {
    this.layoutContainer(offset);
    this.view.layout(this.size, offset, layoutContext);
  }
  dispose() {
    this.disposable.dispose();
    return this.view;
  }
};
var VerticalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.top = `${offset}px`;
    this.container.style.height = `${this.size}px`;
  }
};
var HorizontalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.left = `${offset}px`;
    this.container.style.width = `${this.size}px`;
  }
};
var State;
(function(State2) {
  State2[State2["Idle"] = 0] = "Idle";
  State2[State2["Busy"] = 1] = "Busy";
})(State || (State = {}));
var Sizing;
(function(Sizing2) {
  Sizing2.Distribute = { type: "distribute" };
  function Split(index) {
    return { type: "split", index };
  }
  Sizing2.Split = Split;
  function Invisible(cachedVisibleSize) {
    return { type: "invisible", cachedVisibleSize };
  }
  Sizing2.Invisible = Invisible;
})(Sizing || (Sizing = {}));
var SplitView = class extends Disposable {
  constructor(container, options = {}) {
    var _a6, _b;
    super();
    this.size = 0;
    this.contentSize = 0;
    this.proportions = void 0;
    this.viewItems = [];
    this.sashItems = [];
    this.state = State.Idle;
    this._onDidSashChange = this._register(new Emitter());
    this.onDidSashChange = this._onDidSashChange.event;
    this._onDidSashReset = this._register(new Emitter());
    this._startSnappingEnabled = true;
    this._endSnappingEnabled = true;
    this.orientation = isUndefined(options.orientation) ? 0 : options.orientation;
    this.inverseAltBehavior = !!options.inverseAltBehavior;
    this.proportionalLayout = isUndefined(options.proportionalLayout) ? true : !!options.proportionalLayout;
    this.getSashOrthogonalSize = options.getSashOrthogonalSize;
    this.el = document.createElement("div");
    this.el.classList.add("monaco-split-view2");
    this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal");
    container.appendChild(this.el);
    this.sashContainer = append(this.el, $(".sash-container"));
    this.viewContainer = $(".split-view-container");
    this.scrollable = new Scrollable(125, scheduleAtNextAnimationFrame);
    this.scrollableElement = this._register(new SmoothScrollableElement(this.viewContainer, {
      vertical: this.orientation === 0 ? (_a6 = options.scrollbarVisibility) !== null && _a6 !== void 0 ? _a6 : 1 : 2,
      horizontal: this.orientation === 1 ? (_b = options.scrollbarVisibility) !== null && _b !== void 0 ? _b : 1 : 2
    }, this.scrollable));
    this.onDidScroll = this.scrollableElement.onScroll;
    this._register(this.onDidScroll((e) => {
      this.viewContainer.scrollTop = e.scrollTop;
      this.viewContainer.scrollLeft = e.scrollLeft;
    }));
    append(this.el, this.scrollableElement.getDomNode());
    this.style(options.styles || defaultStyles);
    if (options.descriptor) {
      this.size = options.descriptor.size;
      options.descriptor.views.forEach((viewDescriptor, index) => {
        const sizing = isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : { type: "invisible", cachedVisibleSize: viewDescriptor.size };
        const view = viewDescriptor.view;
        this.doAddView(view, sizing, index, true);
      });
      this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      this.saveProportions();
    }
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalStartSash = sash;
    }
    this._orthogonalStartSash = sash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalEndSash = sash;
    }
    this._orthogonalEndSash = sash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(startSnappingEnabled) {
    if (this._startSnappingEnabled === startSnappingEnabled) {
      return;
    }
    this._startSnappingEnabled = startSnappingEnabled;
    this.updateSashEnablement();
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(endSnappingEnabled) {
    if (this._endSnappingEnabled === endSnappingEnabled) {
      return;
    }
    this._endSnappingEnabled = endSnappingEnabled;
    this.updateSashEnablement();
  }
  style(styles) {
    if (styles.separatorBorder.isTransparent()) {
      this.el.classList.remove("separator-border");
      this.el.style.removeProperty("--separator-border");
    } else {
      this.el.classList.add("separator-border");
      this.el.style.setProperty("--separator-border", styles.separatorBorder.toString());
    }
  }
  addView(view, size, index = this.viewItems.length, skipLayout) {
    this.doAddView(view, size, index, skipLayout);
  }
  layout(size, layoutContext) {
    const previousSize = Math.max(this.size, this.contentSize);
    this.size = size;
    this.layoutContext = layoutContext;
    if (!this.proportions) {
      const indexes = range(this.viewItems.length);
      const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
      const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
      this.resize(this.viewItems.length - 1, size - previousSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    } else {
      for (let i = 0; i < this.viewItems.length; i++) {
        const item = this.viewItems[i];
        item.size = clamp(Math.round(this.proportions[i] * size), item.minimumSize, item.maximumSize);
      }
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  saveProportions() {
    if (this.proportionalLayout && this.contentSize > 0) {
      this.proportions = this.viewItems.map((i) => i.size / this.contentSize);
    }
  }
  onSashStart({ sash, start, alt }) {
    for (const item of this.viewItems) {
      item.enabled = false;
    }
    const index = this.sashItems.findIndex((item) => item.sash === sash);
    const disposable = combinedDisposable(addDisposableListener(document.body, "keydown", (e) => resetSashDragState(this.sashDragState.current, e.altKey)), addDisposableListener(document.body, "keyup", () => resetSashDragState(this.sashDragState.current, false)));
    const resetSashDragState = (start2, alt2) => {
      const sizes = this.viewItems.map((i) => i.size);
      let minDelta = Number.NEGATIVE_INFINITY;
      let maxDelta = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior) {
        alt2 = !alt2;
      }
      if (alt2) {
        const isLastSash = index === this.sashItems.length - 1;
        if (isLastSash) {
          const viewItem = this.viewItems[index];
          minDelta = (viewItem.minimumSize - viewItem.size) / 2;
          maxDelta = (viewItem.maximumSize - viewItem.size) / 2;
        } else {
          const viewItem = this.viewItems[index + 1];
          minDelta = (viewItem.size - viewItem.maximumSize) / 2;
          maxDelta = (viewItem.size - viewItem.minimumSize) / 2;
        }
      }
      let snapBefore;
      let snapAfter;
      if (!alt2) {
        const upIndexes = range(index, -1);
        const downIndexes = range(index + 1, this.viewItems.length);
        const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
        const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0);
        const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
        const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);
        const minDelta2 = Math.max(minDeltaUp, minDeltaDown);
        const maxDelta2 = Math.min(maxDeltaDown, maxDeltaUp);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        if (typeof snapBeforeIndex === "number") {
          const viewItem = this.viewItems[snapBeforeIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapBefore = {
            index: snapBeforeIndex,
            limitDelta: viewItem.visible ? minDelta2 - halfSize : minDelta2 + halfSize,
            size: viewItem.size
          };
        }
        if (typeof snapAfterIndex === "number") {
          const viewItem = this.viewItems[snapAfterIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapAfter = {
            index: snapAfterIndex,
            limitDelta: viewItem.visible ? maxDelta2 + halfSize : maxDelta2 - halfSize,
            size: viewItem.size
          };
        }
      }
      this.sashDragState = { start: start2, current: start2, index, sizes, minDelta, maxDelta, alt: alt2, snapBefore, snapAfter, disposable };
    };
    resetSashDragState(start, alt);
  }
  onSashChange({ current }) {
    const { index, start, sizes, alt, minDelta, maxDelta, snapBefore, snapAfter } = this.sashDragState;
    this.sashDragState.current = current;
    const delta = current - start;
    const newDelta = this.resize(index, delta, sizes, void 0, void 0, minDelta, maxDelta, snapBefore, snapAfter);
    if (alt) {
      const isLastSash = index === this.sashItems.length - 1;
      const newSizes = this.viewItems.map((i) => i.size);
      const viewItemIndex = isLastSash ? index : index + 1;
      const viewItem = this.viewItems[viewItemIndex];
      const newMinDelta = viewItem.size - viewItem.maximumSize;
      const newMaxDelta = viewItem.size - viewItem.minimumSize;
      const resizeIndex = isLastSash ? index - 1 : index + 1;
      this.resize(resizeIndex, -newDelta, newSizes, void 0, void 0, newMinDelta, newMaxDelta);
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  onSashEnd(index) {
    this._onDidSashChange.fire(index);
    this.sashDragState.disposable.dispose();
    this.saveProportions();
    for (const item of this.viewItems) {
      item.enabled = true;
    }
  }
  onViewChange(item, size) {
    const index = this.viewItems.indexOf(item);
    if (index < 0 || index >= this.viewItems.length) {
      return;
    }
    size = typeof size === "number" ? size : item.size;
    size = clamp(size, item.minimumSize, item.maximumSize);
    if (this.inverseAltBehavior && index > 0) {
      this.resize(index - 1, Math.floor((item.size - size) / 2));
      this.distributeEmptySpace();
      this.layoutViews();
    } else {
      item.size = size;
      this.relayout([index], void 0);
    }
  }
  resizeView(index, size) {
    if (this.state !== State.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State.Busy;
    if (index < 0 || index >= this.viewItems.length) {
      return;
    }
    const indexes = range(this.viewItems.length).filter((i) => i !== index);
    const lowPriorityIndexes = [...indexes.filter((i) => this.viewItems[i].priority === 1), index];
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    const item = this.viewItems[index];
    size = Math.round(size);
    size = clamp(size, item.minimumSize, Math.min(item.maximumSize, this.size));
    item.size = size;
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
    this.state = State.Idle;
  }
  distributeViewSizes() {
    const flexibleViewItems = [];
    let flexibleSize = 0;
    for (const item of this.viewItems) {
      if (item.maximumSize - item.minimumSize > 0) {
        flexibleViewItems.push(item);
        flexibleSize += item.size;
      }
    }
    const size = Math.floor(flexibleSize / flexibleViewItems.length);
    for (const item of flexibleViewItems) {
      item.size = clamp(size, item.minimumSize, item.maximumSize);
    }
    const indexes = range(this.viewItems.length);
    const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
  }
  getViewSize(index) {
    if (index < 0 || index >= this.viewItems.length) {
      return -1;
    }
    return this.viewItems[index].size;
  }
  doAddView(view, size, index = this.viewItems.length, skipLayout) {
    if (this.state !== State.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State.Busy;
    const container = $(".split-view-view");
    if (index === this.viewItems.length) {
      this.viewContainer.appendChild(container);
    } else {
      this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));
    }
    const onChangeDisposable = view.onDidChange((size2) => this.onViewChange(item, size2));
    const containerDisposable = toDisposable(() => this.viewContainer.removeChild(container));
    const disposable = combinedDisposable(onChangeDisposable, containerDisposable);
    let viewSize;
    if (typeof size === "number") {
      viewSize = size;
    } else if (size.type === "split") {
      viewSize = this.getViewSize(size.index) / 2;
    } else if (size.type === "invisible") {
      viewSize = { cachedVisibleSize: size.cachedVisibleSize };
    } else {
      viewSize = view.minimumSize;
    }
    const item = this.orientation === 0 ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);
    this.viewItems.splice(index, 0, item);
    if (this.viewItems.length > 1) {
      let opts = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
      const sash = this.orientation === 0 ? new Sash(this.sashContainer, { getHorizontalSashTop: (s) => this.getSashPosition(s), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 1 })) : new Sash(this.sashContainer, { getVerticalSashLeft: (s) => this.getSashPosition(s), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 0 }));
      const sashEventMapper = this.orientation === 0 ? (e) => ({ sash, start: e.startY, current: e.currentY, alt: e.altKey }) : (e) => ({ sash, start: e.startX, current: e.currentX, alt: e.altKey });
      const onStart = Event.map(sash.onDidStart, sashEventMapper);
      const onStartDisposable = onStart(this.onSashStart, this);
      const onChange = Event.map(sash.onDidChange, sashEventMapper);
      const onChangeDisposable2 = onChange(this.onSashChange, this);
      const onEnd = Event.map(sash.onDidEnd, () => this.sashItems.findIndex((item2) => item2.sash === sash));
      const onEndDisposable = onEnd(this.onSashEnd, this);
      const onDidResetDisposable = sash.onDidReset(() => {
        const index2 = this.sashItems.findIndex((item2) => item2.sash === sash);
        const upIndexes = range(index2, -1);
        const downIndexes = range(index2 + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        if (typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible) {
          return;
        }
        if (typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible) {
          return;
        }
        this._onDidSashReset.fire(index2);
      });
      const disposable2 = combinedDisposable(onStartDisposable, onChangeDisposable2, onEndDisposable, onDidResetDisposable, sash);
      const sashItem = { sash, disposable: disposable2 };
      this.sashItems.splice(index - 1, 0, sashItem);
    }
    container.appendChild(view.element);
    let highPriorityIndexes;
    if (typeof size !== "number" && size.type === "split") {
      highPriorityIndexes = [size.index];
    }
    if (!skipLayout) {
      this.relayout([index], highPriorityIndexes);
    }
    this.state = State.Idle;
    if (!skipLayout && typeof size !== "number" && size.type === "distribute") {
      this.distributeViewSizes();
    }
  }
  relayout(lowPriorityIndexes, highPriorityIndexes) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    this.resize(this.viewItems.length - 1, this.size - contentSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    this.distributeEmptySpace();
    this.layoutViews();
    this.saveProportions();
  }
  resize(index, delta, sizes = this.viewItems.map((i) => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {
    if (index < 0 || index >= this.viewItems.length) {
      return 0;
    }
    const upIndexes = range(index, -1);
    const downIndexes = range(index + 1, this.viewItems.length);
    if (highPriorityIndexes) {
      for (const index2 of highPriorityIndexes) {
        pushToStart(upIndexes, index2);
        pushToStart(downIndexes, index2);
      }
    }
    if (lowPriorityIndexes) {
      for (const index2 of lowPriorityIndexes) {
        pushToEnd(upIndexes, index2);
        pushToEnd(downIndexes, index2);
      }
    }
    const upItems = upIndexes.map((i) => this.viewItems[i]);
    const upSizes = upIndexes.map((i) => sizes[i]);
    const downItems = downIndexes.map((i) => this.viewItems[i]);
    const downSizes = downIndexes.map((i) => sizes[i]);
    const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
    const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);
    const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
    const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);
    const minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);
    const maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);
    let snapped = false;
    if (snapBefore) {
      const snapView = this.viewItems[snapBefore.index];
      const visible = delta >= snapBefore.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapBefore.size);
    }
    if (!snapped && snapAfter) {
      const snapView = this.viewItems[snapAfter.index];
      const visible = delta < snapAfter.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapAfter.size);
    }
    if (snapped) {
      return this.resize(index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);
    }
    delta = clamp(delta, minDelta, maxDelta);
    for (let i = 0, deltaUp = delta; i < upItems.length; i++) {
      const item = upItems[i];
      const size = clamp(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);
      const viewDelta = size - upSizes[i];
      deltaUp -= viewDelta;
      item.size = size;
    }
    for (let i = 0, deltaDown = delta; i < downItems.length; i++) {
      const item = downItems[i];
      const size = clamp(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);
      const viewDelta = size - downSizes[i];
      deltaDown += viewDelta;
      item.size = size;
    }
    return delta;
  }
  distributeEmptySpace(lowPriorityIndex) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let emptyDelta = this.size - contentSize;
    const indexes = range(this.viewItems.length - 1, -1);
    const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    for (const index of highPriorityIndexes) {
      pushToStart(indexes, index);
    }
    for (const index of lowPriorityIndexes) {
      pushToEnd(indexes, index);
    }
    if (typeof lowPriorityIndex === "number") {
      pushToEnd(indexes, lowPriorityIndex);
    }
    for (let i = 0; emptyDelta !== 0 && i < indexes.length; i++) {
      const item = this.viewItems[indexes[i]];
      const size = clamp(item.size + emptyDelta, item.minimumSize, item.maximumSize);
      const viewDelta = size - item.size;
      emptyDelta -= viewDelta;
      item.size = size;
    }
  }
  layoutViews() {
    this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let offset = 0;
    for (const viewItem of this.viewItems) {
      viewItem.layout(offset, this.layoutContext);
      offset += viewItem.size;
    }
    this.sashItems.forEach((item) => item.sash.layout());
    this.updateSashEnablement();
    this.updateScrollableElement();
  }
  updateScrollableElement() {
    if (this.orientation === 0) {
      this.scrollableElement.setScrollDimensions({
        height: this.size,
        scrollHeight: this.contentSize
      });
    } else {
      this.scrollableElement.setScrollDimensions({
        width: this.size,
        scrollWidth: this.contentSize
      });
    }
  }
  updateSashEnablement() {
    let previous = false;
    const collapsesDown = this.viewItems.map((i) => previous = i.size - i.minimumSize > 0 || previous);
    previous = false;
    const expandsDown = this.viewItems.map((i) => previous = i.maximumSize - i.size > 0 || previous);
    const reverseViews = [...this.viewItems].reverse();
    previous = false;
    const collapsesUp = reverseViews.map((i) => previous = i.size - i.minimumSize > 0 || previous).reverse();
    previous = false;
    const expandsUp = reverseViews.map((i) => previous = i.maximumSize - i.size > 0 || previous).reverse();
    let position = 0;
    for (let index = 0; index < this.sashItems.length; index++) {
      const { sash } = this.sashItems[index];
      const viewItem = this.viewItems[index];
      position += viewItem.size;
      const min = !(collapsesDown[index] && expandsUp[index + 1]);
      const max = !(expandsDown[index] && collapsesUp[index + 1]);
      if (min && max) {
        const upIndexes = range(index, -1);
        const downIndexes = range(index + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        const snappedBefore = typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible;
        const snappedAfter = typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible;
        if (snappedBefore && collapsesUp[index] && (position > 0 || this.startSnappingEnabled)) {
          sash.state = 1;
        } else if (snappedAfter && collapsesDown[index] && (position < this.contentSize || this.endSnappingEnabled)) {
          sash.state = 2;
        } else {
          sash.state = 0;
        }
      } else if (min && !max) {
        sash.state = 1;
      } else if (!min && max) {
        sash.state = 2;
      } else {
        sash.state = 3;
      }
    }
  }
  getSashPosition(sash) {
    let position = 0;
    for (let i = 0; i < this.sashItems.length; i++) {
      position += this.viewItems[i].size;
      if (this.sashItems[i].sash === sash) {
        return position;
      }
    }
    return 0;
  }
  findFirstSnapIndex(indexes) {
    for (const index of indexes) {
      const viewItem = this.viewItems[index];
      if (!viewItem.visible) {
        continue;
      }
      if (viewItem.snap) {
        return index;
      }
    }
    for (const index of indexes) {
      const viewItem = this.viewItems[index];
      if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {
        return void 0;
      }
      if (!viewItem.visible && viewItem.snap) {
        return index;
      }
    }
    return void 0;
  }
  dispose() {
    super.dispose();
    this.viewItems.forEach((i) => i.dispose());
    this.viewItems = [];
    this.sashItems.forEach((i) => i.disposable.dispose());
    this.sashItems = [];
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js
var TableListRenderer = class {
  constructor(columns, renderers, getColumnSize) {
    this.columns = columns;
    this.getColumnSize = getColumnSize;
    this.templateId = TableListRenderer.TemplateId;
    this.renderedTemplates = new Set();
    const rendererMap = new Map(renderers.map((r) => [r.templateId, r]));
    this.renderers = [];
    for (const column of columns) {
      const renderer = rendererMap.get(column.templateId);
      if (!renderer) {
        throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);
      }
      this.renderers.push(renderer);
    }
  }
  renderTemplate(container) {
    const rowContainer = append(container, $(".monaco-table-tr"));
    const cellContainers = [];
    const cellTemplateData = [];
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      const cellContainer = append(rowContainer, $(".monaco-table-td", { "data-col-index": i }));
      cellContainer.style.width = `${this.getColumnSize(i)}px`;
      cellContainers.push(cellContainer);
      cellTemplateData.push(renderer.renderTemplate(cellContainer));
    }
    const result = { container, cellContainers, cellTemplateData };
    this.renderedTemplates.add(result);
    return result;
  }
  renderElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const column = this.columns[i];
      const cell = column.project(element);
      const renderer = this.renderers[i];
      renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);
    }
  }
  disposeElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      if (renderer.disposeElement) {
        const column = this.columns[i];
        const cell = column.project(element);
        renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);
      }
    }
  }
  disposeTemplate(templateData) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      renderer.disposeTemplate(templateData.cellTemplateData[i]);
    }
    clearNode(templateData.container);
    this.renderedTemplates.delete(templateData);
  }
  layoutColumn(index, size) {
    for (const { cellContainers } of this.renderedTemplates) {
      cellContainers[index].style.width = `${size}px`;
    }
  }
};
TableListRenderer.TemplateId = "row";
function asListVirtualDelegate(delegate) {
  return {
    getHeight(row) {
      return delegate.getHeight(row);
    },
    getTemplateId() {
      return TableListRenderer.TemplateId;
    }
  };
}
var ColumnHeader = class {
  constructor(column, index) {
    this.column = column;
    this.index = index;
    this._onDidLayout = new Emitter();
    this.onDidLayout = this._onDidLayout.event;
    this.element = $(".monaco-table-th", { "data-col-index": index, title: column.tooltip }, column.label);
  }
  get minimumSize() {
    var _a6;
    return (_a6 = this.column.minimumWidth) !== null && _a6 !== void 0 ? _a6 : 120;
  }
  get maximumSize() {
    var _a6;
    return (_a6 = this.column.maximumWidth) !== null && _a6 !== void 0 ? _a6 : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var _a6;
    return (_a6 = this.column.onDidChangeWidthConstraints) !== null && _a6 !== void 0 ? _a6 : Event.None;
  }
  layout(size) {
    this._onDidLayout.fire([this.index, size]);
  }
};
var Table = class {
  constructor(user, container, virtualDelegate, columns, renderers, _options) {
    this.virtualDelegate = virtualDelegate;
    this.domId = `table_id_${++Table.InstanceCount}`;
    this.cachedHeight = 0;
    this.domNode = append(container, $(`.monaco-table.${this.domId}`));
    const headers = columns.map((c, i) => new ColumnHeader(c, i));
    const descriptor = {
      size: headers.reduce((a, b) => a + b.column.weight, 0),
      views: headers.map((view) => ({ size: view.column.weight, view }))
    };
    this.splitview = new SplitView(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor
    });
    this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;
    this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;
    const renderer = new TableListRenderer(columns, renderers, (i) => this.splitview.getViewSize(i));
    this.list = new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options);
    this.columnLayoutDisposable = Event.any(...headers.map((h) => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size));
    this.styleElement = createStyleSheet(this.domNode);
    this.style({});
  }
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  updateOptions(options) {
    this.list.updateOptions(options);
  }
  splice(start, deleteCount, elements = []) {
    this.list.splice(start, deleteCount, elements);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(styles) {
    const content = [];
    content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`);
    this.styleElement.textContent = content.join("\n");
    this.list.style(styles);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.splitview.dispose();
    this.list.dispose();
    this.columnLayoutDisposable.dispose();
  }
};
Table.InstanceCount = 0;

// node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IListService = createDecorator("listService");
var ListService = class ListService2 {
  constructor(_themeService) {
    this._themeService = _themeService;
    this.disposables = new DisposableStore();
    this.lists = [];
    this._lastFocusedWidget = void 0;
    this._hasCreatedStyleController = false;
  }
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  register(widget, extraContextKeys) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = true;
      const styleController = new DefaultStyleController(createStyleSheet(), "");
      this.disposables.add(attachListStyler(styleController, this._themeService));
    }
    if (this.lists.some((l) => l.widget === widget)) {
      throw new Error("Cannot register the same widget multiple times");
    }
    const registeredList = { widget, extraContextKeys };
    this.lists.push(registeredList);
    if (widget.getHTMLElement() === document.activeElement) {
      this._lastFocusedWidget = widget;
    }
    return combinedDisposable(widget.onDidFocus(() => this._lastFocusedWidget = widget), toDisposable(() => this.lists.splice(this.lists.indexOf(registeredList), 1)), widget.onDidDispose(() => {
      this.lists = this.lists.filter((l) => l !== registeredList);
      if (this._lastFocusedWidget === widget) {
        this._lastFocusedWidget = void 0;
      }
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
ListService = __decorate13([
  __param12(0, IThemeService)
], ListService);
var RawWorkbenchListFocusContextKey = new RawContextKey("listFocus", true);
var WorkbenchListSupportsMultiSelectContextKey = new RawContextKey("listSupportsMultiselect", true);
var WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey));
var WorkbenchListHasSelectionOrFocus = new RawContextKey("listHasSelectionOrFocus", false);
var WorkbenchListDoubleSelection = new RawContextKey("listDoubleSelection", false);
var WorkbenchListMultiSelection = new RawContextKey("listMultiSelection", false);
var WorkbenchListSelectionNavigation = new RawContextKey("listSelectionNavigation", false);
var WorkbenchListAutomaticKeyboardNavigationKey = "listAutomaticKeyboardNavigation";
function createScopedContextKeyService(contextKeyService, widget) {
  const result = contextKeyService.createScoped(widget.getHTMLElement());
  RawWorkbenchListFocusContextKey.bindTo(result);
  return result;
}
var multiSelectModifierSettingKey = "workbench.list.multiSelectModifier";
var openModeSettingKey = "workbench.list.openMode";
var horizontalScrollingKey = "workbench.list.horizontalScrolling";
var keyboardNavigationSettingKey = "workbench.list.keyboardNavigation";
var automaticKeyboardNavigationSettingKey = "workbench.list.automaticKeyboardNavigation";
var treeIndentKey = "workbench.tree.indent";
var treeRenderIndentGuidesKey = "workbench.tree.renderIndentGuides";
var listSmoothScrolling = "workbench.list.smoothScrolling";
var mouseWheelScrollSensitivityKey = "workbench.list.mouseWheelScrollSensitivity";
var fastScrollSensitivityKey = "workbench.list.fastScrollSensitivity";
var treeExpandMode = "workbench.tree.expandMode";
function useAltAsMultipleSelectionModifier(configurationService) {
  return configurationService.getValue(multiSelectModifierSettingKey) === "alt";
}
var MultipleSelectionController = class extends Disposable {
  constructor(configurationService) {
    super();
    this.configurationService = configurationService;
    this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(this.configurationService);
      }
    }));
  }
  isSelectionSingleChangeEvent(event) {
    if (this.useAltAsMultipleSelectionModifier) {
      return event.browserEvent.altKey;
    }
    return isSelectionSingleChangeEvent(event);
  }
  isSelectionRangeChangeEvent(event) {
    return isSelectionRangeChangeEvent(event);
  }
};
function toWorkbenchListOptions(options, configurationService, keybindingService) {
  var _a6;
  const disposables = new DisposableStore();
  const result = Object.assign(Object.assign({}, options), { keyboardNavigationDelegate: { mightProducePrintableCharacter(e) {
    return keybindingService.mightProducePrintableCharacter(e);
  } }, smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), mouseWheelScrollSensitivity: configurationService.getValue(mouseWheelScrollSensitivityKey), fastScrollSensitivity: configurationService.getValue(fastScrollSensitivityKey), multipleSelectionController: (_a6 = options.multipleSelectionController) !== null && _a6 !== void 0 ? _a6 : disposables.add(new MultipleSelectionController(configurationService)) });
  return [result, disposables];
}
var WorkbenchList = class WorkbenchList2 extends List {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {
    const horizontalScrolling = typeof options.horizontalScrolling !== "undefined" ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
    super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.themeService = themeService;
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options.selectionNavigation));
    this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.horizontalScrolling = options.horizontalScrolling;
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    this.disposables.add(this.onDidChangeSelection(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.listMultiSelection.set(selection.length > 1);
        this.listDoubleSelection.set(selection.length === 2);
      });
    }));
    this.disposables.add(this.onDidChangeFocus(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }));
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options2 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options2 = Object.assign(Object.assign({}, options2), { horizontalScrolling: horizontalScrolling2 });
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options2 = Object.assign(Object.assign({}, options2), { smoothScrolling });
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { mouseWheelScrollSensitivity });
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { fastScrollSensitivity });
      }
      if (Object.keys(options2).length > 0) {
        this.updateOptions(options2);
      }
    }));
    this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));
    this.disposables.add(this.navigator);
  }
  updateOptions(options) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    if (options.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._styler = attachListStyler(this, this.themeService, styles);
  }
  dispose() {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    super.dispose();
  }
};
WorkbenchList = __decorate13([
  __param12(5, IContextKeyService),
  __param12(6, IListService),
  __param12(7, IThemeService),
  __param12(8, IConfigurationService),
  __param12(9, IKeybindingService)
], WorkbenchList);
var WorkbenchPagedList = class WorkbenchPagedList2 extends PagedList {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {
    const horizontalScrolling = typeof options.horizontalScrolling !== "undefined" ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
    super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));
    this.disposables = new DisposableStore();
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.themeService = themeService;
    this.horizontalScrolling = options.horizontalScrolling;
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options.selectionNavigation));
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    if (options.overrideStyles) {
      this.disposables.add(attachListStyler(this, themeService, options.overrideStyles));
    }
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options2 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options2 = Object.assign(Object.assign({}, options2), { horizontalScrolling: horizontalScrolling2 });
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options2 = Object.assign(Object.assign({}, options2), { smoothScrolling });
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { mouseWheelScrollSensitivity });
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { fastScrollSensitivity });
      }
      if (Object.keys(options2).length > 0) {
        this.updateOptions(options2);
      }
    }));
    this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));
    this.disposables.add(this.navigator);
  }
  updateOptions(options) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    if (options.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._styler = attachListStyler(this, this.themeService, styles);
  }
  dispose() {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this.disposables.dispose();
    super.dispose();
  }
};
WorkbenchPagedList = __decorate13([
  __param12(5, IContextKeyService),
  __param12(6, IListService),
  __param12(7, IThemeService),
  __param12(8, IConfigurationService),
  __param12(9, IKeybindingService)
], WorkbenchPagedList);
var WorkbenchTable = class WorkbenchTable2 extends Table {
  constructor(user, container, delegate, columns, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {
    const horizontalScrolling = typeof options.horizontalScrolling !== "undefined" ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
    super(user, container, delegate, columns, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));
    this.disposables = new DisposableStore();
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.themeService = themeService;
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options.selectionNavigation));
    this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.horizontalScrolling = options.horizontalScrolling;
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    this.disposables.add(this.onDidChangeSelection(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.listMultiSelection.set(selection.length > 1);
        this.listDoubleSelection.set(selection.length === 2);
      });
    }));
    this.disposables.add(this.onDidChangeFocus(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }));
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options2 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options2 = Object.assign(Object.assign({}, options2), { horizontalScrolling: horizontalScrolling2 });
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options2 = Object.assign(Object.assign({}, options2), { smoothScrolling });
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { mouseWheelScrollSensitivity });
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options2 = Object.assign(Object.assign({}, options2), { fastScrollSensitivity });
      }
      if (Object.keys(options2).length > 0) {
        this.updateOptions(options2);
      }
    }));
    this.navigator = new TableResourceNavigator(this, Object.assign({ configurationService }, options));
    this.disposables.add(this.navigator);
  }
  updateOptions(options) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    if (options.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._styler = attachListStyler(this, this.themeService, styles);
  }
  dispose() {
    var _a6;
    (_a6 = this._styler) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this.disposables.dispose();
    super.dispose();
  }
};
WorkbenchTable = __decorate13([
  __param12(6, IContextKeyService),
  __param12(7, IListService),
  __param12(8, IThemeService),
  __param12(9, IConfigurationService),
  __param12(10, IKeybindingService)
], WorkbenchTable);
var ResourceNavigator = class extends Disposable {
  constructor(widget, options) {
    var _a6;
    super();
    this.widget = widget;
    this._onDidOpen = this._register(new Emitter());
    this.onDidOpen = this._onDidOpen.event;
    this._register(Event.filter(this.widget.onDidChangeSelection, (e) => e.browserEvent instanceof KeyboardEvent)((e) => this.onSelectionFromKeyboard(e)));
    this._register(this.widget.onPointer((e) => this.onPointer(e.element, e.browserEvent)));
    this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.element, e.browserEvent)));
    if (typeof (options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== "boolean" && (options === null || options === void 0 ? void 0 : options.configurationService)) {
      this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
      this._register(options === null || options === void 0 ? void 0 : options.configurationService.onDidChangeConfiguration(() => {
        this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
      }));
    } else {
      this.openOnSingleClick = (_a6 = options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== null && _a6 !== void 0 ? _a6 : true;
    }
  }
  onSelectionFromKeyboard(event) {
    if (event.elements.length !== 1) {
      return;
    }
    const selectionKeyboardEvent = event.browserEvent;
    const preserveFocus = typeof selectionKeyboardEvent.preserveFocus === "boolean" ? selectionKeyboardEvent.preserveFocus : true;
    const pinned = typeof selectionKeyboardEvent.pinned === "boolean" ? selectionKeyboardEvent.pinned : !preserveFocus;
    const sideBySide = false;
    this._open(this.getSelectedElement(), preserveFocus, pinned, sideBySide, event.browserEvent);
  }
  onPointer(element, browserEvent) {
    if (!this.openOnSingleClick) {
      return;
    }
    const isDoubleClick = browserEvent.detail === 2;
    if (isDoubleClick) {
      return;
    }
    const isMiddleClick = browserEvent.button === 1;
    const preserveFocus = true;
    const pinned = isMiddleClick;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(element, preserveFocus, pinned, sideBySide, browserEvent);
  }
  onMouseDblClick(element, browserEvent) {
    if (!browserEvent) {
      return;
    }
    const target = browserEvent.target;
    const onTwistie = target.classList.contains("monaco-tl-twistie") || target.classList.contains("monaco-icon-label") && target.classList.contains("folder-icon") && browserEvent.offsetX < 16;
    if (onTwistie) {
      return;
    }
    const preserveFocus = false;
    const pinned = true;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(element, preserveFocus, pinned, sideBySide, browserEvent);
  }
  _open(element, preserveFocus, pinned, sideBySide, browserEvent) {
    if (!element) {
      return;
    }
    this._onDidOpen.fire({
      editorOptions: {
        preserveFocus,
        pinned,
        revealIfVisible: true
      },
      sideBySide,
      element,
      browserEvent
    });
  }
};
var ListResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options) {
    super(widget, options);
    this.widget = widget;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
};
var TableResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options) {
    super(widget, options);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
};
var TreeResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options) {
    super(widget, options);
  }
  getSelectedElement() {
    var _a6;
    return (_a6 = this.widget.getSelection()[0]) !== null && _a6 !== void 0 ? _a6 : void 0;
  }
};
function createKeyboardNavigationEventFilter(container, keybindingService) {
  let inChord = false;
  return (event) => {
    if (inChord) {
      inChord = false;
      return false;
    }
    const result = keybindingService.softDispatch(event, container);
    if (result && result.enterChord) {
      inChord = true;
      return false;
    }
    inChord = false;
    return true;
  };
}
var WorkbenchObjectTree = class WorkbenchObjectTree2 extends ObjectTree {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options) {
    super.updateOptions(options);
    this.internals.updateOptions(options);
  }
};
WorkbenchObjectTree = __decorate13([
  __param12(5, IContextKeyService),
  __param12(6, IListService),
  __param12(7, IThemeService),
  __param12(8, IConfigurationService),
  __param12(9, IKeybindingService),
  __param12(10, IAccessibilityService)
], WorkbenchObjectTree);
var WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree2 extends CompressibleObjectTree {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
    this.internals.updateOptions(options);
  }
};
WorkbenchCompressibleObjectTree = __decorate13([
  __param12(5, IContextKeyService),
  __param12(6, IListService),
  __param12(7, IThemeService),
  __param12(8, IConfigurationService),
  __param12(9, IKeybindingService),
  __param12(10, IAccessibilityService)
], WorkbenchCompressibleObjectTree);
var WorkbenchDataTree = class WorkbenchDataTree2 extends DataTree {
  constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
    this.internals.updateOptions(options);
  }
};
WorkbenchDataTree = __decorate13([
  __param12(6, IContextKeyService),
  __param12(7, IListService),
  __param12(8, IThemeService),
  __param12(9, IConfigurationService),
  __param12(10, IKeybindingService),
  __param12(11, IAccessibilityService)
], WorkbenchDataTree);
var WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree2 extends AsyncDataTree {
  constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
    this.internals.updateOptions(options);
  }
};
WorkbenchAsyncDataTree = __decorate13([
  __param12(6, IContextKeyService),
  __param12(7, IListService),
  __param12(8, IThemeService),
  __param12(9, IConfigurationService),
  __param12(10, IKeybindingService),
  __param12(11, IAccessibilityService)
], WorkbenchAsyncDataTree);
var WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree2 extends CompressibleAsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options) {
    super.updateOptions(options);
    this.internals.updateOptions(options);
  }
};
WorkbenchCompressibleAsyncDataTree = __decorate13([
  __param12(7, IContextKeyService),
  __param12(8, IListService),
  __param12(9, IThemeService),
  __param12(10, IConfigurationService),
  __param12(11, IKeybindingService),
  __param12(12, IAccessibilityService)
], WorkbenchCompressibleAsyncDataTree);
function workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService) {
  var _a6;
  const getAutomaticKeyboardNavigation = () => {
    let automaticKeyboardNavigation = Boolean(contextKeyService.getContextKeyValue(WorkbenchListAutomaticKeyboardNavigationKey));
    if (automaticKeyboardNavigation) {
      automaticKeyboardNavigation = Boolean(configurationService.getValue(automaticKeyboardNavigationSettingKey));
    }
    return automaticKeyboardNavigation;
  };
  const accessibilityOn = accessibilityService.isScreenReaderOptimized();
  const keyboardNavigation = options.simpleKeyboardNavigation || accessibilityOn ? "simple" : configurationService.getValue(keyboardNavigationSettingKey);
  const horizontalScrolling = options.horizontalScrolling !== void 0 ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
  const [workbenchListOptions, disposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
  const additionalScrollHeight = options.additionalScrollHeight;
  return {
    getAutomaticKeyboardNavigation,
    disposable,
    options: Object.assign(Object.assign({
      keyboardSupport: false
    }, workbenchListOptions), { indent: typeof configurationService.getValue(treeIndentKey) === "number" ? configurationService.getValue(treeIndentKey) : void 0, renderIndentGuides: configurationService.getValue(treeRenderIndentGuidesKey), smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), automaticKeyboardNavigation: getAutomaticKeyboardNavigation(), simpleKeyboardNavigation: keyboardNavigation === "simple", filterOnType: keyboardNavigation === "filter", horizontalScrolling, keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(container, keybindingService), additionalScrollHeight, hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (_a6 = options.expandOnlyOnTwistieClick) !== null && _a6 !== void 0 ? _a6 : configurationService.getValue(treeExpandMode) === "doubleClick" })
  };
}
var WorkbenchTreeInternals = class WorkbenchTreeInternals2 {
  constructor(tree, options, getAutomaticKeyboardNavigation, overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService) {
    this.tree = tree;
    this.themeService = themeService;
    this.disposables = [];
    this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options.selectionNavigation));
    this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    const interestingContextKeys = new Set();
    interestingContextKeys.add(WorkbenchListAutomaticKeyboardNavigationKey);
    const updateKeyboardNavigation = () => {
      const accessibilityOn = accessibilityService.isScreenReaderOptimized();
      const keyboardNavigation = accessibilityOn ? "simple" : configurationService.getValue(keyboardNavigationSettingKey);
      tree.updateOptions({
        simpleKeyboardNavigation: keyboardNavigation === "simple",
        filterOnType: keyboardNavigation === "filter"
      });
    };
    this.updateStyleOverrides(overrideStyles);
    this.disposables.push(this.contextKeyService, listService.register(tree), tree.onDidChangeSelection(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.hasMultiSelection.set(selection.length > 1);
        this.hasDoubleSelection.set(selection.length === 2);
      });
    }), tree.onDidChangeFocus(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }), configurationService.onDidChangeConfiguration((e) => {
      let newOptions = {};
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      if (e.affectsConfiguration(treeIndentKey)) {
        const indent = configurationService.getValue(treeIndentKey);
        newOptions = Object.assign(Object.assign({}, newOptions), { indent });
      }
      if (e.affectsConfiguration(treeRenderIndentGuidesKey)) {
        const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);
        newOptions = Object.assign(Object.assign({}, newOptions), { renderIndentGuides });
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(!!configurationService.getValue(listSmoothScrolling));
        newOptions = Object.assign(Object.assign({}, newOptions), { smoothScrolling });
      }
      if (e.affectsConfiguration(keyboardNavigationSettingKey)) {
        updateKeyboardNavigation();
      }
      if (e.affectsConfiguration(automaticKeyboardNavigationSettingKey)) {
        newOptions = Object.assign(Object.assign({}, newOptions), { automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });
      }
      if (e.affectsConfiguration(horizontalScrollingKey) && options.horizontalScrolling === void 0) {
        const horizontalScrolling = Boolean(!!configurationService.getValue(horizontalScrollingKey));
        newOptions = Object.assign(Object.assign({}, newOptions), { horizontalScrolling });
      }
      if (e.affectsConfiguration(treeExpandMode) && options.expandOnlyOnTwistieClick === void 0) {
        newOptions = Object.assign(Object.assign({}, newOptions), { expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === "doubleClick" });
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        newOptions = Object.assign(Object.assign({}, newOptions), { mouseWheelScrollSensitivity });
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        newOptions = Object.assign(Object.assign({}, newOptions), { fastScrollSensitivity });
      }
      if (Object.keys(newOptions).length > 0) {
        tree.updateOptions(newOptions);
      }
    }), this.contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(interestingContextKeys)) {
        tree.updateOptions({ automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });
      }
    }), accessibilityService.onDidChangeScreenReaderOptimized(() => updateKeyboardNavigation()));
    this.navigator = new TreeResourceNavigator(tree, Object.assign({ configurationService }, options));
    this.disposables.push(this.navigator);
  }
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  updateOptions(options) {
    if (options.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
    }
  }
  updateStyleOverrides(overrideStyles) {
    dispose(this.styler);
    this.styler = overrideStyles ? attachListStyler(this.tree, this.themeService, overrideStyles) : Disposable.None;
  }
  dispose() {
    this.disposables = dispose(this.disposables);
    dispose(this.styler);
    this.styler = void 0;
  }
};
WorkbenchTreeInternals = __decorate13([
  __param12(4, IContextKeyService),
  __param12(5, IListService),
  __param12(6, IThemeService),
  __param12(7, IConfigurationService),
  __param12(8, IAccessibilityService)
], WorkbenchTreeInternals);
var configurationRegistry = Registry.as(Extensions.Configuration);
configurationRegistry.registerConfiguration({
  id: "workbench",
  order: 7,
  title: localize("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [multiSelectModifierSettingKey]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      enumDescriptions: [
        localize("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        localize("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: localize({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [openModeSettingKey]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: localize({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [horizontalScrollingKey]: {
      type: "boolean",
      default: false,
      description: localize("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [treeIndentKey]: {
      type: "number",
      default: 8,
      minimum: 0,
      maximum: 40,
      description: localize("tree indent setting", "Controls tree indentation in pixels.")
    },
    [treeRenderIndentGuidesKey]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: localize("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [listSmoothScrolling]: {
      type: "boolean",
      default: false,
      description: localize("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [mouseWheelScrollSensitivityKey]: {
      type: "number",
      default: 1,
      description: localize("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the deltaX and deltaY of mouse wheel scroll events.")
    },
    [fastScrollSensitivityKey]: {
      type: "number",
      default: 5,
      description: localize("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing Alt.")
    },
    [keyboardNavigationSettingKey]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        localize("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        localize("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        localize("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: localize("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.")
    },
    [automaticKeyboardNavigationSettingKey]: {
      type: "boolean",
      default: true,
      markdownDescription: localize("automatic keyboard navigation setting", "Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.")
    },
    [treeExpandMode]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: localize("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    }
  }
});

// node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js
var MarkerSeverity2;
(function(MarkerSeverity4) {
  MarkerSeverity4[MarkerSeverity4["Hint"] = 1] = "Hint";
  MarkerSeverity4[MarkerSeverity4["Info"] = 2] = "Info";
  MarkerSeverity4[MarkerSeverity4["Warning"] = 4] = "Warning";
  MarkerSeverity4[MarkerSeverity4["Error"] = 8] = "Error";
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
(function(MarkerSeverity4) {
  function compare(a, b) {
    return b - a;
  }
  MarkerSeverity4.compare = compare;
  const _displayStrings = Object.create(null);
  _displayStrings[MarkerSeverity4.Error] = localize("sev.error", "Error");
  _displayStrings[MarkerSeverity4.Warning] = localize("sev.warning", "Warning");
  _displayStrings[MarkerSeverity4.Info] = localize("sev.info", "Info");
  function toString(a) {
    return _displayStrings[a] || "";
  }
  MarkerSeverity4.toString = toString;
  function fromSeverity(severity) {
    switch (severity) {
      case severity_default.Error:
        return MarkerSeverity4.Error;
      case severity_default.Warning:
        return MarkerSeverity4.Warning;
      case severity_default.Info:
        return MarkerSeverity4.Info;
      case severity_default.Ignore:
        return MarkerSeverity4.Hint;
    }
  }
  MarkerSeverity4.fromSeverity = fromSeverity;
  function toSeverity(severity) {
    switch (severity) {
      case MarkerSeverity4.Error:
        return severity_default.Error;
      case MarkerSeverity4.Warning:
        return severity_default.Warning;
      case MarkerSeverity4.Info:
        return severity_default.Info;
      case MarkerSeverity4.Hint:
        return severity_default.Ignore;
    }
  }
  MarkerSeverity4.toSeverity = toSeverity;
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
var IMarkerData;
(function(IMarkerData2) {
  const emptyString = "";
  function makeKey(markerData) {
    return makeKeyOptionalMessage(markerData, true);
  }
  IMarkerData2.makeKey = makeKey;
  function makeKeyOptionalMessage(markerData, useMessage) {
    let result = [emptyString];
    if (markerData.source) {
      result.push(markerData.source.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.code) {
      if (typeof markerData.code === "string") {
        result.push(markerData.code.replace("\xA6", "\\\xA6"));
      } else {
        result.push(markerData.code.value.replace("\xA6", "\\\xA6"));
      }
    } else {
      result.push(emptyString);
    }
    if (markerData.severity !== void 0 && markerData.severity !== null) {
      result.push(MarkerSeverity2.toString(markerData.severity));
    } else {
      result.push(emptyString);
    }
    if (markerData.message && useMessage) {
      result.push(markerData.message.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
      result.push(markerData.startLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
      result.push(markerData.startColumn.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
      result.push(markerData.endLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
      result.push(markerData.endColumn.toString());
    } else {
      result.push(emptyString);
    }
    result.push(emptyString);
    return result.join("\xA6");
  }
  IMarkerData2.makeKeyOptionalMessage = makeKeyOptionalMessage;
})(IMarkerData || (IMarkerData = {}));
var IMarkerService = createDecorator("markerService");

// node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js
var DoubleResourceMap = class {
  constructor() {
    this._byResource = new ResourceMap();
    this._byOwner = new Map();
  }
  set(resource, owner, value) {
    let ownerMap = this._byResource.get(resource);
    if (!ownerMap) {
      ownerMap = new Map();
      this._byResource.set(resource, ownerMap);
    }
    ownerMap.set(owner, value);
    let resourceMap = this._byOwner.get(owner);
    if (!resourceMap) {
      resourceMap = new ResourceMap();
      this._byOwner.set(owner, resourceMap);
    }
    resourceMap.set(resource, value);
  }
  get(resource, owner) {
    let ownerMap = this._byResource.get(resource);
    return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);
  }
  delete(resource, owner) {
    let removedA = false;
    let removedB = false;
    let ownerMap = this._byResource.get(resource);
    if (ownerMap) {
      removedA = ownerMap.delete(owner);
    }
    let resourceMap = this._byOwner.get(owner);
    if (resourceMap) {
      removedB = resourceMap.delete(resource);
    }
    if (removedA !== removedB) {
      throw new Error("illegal state");
    }
    return removedA && removedB;
  }
  values(key) {
    var _a6, _b, _c, _d;
    if (typeof key === "string") {
      return (_b = (_a6 = this._byOwner.get(key)) === null || _a6 === void 0 ? void 0 : _a6.values()) !== null && _b !== void 0 ? _b : Iterable.empty();
    }
    if (URI.isUri(key)) {
      return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();
    }
    return Iterable.map(Iterable.concat(...this._byOwner.values()), (map) => map[1]);
  }
};
var MarkerStats = class {
  constructor(service) {
    this.errors = 0;
    this.infos = 0;
    this.warnings = 0;
    this.unknowns = 0;
    this._data = new ResourceMap();
    this._service = service;
    this._subscription = service.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(resources) {
    for (const resource of resources) {
      const oldStats = this._data.get(resource);
      if (oldStats) {
        this._substract(oldStats);
      }
      const newStats = this._resourceStats(resource);
      this._add(newStats);
      this._data.set(resource, newStats);
    }
  }
  _resourceStats(resource) {
    const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (resource.scheme === Schemas.inMemory || resource.scheme === Schemas.walkThrough || resource.scheme === Schemas.walkThroughSnippet) {
      return result;
    }
    for (const { severity } of this._service.read({ resource })) {
      if (severity === MarkerSeverity2.Error) {
        result.errors += 1;
      } else if (severity === MarkerSeverity2.Warning) {
        result.warnings += 1;
      } else if (severity === MarkerSeverity2.Info) {
        result.infos += 1;
      } else {
        result.unknowns += 1;
      }
    }
    return result;
  }
  _substract(op) {
    this.errors -= op.errors;
    this.warnings -= op.warnings;
    this.infos -= op.infos;
    this.unknowns -= op.unknowns;
  }
  _add(op) {
    this.errors += op.errors;
    this.warnings += op.warnings;
    this.infos += op.infos;
    this.unknowns += op.unknowns;
  }
};
var MarkerService = class {
  constructor() {
    this._onMarkerChanged = new DebounceEmitter({
      delay: 0,
      merge: MarkerService._merge
    });
    this.onMarkerChanged = this._onMarkerChanged.event;
    this._data = new DoubleResourceMap();
    this._stats = new MarkerStats(this);
  }
  dispose() {
    this._stats.dispose();
    this._onMarkerChanged.dispose();
  }
  remove(owner, resources) {
    for (const resource of resources || []) {
      this.changeOne(owner, resource, []);
    }
  }
  changeOne(owner, resource, markerData) {
    if (isFalsyOrEmpty(markerData)) {
      const removed = this._data.delete(resource, owner);
      if (removed) {
        this._onMarkerChanged.fire([resource]);
      }
    } else {
      const markers = [];
      for (const data of markerData) {
        const marker = MarkerService._toMarker(owner, resource, data);
        if (marker) {
          markers.push(marker);
        }
      }
      this._data.set(resource, owner, markers);
      this._onMarkerChanged.fire([resource]);
    }
  }
  static _toMarker(owner, resource, data) {
    let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags } = data;
    if (!message) {
      return void 0;
    }
    startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
    startColumn = startColumn > 0 ? startColumn : 1;
    endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
    endColumn = endColumn > 0 ? endColumn : startColumn;
    return {
      resource,
      owner,
      code,
      severity,
      message,
      source,
      startLineNumber,
      startColumn,
      endLineNumber,
      endColumn,
      relatedInformation,
      tags
    };
  }
  read(filter = Object.create(null)) {
    let { owner, resource, severities, take } = filter;
    if (!take || take < 0) {
      take = -1;
    }
    if (owner && resource) {
      const data = this._data.get(resource, owner);
      if (!data) {
        return [];
      } else {
        const result = [];
        for (const marker of data) {
          if (MarkerService._accept(marker, severities)) {
            const newLen = result.push(marker);
            if (take > 0 && newLen === take) {
              break;
            }
          }
        }
        return result;
      }
    } else if (!owner && !resource) {
      const result = [];
      for (let markers of this._data.values()) {
        for (let data of markers) {
          if (MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    } else {
      const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
      const result = [];
      for (const markers of iterable) {
        for (const data of markers) {
          if (MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    }
  }
  static _accept(marker, severities) {
    return severities === void 0 || (severities & marker.severity) === marker.severity;
  }
  static _merge(all) {
    const set = new ResourceMap();
    for (let array of all) {
      for (let item of array) {
        set.set(item, true);
      }
    }
    return Array.from(set.keys());
  }
};

// node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MenuService = class MenuService2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  createMenu(id, contextKeyService, emitEventsForSubmenuChanges = false) {
    return new Menu2(id, emitEventsForSubmenuChanges, this._commandService, contextKeyService, this);
  }
};
MenuService = __decorate14([
  __param13(0, ICommandService)
], MenuService);
var Menu2 = class Menu3 {
  constructor(_id, _fireEventsForSubmenuChanges, _commandService, _contextKeyService, _menuService) {
    this._id = _id;
    this._fireEventsForSubmenuChanges = _fireEventsForSubmenuChanges;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._menuService = _menuService;
    this._disposables = new DisposableStore();
    this._menuGroups = [];
    this._contextKeys = new Set();
    this._build();
    const rebuildMenuSoon = new RunOnceScheduler(() => {
      this._build();
      this._onDidChange.fire(this);
    }, 50);
    this._disposables.add(rebuildMenuSoon);
    this._disposables.add(MenuRegistry.onDidChangeMenu((e) => {
      if (e.has(_id)) {
        rebuildMenuSoon.schedule();
      }
    }));
    const contextKeyListener = this._disposables.add(new DisposableStore());
    const startContextKeyListener = () => {
      const fireChangeSoon = new RunOnceScheduler(() => this._onDidChange.fire(this), 50);
      contextKeyListener.add(fireChangeSoon);
      contextKeyListener.add(_contextKeyService.onDidChangeContext((e) => {
        if (e.affectsSome(this._contextKeys)) {
          fireChangeSoon.schedule();
        }
      }));
    };
    this._onDidChange = new Emitter({
      onFirstListenerAdd: startContextKeyListener,
      onLastListenerRemove: contextKeyListener.clear.bind(contextKeyListener)
    });
    this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
  }
  _build() {
    this._menuGroups.length = 0;
    this._contextKeys.clear();
    const menuItems = MenuRegistry.getMenuItems(this._id);
    let group;
    menuItems.sort(Menu3._compareMenuItems);
    for (const item of menuItems) {
      const groupName = item.group || "";
      if (!group || group[0] !== groupName) {
        group = [groupName, []];
        this._menuGroups.push(group);
      }
      group[1].push(item);
      this._collectContextKeys(item);
    }
  }
  _collectContextKeys(item) {
    Menu3._fillInKbExprKeys(item.when, this._contextKeys);
    if (isIMenuItem(item)) {
      if (item.command.precondition) {
        Menu3._fillInKbExprKeys(item.command.precondition, this._contextKeys);
      }
      if (item.command.toggled) {
        const toggledExpression = item.command.toggled.condition || item.command.toggled;
        Menu3._fillInKbExprKeys(toggledExpression, this._contextKeys);
      }
    } else if (this._fireEventsForSubmenuChanges) {
      MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);
    }
  }
  getActions(options) {
    const result = [];
    for (let group of this._menuGroups) {
      const [id, items] = group;
      const activeActions = [];
      for (const item of items) {
        if (this._contextKeyService.contextMatchesRules(item.when)) {
          const action = isIMenuItem(item) ? new MenuItemAction(item.command, item.alt, options, this._contextKeyService, this._commandService) : new SubmenuItemAction(item, this._menuService, this._contextKeyService, options);
          activeActions.push(action);
        }
      }
      if (activeActions.length > 0) {
        result.push([id, activeActions]);
      }
    }
    return result;
  }
  static _fillInKbExprKeys(exp, set) {
    if (exp) {
      for (let key of exp.keys()) {
        set.add(key);
      }
    }
  }
  static _compareMenuItems(a, b) {
    let aGroup = a.group;
    let bGroup = b.group;
    if (aGroup !== bGroup) {
      if (!aGroup) {
        return 1;
      } else if (!bGroup) {
        return -1;
      }
      if (aGroup === "navigation") {
        return -1;
      } else if (bGroup === "navigation") {
        return 1;
      }
      let value = aGroup.localeCompare(bGroup);
      if (value !== 0) {
        return value;
      }
    }
    let aPrio = a.order || 0;
    let bPrio = b.order || 0;
    if (aPrio < bPrio) {
      return -1;
    } else if (aPrio > bPrio) {
      return 1;
    }
    return Menu3._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);
  }
  static _compareTitles(a, b) {
    const aStr = typeof a === "string" ? a : a.original;
    const bStr = typeof b === "string" ? b : b.original;
    return aStr.localeCompare(bStr);
  }
};
Menu2 = __decorate14([
  __param13(2, ICommandService),
  __param13(3, IContextKeyService),
  __param13(4, IMenuService)
], Menu2);

// node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsServiceImpl.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerDecorations = class extends Disposable {
  constructor(model) {
    super();
    this.model = model;
    this._markersData = new Map();
    this._register(toDisposable(() => {
      this.model.deltaDecorations([...this._markersData.keys()], []);
      this._markersData.clear();
    }));
  }
  update(markers, newDecorations) {
    const oldIds = [...this._markersData.keys()];
    this._markersData.clear();
    const ids = this.model.deltaDecorations(oldIds, newDecorations);
    for (let index = 0; index < ids.length; index++) {
      this._markersData.set(ids[index], markers[index]);
    }
    return oldIds.length !== 0 || ids.length !== 0;
  }
  getMarker(decoration) {
    return this._markersData.get(decoration.id);
  }
};
var MarkerDecorationsService = class MarkerDecorationsService2 extends Disposable {
  constructor(modelService, _markerService) {
    super();
    this._markerService = _markerService;
    this._onDidChangeMarker = this._register(new Emitter());
    this._markerDecorations = new ResourceMap();
    modelService.getModels().forEach((model) => this._onModelAdded(model));
    this._register(modelService.onModelAdded(this._onModelAdded, this));
    this._register(modelService.onModelRemoved(this._onModelRemoved, this));
    this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose();
    this._markerDecorations.forEach((value) => value.dispose());
    this._markerDecorations.clear();
  }
  getMarker(uri, decoration) {
    const markerDecorations = this._markerDecorations.get(uri);
    return markerDecorations ? markerDecorations.getMarker(decoration) || null : null;
  }
  _handleMarkerChange(changedResources) {
    changedResources.forEach((resource) => {
      const markerDecorations = this._markerDecorations.get(resource);
      if (markerDecorations) {
        this._updateDecorations(markerDecorations);
      }
    });
  }
  _onModelAdded(model) {
    const markerDecorations = new MarkerDecorations(model);
    this._markerDecorations.set(model.uri, markerDecorations);
    this._updateDecorations(markerDecorations);
  }
  _onModelRemoved(model) {
    const markerDecorations = this._markerDecorations.get(model.uri);
    if (markerDecorations) {
      markerDecorations.dispose();
      this._markerDecorations.delete(model.uri);
    }
    if (model.uri.scheme === Schemas.inMemory || model.uri.scheme === Schemas.internal || model.uri.scheme === Schemas.vscode) {
      if (this._markerService) {
        this._markerService.read({ resource: model.uri }).map((marker) => marker.owner).forEach((owner) => this._markerService.remove(owner, [model.uri]));
      }
    }
  }
  _updateDecorations(markerDecorations) {
    const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });
    let newModelDecorations = markers.map((marker) => {
      return {
        range: this._createDecorationRange(markerDecorations.model, marker),
        options: this._createDecorationOption(marker)
      };
    });
    if (markerDecorations.update(markers, newModelDecorations)) {
      this._onDidChangeMarker.fire(markerDecorations.model);
    }
  }
  _createDecorationRange(model, rawMarker) {
    let ret = Range.lift(rawMarker);
    if (rawMarker.severity === MarkerSeverity2.Hint && !this._hasMarkerTag(rawMarker, 1) && !this._hasMarkerTag(rawMarker, 2)) {
      ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);
    }
    ret = model.validateRange(ret);
    if (ret.isEmpty()) {
      let word = model.getWordAtPosition(ret.getStartPosition());
      if (word) {
        ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
      } else {
        let maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) || model.getLineMaxColumn(ret.startLineNumber);
        if (maxColumn === 1) {
        } else if (ret.endColumn >= maxColumn) {
          ret = new Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);
        } else {
          ret = new Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);
        }
      }
    } else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
      let minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
      if (minColumn < ret.endColumn) {
        ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
        rawMarker.startColumn = minColumn;
      }
    }
    return ret;
  }
  _createDecorationOption(marker) {
    let className;
    let color = void 0;
    let zIndex;
    let inlineClassName = void 0;
    let minimap;
    switch (marker.severity) {
      case MarkerSeverity2.Hint:
        if (this._hasMarkerTag(marker, 2)) {
          className = void 0;
        } else if (this._hasMarkerTag(marker, 1)) {
          className = "squiggly-unnecessary";
        } else {
          className = "squiggly-hint";
        }
        zIndex = 0;
        break;
      case MarkerSeverity2.Warning:
        className = "squiggly-warning";
        color = themeColorFromId(overviewRulerWarning);
        zIndex = 20;
        minimap = {
          color: themeColorFromId(minimapWarning),
          position: MinimapPosition.Inline
        };
        break;
      case MarkerSeverity2.Info:
        className = "squiggly-info";
        color = themeColorFromId(overviewRulerInfo);
        zIndex = 10;
        break;
      case MarkerSeverity2.Error:
      default:
        className = "squiggly-error";
        color = themeColorFromId(overviewRulerError);
        zIndex = 30;
        minimap = {
          color: themeColorFromId(minimapError),
          position: MinimapPosition.Inline
        };
        break;
    }
    if (marker.tags) {
      if (marker.tags.indexOf(1) !== -1) {
        inlineClassName = "squiggly-inline-unnecessary";
      }
      if (marker.tags.indexOf(2) !== -1) {
        inlineClassName = "squiggly-inline-deprecated";
      }
    }
    return {
      description: "marker-decoration",
      stickiness: 1,
      className,
      showIfCollapsed: true,
      overviewRuler: {
        color,
        position: OverviewRulerLane.Right
      },
      minimap,
      zIndex,
      inlineClassName
    };
  }
  _hasMarkerTag(marker, tag) {
    if (marker.tags) {
      return marker.tags.indexOf(tag) >= 0;
    }
    return false;
  }
};
MarkerDecorationsService = __decorate15([
  __param14(0, IModelService),
  __param14(1, IMarkerService)
], MarkerDecorationsService);

// node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibilityService.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AccessibilityService = class AccessibilityService2 extends Disposable {
  constructor(_contextKeyService, _configurationService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._accessibilitySupport = 0;
    this._onDidChangeScreenReaderOptimized = new Emitter();
    this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);
    const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.accessibilitySupport")) {
        updateContextKey();
        this._onDidChangeScreenReaderOptimized.fire();
      }
    }));
    updateContextKey();
    this.onDidChangeScreenReaderOptimized(() => updateContextKey());
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const config = this._configurationService.getValue("editor.accessibilitySupport");
    return config === "on" || config === "auto" && this._accessibilitySupport === 2;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
AccessibilityService = __decorate16([
  __param15(0, IContextKeyService),
  __param15(1, IConfigurationService)
], AccessibilityService);

// node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BrowserClipboardService = class {
  constructor() {
    this.mapTextToType = new Map();
    this.findText = "";
  }
  writeText(text, type) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (type) {
        this.mapTextToType.set(type, text);
        return;
      }
      try {
        return yield navigator.clipboard.writeText(text);
      } catch (error) {
        console.error(error);
      }
      const activeElement = document.activeElement;
      const textArea = document.body.appendChild($("textarea", { "aria-hidden": true }));
      textArea.style.height = "1px";
      textArea.style.width = "1px";
      textArea.style.position = "absolute";
      textArea.value = text;
      textArea.focus();
      textArea.select();
      document.execCommand("copy");
      if (activeElement instanceof HTMLElement) {
        activeElement.focus();
      }
      document.body.removeChild(textArea);
      return;
    });
  }
  readText(type) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (type) {
        return this.mapTextToType.get(type) || "";
      }
      try {
        return yield navigator.clipboard.readText();
      } catch (error) {
        console.error(error);
        return "";
      }
    });
  }
  readFindText() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.findText;
    });
  }
  writeFindText(text) {
    return __awaiter9(this, void 0, void 0, function* () {
      this.findText = text;
    });
  }
};

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEBUG = false;
function getResourceLabel(resource) {
  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;
}
var stackElementCounter = 0;
var ResourceStackElement = class {
  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 0;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this.resourceLabels = [this.resourceLabel];
    this.strResources = [this.strResource];
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.isValid = true;
  }
  setValid(isValid) {
    this.isValid = isValid;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceReasonPair = class {
  constructor(resourceLabel, reason) {
    this.resourceLabel = resourceLabel;
    this.reason = reason;
  }
};
var RemovedResources = class {
  constructor() {
    this.elements = new Map();
  }
  createMessage() {
    const externalRemoval = [];
    const noParallelUniverses = [];
    for (const [, element] of this.elements) {
      const dest = element.reason === 0 ? externalRemoval : noParallelUniverses;
      dest.push(element.resourceLabel);
    }
    let messages = [];
    if (externalRemoval.length > 0) {
      messages.push(localize({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(", ")));
    }
    if (noParallelUniverses.length > 0) {
      messages.push(localize({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(", ")));
    }
    return messages.join("\n");
  }
  get size() {
    return this.elements.size;
  }
  has(strResource) {
    return this.elements.has(strResource);
  }
  set(strResource, value) {
    this.elements.set(strResource, value);
  }
  delete(strResource) {
    return this.elements.delete(strResource);
  }
};
var WorkspaceStackElement = class {
  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 1;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabels = resourceLabels;
    this.strResources = strResources;
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.removedResources = null;
    this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split === "function";
  }
  removeResource(resourceLabel, strResource, reason) {
    if (!this.removedResources) {
      this.removedResources = new RemovedResources();
    }
    if (!this.removedResources.has(strResource)) {
      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));
    }
  }
  setValid(resourceLabel, strResource, isValid) {
    if (isValid) {
      if (this.invalidatedResources) {
        this.invalidatedResources.delete(strResource);
        if (this.invalidatedResources.size === 0) {
          this.invalidatedResources = null;
        }
      }
    } else {
      if (!this.invalidatedResources) {
        this.invalidatedResources = new RemovedResources();
      }
      if (!this.invalidatedResources.has(strResource)) {
        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0));
      }
    }
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceEditStack = class {
  constructor(resourceLabel, strResource) {
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this._past = [];
    this._future = [];
    this.locked = false;
    this.versionId = 1;
  }
  dispose() {
    for (const element of this._past) {
      if (element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    for (const element of this._future) {
      if (element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    this.versionId++;
  }
  toString() {
    let result = [];
    result.push(`* ${this.strResource}:`);
    for (let i = 0; i < this._past.length; i++) {
      result.push(`   * [UNDO] ${this._past[i]}`);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      result.push(`   * [REDO] ${this._future[i]}`);
    }
    return result.join("\n");
  }
  flushAllElements() {
    this._past = [];
    this._future = [];
    this.versionId++;
  }
  _setElementValidFlag(element, isValid) {
    if (element.type === 1) {
      element.setValid(this.resourceLabel, this.strResource, isValid);
    } else {
      element.setValid(isValid);
    }
  }
  setElementsValidFlag(isValid, filter) {
    for (const element of this._past) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
    for (const element of this._future) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
  }
  pushElement(element) {
    for (const futureElement of this._future) {
      if (futureElement.type === 1) {
        futureElement.removeResource(this.resourceLabel, this.strResource, 1);
      }
    }
    this._future = [];
    this._past.push(element);
    this.versionId++;
  }
  createSnapshot(resource) {
    const elements = [];
    for (let i = 0, len = this._past.length; i < len; i++) {
      elements.push(this._past[i].id);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      elements.push(this._future[i].id);
    }
    return new ResourceEditStackSnapshot(resource, elements);
  }
  restoreSnapshot(snapshot) {
    const snapshotLength = snapshot.elements.length;
    let isOK = true;
    let snapshotIndex = 0;
    let removePastAfter = -1;
    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {
      const element = this._past[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removePastAfter = 0;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    let removeFutureBefore = -1;
    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {
      const element = this._future[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removeFutureBefore = i;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    if (removePastAfter !== -1) {
      this._past = this._past.slice(0, removePastAfter);
    }
    if (removeFutureBefore !== -1) {
      this._future = this._future.slice(removeFutureBefore + 1);
    }
    this.versionId++;
  }
  getElements() {
    const past = [];
    const future = [];
    for (const element of this._past) {
      past.push(element.actual);
    }
    for (const element of this._future) {
      future.push(element.actual);
    }
    return { past, future };
  }
  getClosestPastElement() {
    if (this._past.length === 0) {
      return null;
    }
    return this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    if (this._past.length < 2) {
      return null;
    }
    return this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    if (this._future.length === 0) {
      return null;
    }
    return this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(toRemove, individualMap) {
    for (let j = this._past.length - 1; j >= 0; j--) {
      if (this._past[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._past[j] = individualMap.get(this.strResource);
        } else {
          this._past.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  splitFutureWorkspaceElement(toRemove, individualMap) {
    for (let j = this._future.length - 1; j >= 0; j--) {
      if (this._future[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._future[j] = individualMap.get(this.strResource);
        } else {
          this._future.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  moveBackward(element) {
    this._past.pop();
    this._future.push(element);
    this.versionId++;
  }
  moveForward(element) {
    this._future.pop();
    this._past.push(element);
    this.versionId++;
  }
};
var EditStackSnapshot = class {
  constructor(editStacks) {
    this.editStacks = editStacks;
    this._versionIds = [];
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      this._versionIds[i] = this.editStacks[i].versionId;
    }
  }
  isValid() {
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      if (this._versionIds[i] !== this.editStacks[i].versionId) {
        return false;
      }
    }
    return true;
  }
};
var missingEditStack = new ResourceEditStack("", "");
missingEditStack.locked = true;
var UndoRedoService = class UndoRedoService2 {
  constructor(_dialogService, _notificationService) {
    this._dialogService = _dialogService;
    this._notificationService = _notificationService;
    this._editStacks = new Map();
    this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(resource) {
    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
      if (uriComparisonKeyComputer[0] === resource.scheme) {
        return uriComparisonKeyComputer[1].getComparisonKey(resource);
      }
    }
    return resource.toString();
  }
  _print(label) {
    console.log(`------------------------------------`);
    console.log(`AFTER ${label}: `);
    let str = [];
    for (const element of this._editStacks) {
      str.push(element[1].toString());
    }
    console.log(str.join("\n"));
  }
  pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {
    if (element.type === 0) {
      const resourceLabel = getResourceLabel(element.resource);
      const strResource = this.getUriComparisonKey(element.resource);
      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));
    } else {
      const seen = new Set();
      const resourceLabels = [];
      const strResources = [];
      for (const resource of element.resources) {
        const resourceLabel = getResourceLabel(resource);
        const strResource = this.getUriComparisonKey(resource);
        if (seen.has(strResource)) {
          continue;
        }
        seen.add(strResource);
        resourceLabels.push(resourceLabel);
        strResources.push(strResource);
      }
      if (resourceLabels.length === 1) {
        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));
      } else {
        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));
      }
    }
    if (DEBUG) {
      this._print("pushElement");
    }
  }
  _pushElement(element) {
    for (let i = 0, len = element.strResources.length; i < len; i++) {
      const resourceLabel = element.resourceLabels[i];
      const strResource = element.strResources[i];
      let editStack;
      if (this._editStacks.has(strResource)) {
        editStack = this._editStacks.get(strResource);
      } else {
        editStack = new ResourceEditStack(resourceLabel, strResource);
        this._editStacks.set(strResource, editStack);
      }
      editStack.pushElement(element);
    }
  }
  getLastElement(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      if (editStack.hasFutureElements()) {
        return null;
      }
      const closestPastElement = editStack.getClosestPastElement();
      return closestPastElement ? closestPastElement.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitPastWorkspaceElement(toRemove, individualMap);
    }
  }
  _splitFutureWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitFutureWorkspaceElement(toRemove, individualMap);
    }
  }
  removeElements(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.dispose();
      this._editStacks.delete(strResource);
    }
    if (DEBUG) {
      this._print("removeElements");
    }
  }
  setElementsValidFlag(resource, isValid, filter) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.setElementsValidFlag(isValid, filter);
    }
    if (DEBUG) {
      this._print("setElementsValidFlag");
    }
  }
  createSnapshot(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.createSnapshot(resource);
    }
    return new ResourceEditStackSnapshot(resource, []);
  }
  restoreSnapshot(snapshot) {
    const strResource = this.getUriComparisonKey(snapshot.resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.restoreSnapshot(snapshot);
      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {
        editStack.dispose();
        this._editStacks.delete(strResource);
      }
    }
    if (DEBUG) {
      this._print("restoreSnapshot");
    }
  }
  getElements(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.getElements();
    }
    return { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canUndo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasPastElements();
    }
    return false;
  }
  _onError(err, element) {
    onUnexpectedError(err);
    for (const strResource of element.strResources) {
      this.removeElements(strResource);
    }
    this._notificationService.error(err);
  }
  _acquireLocks(editStackSnapshot) {
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        throw new Error("Cannot acquire edit stack lock");
      }
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.locked = true;
    }
    return () => {
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = false;
      }
    };
  }
  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {
    const releaseLocks = this._acquireLocks(editStackSnapshot);
    let result;
    try {
      result = invoke();
    } catch (err) {
      releaseLocks();
      cleanup.dispose();
      return this._onError(err, element);
    }
    if (result) {
      return result.then(() => {
        releaseLocks();
        cleanup.dispose();
        return continuation();
      }, (err) => {
        releaseLocks();
        cleanup.dispose();
        return this._onError(err, element);
      });
    } else {
      releaseLocks();
      cleanup.dispose();
      return continuation();
    }
  }
  _invokeWorkspacePrepare(element) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (typeof element.actual.prepareUndoRedo === "undefined") {
        return Disposable.None;
      }
      const result = element.actual.prepareUndoRedo();
      if (typeof result === "undefined") {
        return Disposable.None;
      }
      return result;
    });
  }
  _invokeResourcePrepare(element, callback) {
    if (element.actual.type !== 1 || typeof element.actual.prepareUndoRedo === "undefined") {
      return callback(Disposable.None);
    }
    const r = element.actual.prepareUndoRedo();
    if (!r) {
      return callback(Disposable.None);
    }
    if (isDisposable(r)) {
      return callback(r);
    }
    return r.then((disposable) => {
      return callback(disposable);
    });
  }
  _getAffectedEditStacks(element) {
    const affectedEditStacks = [];
    for (const strResource of element.strResources) {
      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);
    }
    return new EditStackSnapshot(affectedEditStacks);
  }
  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitPastWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._undo(strResource, 0, true));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotUndoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestPastElement() !== element) {
        cannotUndoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotUndoDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceUndo(strResource, element, undoConfirmed) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, false);
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);
  }
  _isPartOfUndoGroup(element) {
    if (!element.groupId) {
      return false;
    }
    for (const [, editStack] of this._editStacks) {
      const pastElement = editStack.getClosestPastElement();
      if (!pastElement) {
        continue;
      }
      if (pastElement === element) {
        const secondPastElement = editStack.getSecondClosestPastElement();
        if (secondPastElement && secondPastElement.groupId === element.groupId) {
          return true;
        }
      }
      if (pastElement.groupId === element.groupId) {
        return true;
      }
    }
    return false;
  }
  _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
        const result = yield this._dialogService.show(severity_default.Info, localize("confirmWorkspace", "Would you like to undo '{0}' across all files?", element.label), [
          localize({ key: "ok", comment: ["{0} denotes a number that is > 1"] }, "Undo in {0} Files", editStackSnapshot.editStacks.length),
          localize("nok", "Undo this File"),
          localize("cancel", "Cancel")
        ], {
          cancelId: 2
        });
        if (result.choice === 2) {
          return;
        }
        if (result.choice === 1) {
          this._splitPastWorkspaceElement(element, null);
          return this._undo(strResource, 0, true);
        }
        const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, false);
        if (verificationError1) {
          return verificationError1.returnValue;
        }
        undoConfirmed = true;
      }
      let cleanup;
      try {
        cleanup = yield this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, true);
      if (verificationError2) {
        cleanup.dispose();
        return verificationError2.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveBackward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
    });
  }
  _resourceUndo(editStack, element, undoConfirmed) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveBackward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
    });
  }
  _findClosestUndoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueUndoInGroup(groupId, undoConfirmed) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._undo(matchedStrResource, 0, undoConfirmed);
    }
  }
  undo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._undo(resourceOrSource, 0, false);
    }
    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);
  }
  _undo(strResource, sourceId = 0, undoConfirmed) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestPastElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._undo(matchedStrResource, sourceId, undoConfirmed);
      }
    }
    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;
    if (shouldPromptForConfirmation && !undoConfirmed) {
      return this._confirmAndContinueUndo(strResource, sourceId, element);
    }
    try {
      if (element.type === 1) {
        return this._workspaceUndo(strResource, element, undoConfirmed);
      } else {
        return this._resourceUndo(editStack, element, undoConfirmed);
      }
    } finally {
      if (DEBUG) {
        this._print("undo");
      }
    }
  }
  _confirmAndContinueUndo(strResource, sourceId, element) {
    return __awaiter10(this, void 0, void 0, function* () {
      const result = yield this._dialogService.show(severity_default.Info, localize("confirmDifferentSource", "Would you like to undo '{0}'?", element.label), [
        localize("confirmDifferentSource.yes", "Yes"),
        localize("cancel", "Cancel")
      ], {
        cancelId: 1
      });
      if (result.choice === 1) {
        return;
      }
      return this._undo(strResource, sourceId, true);
    });
  }
  _findClosestRedoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canRedo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasFutureElements();
    }
    return false;
  }
  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitFutureWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._redo(strResource));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotRedoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestFutureElement() !== element) {
        cannotRedoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotRedoDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceRedo(strResource, element) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, false);
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
  }
  _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
    return __awaiter10(this, void 0, void 0, function* () {
      let cleanup;
      try {
        cleanup = yield this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, true);
      if (verificationError) {
        cleanup.dispose();
        return verificationError.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveForward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
    });
  }
  _resourceRedo(editStack, element) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveForward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));
    });
  }
  _findClosestRedoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueRedoInGroup(groupId) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._redo(matchedStrResource);
    }
  }
  redo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._redo(matchedStrResource) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._redo(resourceOrSource);
    }
    return this._redo(this.getUriComparisonKey(resourceOrSource));
  }
  _redo(strResource) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestFutureElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._redo(matchedStrResource);
      }
    }
    try {
      if (element.type === 1) {
        return this._workspaceRedo(strResource, element);
      } else {
        return this._resourceRedo(editStack, element);
      }
    } finally {
      if (DEBUG) {
        this._print("redo");
      }
    }
  }
};
UndoRedoService = __decorate17([
  __param16(0, IDialogService),
  __param16(1, INotificationService)
], UndoRedoService);
var WorkspaceVerificationError = class {
  constructor(returnValue) {
    this.returnValue = returnValue;
  }
};
registerSingleton(IUndoRedoService, UndoRedoService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputServiceImpl.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInput.css";

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInput.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/common/quickInput.js
var NO_KEY_MODS = { ctrlCmd: false, alt: false };
var QuickInputHideReason;
(function(QuickInputHideReason2) {
  QuickInputHideReason2[QuickInputHideReason2["Blur"] = 1] = "Blur";
  QuickInputHideReason2[QuickInputHideReason2["Gesture"] = 2] = "Gesture";
  QuickInputHideReason2[QuickInputHideReason2["Other"] = 3] = "Other";
})(QuickInputHideReason || (QuickInputHideReason = {}));
var ItemActivation;
(function(ItemActivation2) {
  ItemActivation2[ItemActivation2["NONE"] = 0] = "NONE";
  ItemActivation2[ItemActivation2["FIRST"] = 1] = "FIRST";
  ItemActivation2[ItemActivation2["SECOND"] = 2] = "SECOND";
  ItemActivation2[ItemActivation2["LAST"] = 3] = "LAST";
})(ItemActivation || (ItemActivation = {}));

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputList.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/base/common/comparers.js
var intlFileNameCollatorBaseNumeric = new IdleValue(() => {
  const collator = new Intl.Collator(void 0, { numeric: true, sensitivity: "base" });
  return {
    collator,
    collatorIsNumeric: collator.resolvedOptions().numeric
  };
});
function compareFileNames(one, other, caseSensitive = false) {
  const a = one || "";
  const b = other || "";
  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
    return a < b ? -1 : 1;
  }
  return result;
}
function compareAnything(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const prefixCompare = compareByPrefix(one, other, lookFor);
  if (prefixCompare) {
    return prefixCompare;
  }
  const elementASuffixMatch = elementAName.endsWith(lookFor);
  const elementBSuffixMatch = elementBName.endsWith(lookFor);
  if (elementASuffixMatch !== elementBSuffixMatch) {
    return elementASuffixMatch ? -1 : 1;
  }
  const r = compareFileNames(elementAName, elementBName);
  if (r !== 0) {
    return r;
  }
  return elementAName.localeCompare(elementBName);
}
function compareByPrefix(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const elementAPrefixMatch = elementAName.startsWith(lookFor);
  const elementBPrefixMatch = elementBName.startsWith(lookFor);
  if (elementAPrefixMatch !== elementBPrefixMatch) {
    return elementAPrefixMatch ? -1 : 1;
  } else if (elementAPrefixMatch && elementBPrefixMatch) {
    if (elementAName.length < elementBName.length) {
      return -1;
    }
    if (elementAName.length > elementBName.length) {
      return 1;
    }
  }
  return 0;
}

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputUtils.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/media/quickInput.css";
var iconPathToClass = {};
var iconClassGenerator = new IdGenerator("quick-input-button-icon-");
function getIconClass(iconPath) {
  if (!iconPath) {
    return void 0;
  }
  let iconClass;
  const key = iconPath.dark.toString();
  if (iconPathToClass[key]) {
    iconClass = iconPathToClass[key];
  } else {
    iconClass = iconClassGenerator.nextId();
    createCSSRule(`.${iconClass}`, `background-image: ${asCSSUrl(iconPath.light || iconPath.dark)}`);
    createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${asCSSUrl(iconPath.dark)}`);
    iconPathToClass[key] = iconClass;
  }
  return iconClass;
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.css";
var $2 = $;
var KeybindingLabel = class {
  constructor(container, os, options) {
    this.os = os;
    this.keyElements = new Set();
    this.options = options || Object.create(null);
    this.labelBackground = this.options.keybindingLabelBackground;
    this.labelForeground = this.options.keybindingLabelForeground;
    this.labelBorder = this.options.keybindingLabelBorder;
    this.labelBottomBorder = this.options.keybindingLabelBottomBorder;
    this.labelShadow = this.options.keybindingLabelShadow;
    this.domNode = append(container, $2(".monaco-keybinding"));
    this.didEverRender = false;
    container.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(keybinding, matches) {
    if (this.didEverRender && this.keybinding === keybinding && KeybindingLabel.areSame(this.matches, matches)) {
      return;
    }
    this.keybinding = keybinding;
    this.matches = matches;
    this.render();
  }
  render() {
    this.clear();
    if (this.keybinding) {
      let [firstPart, chordPart] = this.keybinding.getParts();
      if (firstPart) {
        this.renderPart(this.domNode, firstPart, this.matches ? this.matches.firstPart : null);
      }
      if (chordPart) {
        append(this.domNode, $2("span.monaco-keybinding-key-chord-separator", void 0, " "));
        this.renderPart(this.domNode, chordPart, this.matches ? this.matches.chordPart : null);
      }
      this.domNode.title = this.keybinding.getAriaLabel() || "";
    } else if (this.options && this.options.renderUnboundKeybindings) {
      this.renderUnbound(this.domNode);
    }
    this.applyStyles();
    this.didEverRender = true;
  }
  clear() {
    clearNode(this.domNode);
    this.keyElements.clear();
  }
  renderPart(parent, part, match) {
    const modifierLabels = UILabelProvider.modifierLabels[this.os];
    if (part.ctrlKey) {
      this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match === null || match === void 0 ? void 0 : match.ctrlKey), modifierLabels.separator);
    }
    if (part.shiftKey) {
      this.renderKey(parent, modifierLabels.shiftKey, Boolean(match === null || match === void 0 ? void 0 : match.shiftKey), modifierLabels.separator);
    }
    if (part.altKey) {
      this.renderKey(parent, modifierLabels.altKey, Boolean(match === null || match === void 0 ? void 0 : match.altKey), modifierLabels.separator);
    }
    if (part.metaKey) {
      this.renderKey(parent, modifierLabels.metaKey, Boolean(match === null || match === void 0 ? void 0 : match.metaKey), modifierLabels.separator);
    }
    const keyLabel = part.keyLabel;
    if (keyLabel) {
      this.renderKey(parent, keyLabel, Boolean(match === null || match === void 0 ? void 0 : match.keyCode), "");
    }
  }
  renderKey(parent, label, highlight, separator) {
    append(parent, this.createKeyElement(label, highlight ? ".highlight" : ""));
    if (separator) {
      append(parent, $2("span.monaco-keybinding-key-separator", void 0, separator));
    }
  }
  renderUnbound(parent) {
    append(parent, this.createKeyElement(localize("unbound", "Unbound")));
  }
  createKeyElement(label, extraClass = "") {
    const keyElement = $2("span.monaco-keybinding-key" + extraClass, void 0, label);
    this.keyElements.add(keyElement);
    return keyElement;
  }
  style(styles) {
    this.labelBackground = styles.keybindingLabelBackground;
    this.labelForeground = styles.keybindingLabelForeground;
    this.labelBorder = styles.keybindingLabelBorder;
    this.labelBottomBorder = styles.keybindingLabelBottomBorder;
    this.labelShadow = styles.keybindingLabelShadow;
    this.applyStyles();
  }
  applyStyles() {
    var _a6;
    if (this.element) {
      for (const keyElement of this.keyElements) {
        if (this.labelBackground) {
          keyElement.style.backgroundColor = (_a6 = this.labelBackground) === null || _a6 === void 0 ? void 0 : _a6.toString();
        }
        if (this.labelBorder) {
          keyElement.style.borderColor = this.labelBorder.toString();
        }
        if (this.labelBottomBorder) {
          keyElement.style.borderBottomColor = this.labelBottomBorder.toString();
        }
        if (this.labelShadow) {
          keyElement.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`;
        }
      }
      if (this.labelForeground) {
        this.element.style.color = this.labelForeground.toString();
      }
    }
  }
  static areSame(a, b) {
    if (a === b || !a && !b) {
      return true;
    }
    return !!a && !!b && equals(a.firstPart, b.firstPart) && equals(a.chordPart, b.chordPart);
  }
};

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputList.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $3 = $;
var ListElement = class {
  constructor(init) {
    this.hidden = false;
    this._onChecked = new Emitter();
    this.onChecked = this._onChecked.event;
    Object.assign(this, init);
  }
  get checked() {
    return !!this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      this._onChecked.fire(value);
    }
  }
  dispose() {
    this._onChecked.dispose();
  }
};
var ListElementRenderer = class {
  get templateId() {
    return ListElementRenderer.ID;
  }
  renderTemplate(container) {
    const data = Object.create(null);
    data.toDisposeElement = [];
    data.toDisposeTemplate = [];
    data.entry = append(container, $3(".quick-input-list-entry"));
    const label = append(data.entry, $3("label.quick-input-list-label"));
    data.toDisposeTemplate.push(addStandardDisposableListener(label, EventType.CLICK, (e) => {
      if (!data.checkbox.offsetParent) {
        e.preventDefault();
      }
    }));
    data.checkbox = append(label, $3("input.quick-input-list-checkbox"));
    data.checkbox.type = "checkbox";
    data.toDisposeTemplate.push(addStandardDisposableListener(data.checkbox, EventType.CHANGE, (e) => {
      data.element.checked = data.checkbox.checked;
    }));
    const rows = append(label, $3(".quick-input-list-rows"));
    const row1 = append(rows, $3(".quick-input-list-row"));
    const row2 = append(rows, $3(".quick-input-list-row"));
    data.label = new IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true, supportIcons: true });
    const keybindingContainer = append(row1, $3(".quick-input-list-entry-keybinding"));
    data.keybinding = new KeybindingLabel(keybindingContainer, OS);
    const detailContainer = append(row2, $3(".quick-input-list-label-meta"));
    data.detail = new HighlightedLabel(detailContainer, true);
    data.separator = append(data.entry, $3(".quick-input-list-separator"));
    data.actionBar = new ActionBar(data.entry);
    data.actionBar.domNode.classList.add("quick-input-list-entry-action-bar");
    data.toDisposeTemplate.push(data.actionBar);
    return data;
  }
  renderElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.element = element;
    data.checkbox.checked = element.checked;
    data.toDisposeElement.push(element.onChecked((checked) => data.checkbox.checked = checked));
    const { labelHighlights, descriptionHighlights, detailHighlights } = element;
    const options = Object.create(null);
    options.matches = labelHighlights || [];
    options.descriptionTitle = element.saneDescription;
    options.descriptionMatches = descriptionHighlights || [];
    options.extraClasses = element.item.iconClasses;
    options.italic = element.item.italic;
    options.strikethrough = element.item.strikethrough;
    data.label.setLabel(element.saneLabel, element.saneDescription, options);
    data.keybinding.set(element.item.keybinding);
    data.detail.set(element.saneDetail, detailHighlights);
    if (element.separator && element.separator.label) {
      data.separator.textContent = element.separator.label;
      data.separator.style.display = "";
    } else {
      data.separator.style.display = "none";
    }
    data.entry.classList.toggle("quick-input-list-separator-border", !!element.separator);
    data.actionBar.clear();
    const buttons = element.item.buttons;
    if (buttons && buttons.length) {
      data.actionBar.push(buttons.map((button, index2) => {
        let cssClasses = button.iconClass || (button.iconPath ? getIconClass(button.iconPath) : void 0);
        if (button.alwaysVisible) {
          cssClasses = cssClasses ? `${cssClasses} always-visible` : "always-visible";
        }
        const action = new Action(`id-${index2}`, "", cssClasses, true, () => __awaiter11(this, void 0, void 0, function* () {
          element.fireButtonTriggered({
            button,
            item: element.item
          });
        }));
        action.tooltip = button.tooltip || "";
        return action;
      }), { icon: true, label: false });
      data.entry.classList.add("has-actions");
    } else {
      data.entry.classList.remove("has-actions");
    }
  }
  disposeElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
  }
  disposeTemplate(data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.toDisposeTemplate = dispose(data.toDisposeTemplate);
  }
};
ListElementRenderer.ID = "listelement";
var ListElementDelegate = class {
  getHeight(element) {
    return element.saneDetail ? 44 : 22;
  }
  getTemplateId(element) {
    return ListElementRenderer.ID;
  }
};
var QuickInputListFocus;
(function(QuickInputListFocus2) {
  QuickInputListFocus2[QuickInputListFocus2["First"] = 1] = "First";
  QuickInputListFocus2[QuickInputListFocus2["Second"] = 2] = "Second";
  QuickInputListFocus2[QuickInputListFocus2["Last"] = 3] = "Last";
  QuickInputListFocus2[QuickInputListFocus2["Next"] = 4] = "Next";
  QuickInputListFocus2[QuickInputListFocus2["Previous"] = 5] = "Previous";
  QuickInputListFocus2[QuickInputListFocus2["NextPage"] = 6] = "NextPage";
  QuickInputListFocus2[QuickInputListFocus2["PreviousPage"] = 7] = "PreviousPage";
})(QuickInputListFocus || (QuickInputListFocus = {}));
var QuickInputList = class {
  constructor(parent, id, options) {
    this.parent = parent;
    this.inputElements = [];
    this.elements = [];
    this.elementsToIndexes = new Map();
    this.matchOnDescription = false;
    this.matchOnDetail = false;
    this.matchOnLabel = true;
    this.matchOnMeta = true;
    this.sortByLabel = true;
    this._onChangedAllVisibleChecked = new Emitter();
    this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
    this._onChangedCheckedCount = new Emitter();
    this.onChangedCheckedCount = this._onChangedCheckedCount.event;
    this._onChangedVisibleCount = new Emitter();
    this.onChangedVisibleCount = this._onChangedVisibleCount.event;
    this._onChangedCheckedElements = new Emitter();
    this.onChangedCheckedElements = this._onChangedCheckedElements.event;
    this._onButtonTriggered = new Emitter();
    this.onButtonTriggered = this._onButtonTriggered.event;
    this._onKeyDown = new Emitter();
    this.onKeyDown = this._onKeyDown.event;
    this._onLeave = new Emitter();
    this.onLeave = this._onLeave.event;
    this._fireCheckedEvents = true;
    this.elementDisposables = [];
    this.disposables = [];
    this.id = id;
    this.container = append(this.parent, $3(".quick-input-list"));
    const delegate = new ListElementDelegate();
    const accessibilityProvider = new QuickInputAccessibilityProvider();
    this.list = options.createList("QuickInput", this.container, delegate, [new ListElementRenderer()], {
      identityProvider: { getId: (element) => element.saneLabel },
      setRowLineHeight: false,
      multipleSelectionSupport: false,
      horizontalScrolling: false,
      accessibilityProvider
    });
    this.list.getHTMLElement().id = id;
    this.disposables.push(this.list);
    this.disposables.push(this.list.onKeyDown((e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          if (isMacintosh ? e.metaKey : e.ctrlKey) {
            this.list.setFocus(range(this.list.length));
          }
          break;
        case 16:
          const focus1 = this.list.getFocus();
          if (focus1.length === 1 && focus1[0] === 0) {
            this._onLeave.fire();
          }
          break;
        case 18:
          const focus2 = this.list.getFocus();
          if (focus2.length === 1 && focus2[0] === this.list.length - 1) {
            this._onLeave.fire();
          }
          break;
      }
      this._onKeyDown.fire(event);
    }));
    this.disposables.push(this.list.onMouseDown((e) => {
      if (e.browserEvent.button !== 2) {
        e.browserEvent.preventDefault();
      }
    }));
    this.disposables.push(addDisposableListener(this.container, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        this._onLeave.fire();
      }
    }));
    this.disposables.push(this.list.onMouseMiddleClick((e) => {
      this._onLeave.fire();
    }));
    this.disposables.push(this.list.onContextMenu((e) => {
      if (typeof e.index === "number") {
        e.browserEvent.preventDefault();
        this.list.setSelection([e.index]);
      }
    }));
    this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Event.map(this.list.onDidChangeFocus, (e) => e.elements.map((e2) => e2.item));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((e2) => e2.item), event: e.browserEvent }));
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, false);
  }
  allVisibleChecked(elements, whenNoneVisible = true) {
    for (let i = 0, n = elements.length; i < n; i++) {
      const element = elements[i];
      if (!element.hidden) {
        if (!element.checked) {
          return false;
        } else {
          whenNoneVisible = true;
        }
      }
    }
    return whenNoneVisible;
  }
  getCheckedCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (elements[i].checked) {
        count++;
      }
    }
    return count;
  }
  getVisibleCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (!elements[i].hidden) {
        count++;
      }
    }
    return count;
  }
  setAllVisibleChecked(checked) {
    try {
      this._fireCheckedEvents = false;
      this.elements.forEach((element) => {
        if (!element.hidden) {
          element.checked = checked;
        }
      });
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  setElements(inputElements) {
    this.elementDisposables = dispose(this.elementDisposables);
    const fireButtonTriggered = (event) => this.fireButtonTriggered(event);
    this.inputElements = inputElements;
    this.elements = inputElements.reduce((result, item, index) => {
      var _a6, _b, _c;
      if (item.type !== "separator") {
        const previous = index && inputElements[index - 1];
        const saneLabel = item.label && item.label.replace(/\r?\n/g, " ");
        const saneMeta = item.meta && item.meta.replace(/\r?\n/g, " ");
        const saneDescription = item.description && item.description.replace(/\r?\n/g, " ");
        const saneDetail = item.detail && item.detail.replace(/\r?\n/g, " ");
        const saneAriaLabel = item.ariaLabel || [saneLabel, saneDescription, saneDetail].map((s) => getCodiconAriaLabel(s)).filter((s) => !!s).join(", ");
        result.push(new ListElement({
          index,
          item,
          saneLabel,
          saneMeta,
          saneAriaLabel,
          saneDescription,
          saneDetail,
          labelHighlights: (_a6 = item.highlights) === null || _a6 === void 0 ? void 0 : _a6.label,
          descriptionHighlights: (_b = item.highlights) === null || _b === void 0 ? void 0 : _b.description,
          detailHighlights: (_c = item.highlights) === null || _c === void 0 ? void 0 : _c.detail,
          checked: false,
          separator: previous && previous.type === "separator" ? previous : void 0,
          fireButtonTriggered
        }));
      }
      return result;
    }, []);
    this.elementDisposables.push(...this.elements);
    this.elementDisposables.push(...this.elements.map((element) => element.onChecked(() => this.fireCheckedEvents())));
    this.elementsToIndexes = this.elements.reduce((map, element, index) => {
      map.set(element.item, index);
      return map;
    }, new Map());
    this.list.splice(0, this.list.length);
    this.list.splice(0, this.list.length, this.elements);
    this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(items) {
    this.list.setFocus(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
    if (items.length > 0) {
      const focused = this.list.getFocus()[0];
      if (typeof focused === "number") {
        this.list.reveal(focused);
      }
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(items) {
    this.list.setSelection(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(items) {
    try {
      this._fireCheckedEvents = false;
      const checked = new Set();
      for (const item of items) {
        checked.add(item);
      }
      for (const element of this.elements) {
        element.checked = checked.has(element.item);
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  set enabled(value) {
    this.list.getHTMLElement().style.pointerEvents = value ? "" : "none";
  }
  focus(what) {
    if (!this.list.length) {
      return;
    }
    if (what === QuickInputListFocus.Next && this.list.getFocus()[0] === this.list.length - 1) {
      what = QuickInputListFocus.First;
    }
    if (what === QuickInputListFocus.Previous && this.list.getFocus()[0] === 0) {
      what = QuickInputListFocus.Last;
    }
    if (what === QuickInputListFocus.Second && this.list.length < 2) {
      what = QuickInputListFocus.First;
    }
    switch (what) {
      case QuickInputListFocus.First:
        this.list.focusFirst();
        break;
      case QuickInputListFocus.Second:
        this.list.focusNth(1);
        break;
      case QuickInputListFocus.Last:
        this.list.focusLast();
        break;
      case QuickInputListFocus.Next:
        this.list.focusNext();
        break;
      case QuickInputListFocus.Previous:
        this.list.focusPrevious();
        break;
      case QuickInputListFocus.NextPage:
        this.list.focusNextPage();
        break;
      case QuickInputListFocus.PreviousPage:
        this.list.focusPreviousPage();
        break;
    }
    const focused = this.list.getFocus()[0];
    if (typeof focused === "number") {
      this.list.reveal(focused);
    }
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  layout(maxHeight) {
    this.list.getHTMLElement().style.maxHeight = maxHeight ? `calc(${Math.floor(maxHeight / 44) * 44}px)` : "";
    this.list.layout();
  }
  filter(query) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.list.layout();
      return false;
    }
    query = query.trim();
    if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.elements.forEach((element) => {
        element.labelHighlights = void 0;
        element.descriptionHighlights = void 0;
        element.detailHighlights = void 0;
        element.hidden = false;
        const previous = element.index && this.inputElements[element.index - 1];
        element.separator = previous && previous.type === "separator" ? previous : void 0;
      });
    } else {
      let currentSeparator;
      this.elements.forEach((element) => {
        const labelHighlights = this.matchOnLabel ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel))) : void 0;
        const descriptionHighlights = this.matchOnDescription ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || ""))) : void 0;
        const detailHighlights = this.matchOnDetail ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || ""))) : void 0;
        const metaHighlights = this.matchOnMeta ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneMeta || ""))) : void 0;
        if (labelHighlights || descriptionHighlights || detailHighlights || metaHighlights) {
          element.labelHighlights = labelHighlights;
          element.descriptionHighlights = descriptionHighlights;
          element.detailHighlights = detailHighlights;
          element.hidden = false;
        } else {
          element.labelHighlights = void 0;
          element.descriptionHighlights = void 0;
          element.detailHighlights = void 0;
          element.hidden = !element.item.alwaysShow;
        }
        element.separator = void 0;
        if (!this.sortByLabel) {
          const previous = element.index && this.inputElements[element.index - 1];
          currentSeparator = previous && previous.type === "separator" ? previous : currentSeparator;
          if (currentSeparator && !element.hidden) {
            element.separator = currentSeparator;
            currentSeparator = void 0;
          }
        }
      });
    }
    const shownElements = this.elements.filter((element) => !element.hidden);
    if (this.sortByLabel && query) {
      const normalizedSearchValue = query.toLowerCase();
      shownElements.sort((a, b) => {
        return compareEntries(a, b, normalizedSearchValue);
      });
    }
    this.elementsToIndexes = shownElements.reduce((map, element, index) => {
      map.set(element.item, index);
      return map;
    }, new Map());
    this.list.splice(0, this.list.length, shownElements);
    this.list.setFocus([]);
    this.list.layout();
    this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
    this._onChangedVisibleCount.fire(shownElements.length);
    return true;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = false;
      const elements = this.list.getFocusedElements();
      const allChecked = this.allVisibleChecked(elements);
      for (const element of elements) {
        element.checked = !allChecked;
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  display(display) {
    this.container.style.display = display ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = dispose(this.elementDisposables);
    this.disposables = dispose(this.disposables);
  }
  fireCheckedEvents() {
    if (this._fireCheckedEvents) {
      this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
      this._onChangedCheckedCount.fire(this.getCheckedCount());
      this._onChangedCheckedElements.fire(this.getCheckedElements());
    }
  }
  fireButtonTriggered(event) {
    this._onButtonTriggered.fire(event);
  }
  style(styles) {
    this.list.style(styles);
  }
};
__decorate18([
  memoize
], QuickInputList.prototype, "onDidChangeFocus", null);
__decorate18([
  memoize
], QuickInputList.prototype, "onDidChangeSelection", null);
function compareEntries(elementA, elementB, lookFor) {
  const labelHighlightsA = elementA.labelHighlights || [];
  const labelHighlightsB = elementB.labelHighlights || [];
  if (labelHighlightsA.length && !labelHighlightsB.length) {
    return -1;
  }
  if (!labelHighlightsA.length && labelHighlightsB.length) {
    return 1;
  }
  if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {
    return 0;
  }
  return compareAnything(elementA.saneLabel, elementB.saneLabel, lookFor);
}
var QuickInputAccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("quickInput", "Quick Input");
  }
  getAriaLabel(element) {
    return element.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole() {
    return "option";
  }
};

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputBox.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css";
var $4 = $;
var defaultOpts = {
  inputBackground: Color.fromHex("#3C3C3C"),
  inputForeground: Color.fromHex("#CCCCCC"),
  inputValidationInfoBorder: Color.fromHex("#55AAFF"),
  inputValidationInfoBackground: Color.fromHex("#063B49"),
  inputValidationWarningBorder: Color.fromHex("#B89500"),
  inputValidationWarningBackground: Color.fromHex("#352A05"),
  inputValidationErrorBorder: Color.fromHex("#BE1100"),
  inputValidationErrorBackground: Color.fromHex("#5A1D1D")
};
var InputBox = class extends Widget {
  constructor(container, contextViewProvider, options) {
    var _a6;
    super();
    this.state = "idle";
    this.maxHeight = Number.POSITIVE_INFINITY;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidHeightChange = this._register(new Emitter());
    this.onDidHeightChange = this._onDidHeightChange.event;
    this.contextViewProvider = contextViewProvider;
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts, false);
    this.message = null;
    this.placeholder = this.options.placeholder || "";
    this.tooltip = (_a6 = this.options.tooltip) !== null && _a6 !== void 0 ? _a6 : this.placeholder || "";
    this.ariaLabel = this.options.ariaLabel || "";
    this.inputBackground = this.options.inputBackground;
    this.inputForeground = this.options.inputForeground;
    this.inputBorder = this.options.inputBorder;
    this.inputValidationInfoBorder = this.options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = this.options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = this.options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = this.options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = this.options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = this.options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = this.options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = this.options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = this.options.inputValidationErrorForeground;
    if (this.options.validationOptions) {
      this.validation = this.options.validationOptions.validation;
    }
    this.element = append(container, $4(".monaco-inputbox.idle"));
    let tagName = this.options.flexibleHeight ? "textarea" : "input";
    let wrapper = append(this.element, $4(".ibwrapper"));
    this.input = append(wrapper, $4(tagName + ".input.empty"));
    this.input.setAttribute("autocorrect", "off");
    this.input.setAttribute("autocapitalize", "off");
    this.input.setAttribute("spellcheck", "false");
    this.onfocus(this.input, () => this.element.classList.add("synthetic-focus"));
    this.onblur(this.input, () => this.element.classList.remove("synthetic-focus"));
    if (this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight === "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;
      this.mirror = append(wrapper, $4("div.mirror"));
      this.mirror.innerText = "\xA0";
      this.scrollableElement = new ScrollableElement(this.element, { vertical: 1 });
      if (this.options.flexibleWidth) {
        this.input.setAttribute("wrap", "off");
        this.mirror.style.whiteSpace = "pre";
        this.mirror.style.wordWrap = "initial";
      }
      append(container, this.scrollableElement.getDomNode());
      this._register(this.scrollableElement);
      this._register(this.scrollableElement.onScroll((e) => this.input.scrollTop = e.scrollTop));
      const onSelectionChange = this._register(new DomEmitter(document, "selectionchange"));
      const onAnchoredSelectionChange = Event.filter(onSelectionChange.event, () => {
        const selection = document.getSelection();
        return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;
      });
      this._register(onAnchoredSelectionChange(this.updateScrollDimensions, this));
      this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else {
      this.input.type = this.options.type || "text";
      this.input.setAttribute("wrap", "off");
    }
    if (this.ariaLabel) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    }
    if (this.placeholder && !this.options.showPlaceholderOnFocus) {
      this.setPlaceHolder(this.placeholder);
    }
    if (this.tooltip) {
      this.setTooltip(this.tooltip);
    }
    this.oninput(this.input, () => this.onValueChange());
    this.onblur(this.input, () => this.onBlur());
    this.onfocus(this.input, () => this.onFocus());
    this.ignoreGesture(this.input);
    setTimeout(() => this.updateMirror(), 0);
    if (this.options.actions) {
      this.actionbar = this._register(new ActionBar(this.element));
      this.actionbar.push(this.options.actions, { icon: true, label: false });
    }
    this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", "");
    }
  }
  onFocus() {
    this._showMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", this.placeholder || "");
    }
  }
  setPlaceHolder(placeHolder) {
    this.placeholder = placeHolder;
    this.input.setAttribute("placeholder", placeHolder);
  }
  setTooltip(tooltip) {
    this.tooltip = tooltip;
    this.input.title = tooltip;
  }
  setAriaLabel(label) {
    this.ariaLabel = label;
    if (label) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    } else {
      this.input.removeAttribute("aria-label");
    }
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(newValue) {
    if (this.input.value !== newValue) {
      this.input.value = newValue;
      this.onValueChange();
    }
  }
  get height() {
    return typeof this.cachedHeight === "number" ? this.cachedHeight : getTotalHeight(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(range2 = null) {
    this.input.select();
    if (range2) {
      this.input.setSelectionRange(range2.start, range2.end);
      if (range2.end === this.input.value.length) {
        this.input.scrollLeft = this.input.scrollWidth;
      }
    }
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur();
    this.input.disabled = true;
    this._hideMessage();
  }
  get width() {
    return getTotalWidth(this.input);
  }
  set width(width) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let horizontalPadding = 0;
      if (this.mirror) {
        const paddingLeft = parseFloat(this.mirror.style.paddingLeft || "") || 0;
        const paddingRight = parseFloat(this.mirror.style.paddingRight || "") || 0;
        horizontalPadding = paddingLeft + paddingRight;
      }
      this.input.style.width = width - horizontalPadding + "px";
    } else {
      this.input.style.width = width + "px";
    }
    if (this.mirror) {
      this.mirror.style.width = width + "px";
    }
  }
  set paddingRight(paddingRight) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      this.input.style.width = `calc(100% - ${paddingRight}px)`;
    } else {
      this.input.style.paddingRight = paddingRight + "px";
    }
    if (this.mirror) {
      this.mirror.style.paddingRight = paddingRight + "px";
    }
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight !== "number" || typeof this.cachedHeight !== "number" || !this.scrollableElement) {
      return;
    }
    const scrollHeight = this.cachedContentHeight;
    const height = this.cachedHeight;
    const scrollTop = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight, height });
    this.scrollableElement.setScrollPosition({ scrollTop });
  }
  showMessage(message, force) {
    this.message = message;
    this.element.classList.remove("idle");
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add(this.classForType(message.type));
    const styles = this.stylesForType(this.message.type);
    this.element.style.border = styles.border ? `1px solid ${styles.border}` : "";
    if (this.hasFocus() || force) {
      this._showMessage();
    }
  }
  hideMessage() {
    this.message = null;
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add("idle");
    this._hideMessage();
    this.applyStyles();
  }
  validate() {
    let errorMsg = null;
    if (this.validation) {
      errorMsg = this.validation(this.value);
      if (errorMsg) {
        this.inputElement.setAttribute("aria-invalid", "true");
        this.showMessage(errorMsg);
      } else if (this.inputElement.hasAttribute("aria-invalid")) {
        this.inputElement.removeAttribute("aria-invalid");
        this.hideMessage();
      }
    }
    return errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.type;
  }
  stylesForType(type) {
    switch (type) {
      case 1:
        return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
      case 2:
        return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
      default:
        return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
    }
  }
  classForType(type) {
    switch (type) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message) {
      return;
    }
    let div;
    let layout2 = () => div.style.width = getTotalWidth(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (container) => {
        if (!this.message) {
          return null;
        }
        div = append(container, $4(".monaco-inputbox-container"));
        layout2();
        const renderOptions = {
          inline: true,
          className: "monaco-inputbox-message"
        };
        const spanElement = this.message.formatContent ? renderFormattedText(this.message.content, renderOptions) : renderText(this.message.content, renderOptions);
        spanElement.classList.add(this.classForType(this.message.type));
        const styles = this.stylesForType(this.message.type);
        spanElement.style.backgroundColor = styles.background ? styles.background.toString() : "";
        spanElement.style.color = styles.foreground ? styles.foreground.toString() : "";
        spanElement.style.border = styles.border ? `1px solid ${styles.border}` : "";
        append(div, spanElement);
        return null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: layout2
    });
    let alertText;
    if (this.message.type === 3) {
      alertText = localize("alertErrorMessage", "Error: {0}", this.message.content);
    } else if (this.message.type === 2) {
      alertText = localize("alertWarningMessage", "Warning: {0}", this.message.content);
    } else {
      alertText = localize("alertInfoMessage", "Info: {0}", this.message.content);
    }
    alert(alertText);
    this.state = "open";
  }
  _hideMessage() {
    if (!this.contextViewProvider) {
      return;
    }
    if (this.state === "open") {
      this.contextViewProvider.hideContextView();
    }
    this.state = "idle";
  }
  onValueChange() {
    this._onDidChange.fire(this.value);
    this.validate();
    this.updateMirror();
    this.input.classList.toggle("empty", !this.value);
    if (this.state === "open" && this.contextViewProvider) {
      this.contextViewProvider.layout();
    }
  }
  updateMirror() {
    if (!this.mirror) {
      return;
    }
    const value = this.value;
    const lastCharCode = value.charCodeAt(value.length - 1);
    const suffix = lastCharCode === 10 ? " " : "";
    const mirrorTextContent = (value + suffix).replace(/\u000c/g, "");
    if (mirrorTextContent) {
      this.mirror.textContent = value + suffix;
    } else {
      this.mirror.innerText = "\xA0";
    }
    this.layout();
  }
  style(styles) {
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    const background = this.inputBackground ? this.inputBackground.toString() : "";
    const foreground = this.inputForeground ? this.inputForeground.toString() : "";
    const border = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = background;
    this.element.style.color = foreground;
    this.input.style.backgroundColor = "inherit";
    this.input.style.color = foreground;
    this.element.style.borderWidth = border ? "1px" : "";
    this.element.style.borderStyle = border ? "solid" : "";
    this.element.style.borderColor = border;
  }
  layout() {
    if (!this.mirror) {
      return;
    }
    const previousHeight = this.cachedContentHeight;
    this.cachedContentHeight = getTotalHeight(this.mirror);
    if (previousHeight !== this.cachedContentHeight) {
      this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);
      this.input.style.height = this.cachedHeight + "px";
      this._onDidHeightChange.fire(this.cachedContentHeight);
    }
  }
  insertAtCursor(text) {
    const inputElement = this.inputElement;
    const start = inputElement.selectionStart;
    const end = inputElement.selectionEnd;
    const content = inputElement.value;
    if (start !== null && end !== null) {
      this.value = content.substr(0, start) + text + content.substr(end);
      inputElement.setSelectionRange(start + 1, start + 1);
      this.layout();
    }
  }
  dispose() {
    this._hideMessage();
    this.message = null;
    if (this.actionbar) {
      this.actionbar.dispose();
    }
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputBox.js
var $5 = $;
var QuickInputBox = class extends Disposable {
  constructor(parent) {
    super();
    this.parent = parent;
    this.onKeyDown = (handler) => {
      return addDisposableListener(this.inputBox.inputElement, EventType.KEY_DOWN, (e) => {
        handler(new StandardKeyboardEvent(e));
      });
    };
    this.onMouseDown = (handler) => {
      return addDisposableListener(this.inputBox.inputElement, EventType.MOUSE_DOWN, (e) => {
        handler(new StandardMouseEvent(e));
      });
    };
    this.onDidChange = (handler) => {
      return this.inputBox.onDidChange(handler);
    };
    this.container = append(this.parent, $5(".quick-input-box"));
    this.inputBox = this._register(new InputBox(this.container, void 0));
  }
  get value() {
    return this.inputBox.value;
  }
  set value(value) {
    this.inputBox.value = value;
  }
  select(range2 = null) {
    this.inputBox.select(range2);
  }
  isSelectionAtEnd() {
    return this.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(placeholder) {
    this.inputBox.setPlaceHolder(placeholder);
  }
  get ariaLabel() {
    return this.inputBox.getAriaLabel();
  }
  set ariaLabel(ariaLabel) {
    this.inputBox.setAriaLabel(ariaLabel);
  }
  get password() {
    return this.inputBox.inputElement.type === "password";
  }
  set password(password) {
    this.inputBox.inputElement.type = password ? "password" : "text";
  }
  setAttribute(name, value) {
    this.inputBox.inputElement.setAttribute(name, value);
  }
  removeAttribute(name) {
    this.inputBox.inputElement.removeAttribute(name);
  }
  showDecoration(decoration) {
    if (decoration === severity_default.Ignore) {
      this.inputBox.hideMessage();
    } else {
      this.inputBox.showMessage({ type: decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3, content: "" });
    }
  }
  stylesForType(decoration) {
    return this.inputBox.stylesForType(decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3);
  }
  setFocus() {
    this.inputBox.focus();
  }
  layout() {
    this.inputBox.layout();
  }
  style(styles) {
    this.inputBox.style(styles);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.css";
var defaultOpts2 = {
  badgeBackground: Color.fromHex("#4D4D4D"),
  badgeForeground: Color.fromHex("#FFFFFF")
};
var CountBadge = class {
  constructor(container, options) {
    this.count = 0;
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts2, false);
    this.badgeBackground = this.options.badgeBackground;
    this.badgeForeground = this.options.badgeForeground;
    this.badgeBorder = this.options.badgeBorder;
    this.element = append(container, $(".monaco-count-badge"));
    this.countFormat = this.options.countFormat || "{0}";
    this.titleFormat = this.options.titleFormat || "";
    this.setCount(this.options.count || 0);
  }
  setCount(count) {
    this.count = count;
    this.render();
  }
  setTitleFormat(titleFormat) {
    this.titleFormat = titleFormat;
    this.render();
  }
  render() {
    this.element.textContent = format(this.countFormat, this.count);
    this.element.title = format(this.titleFormat, this.count);
    this.applyStyles();
  }
  style(styles) {
    this.badgeBackground = styles.badgeBackground;
    this.badgeForeground = styles.badgeForeground;
    this.badgeBorder = styles.badgeBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.element) {
      const background = this.badgeBackground ? this.badgeBackground.toString() : "";
      const foreground = this.badgeForeground ? this.badgeForeground.toString() : "";
      const border = this.badgeBorder ? this.badgeBorder.toString() : "";
      this.element.style.backgroundColor = background;
      this.element.style.color = foreground;
      this.element.style.borderWidth = border ? "1px" : "";
      this.element.style.borderStyle = border ? "solid" : "";
      this.element.style.borderColor = border;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.css";
var CSS_DONE = "done";
var CSS_ACTIVE = "active";
var CSS_INFINITE = "infinite";
var CSS_DISCRETE = "discrete";
var defaultOpts3 = {
  progressBarBackground: Color.fromHex("#0E70C0")
};
var ProgressBar = class extends Disposable {
  constructor(container, options) {
    super();
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts3, false);
    this.workedVal = 0;
    this.progressBarBackground = this.options.progressBarBackground;
    this._register(this.showDelayedScheduler = new RunOnceScheduler(() => show(this.element), 0));
    this.create(container);
  }
  create(container) {
    this.element = document.createElement("div");
    this.element.classList.add("monaco-progress-container");
    this.element.setAttribute("role", "progressbar");
    this.element.setAttribute("aria-valuemin", "0");
    container.appendChild(this.element);
    this.bit = document.createElement("div");
    this.bit.classList.add("progress-bit");
    this.element.appendChild(this.bit);
    this.applyStyles();
  }
  off() {
    this.bit.style.width = "inherit";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_ACTIVE, CSS_INFINITE, CSS_DISCRETE);
    this.workedVal = 0;
    this.totalWork = void 0;
  }
  stop() {
    return this.doDone(false);
  }
  doDone(delayed) {
    this.element.classList.add(CSS_DONE);
    if (!this.element.classList.contains(CSS_INFINITE)) {
      this.bit.style.width = "inherit";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    } else {
      this.bit.style.opacity = "0";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    }
    return this;
  }
  infinite() {
    this.bit.style.width = "2%";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_DISCRETE, CSS_DONE);
    this.element.classList.add(CSS_ACTIVE, CSS_INFINITE);
    return this;
  }
  getContainer() {
    return this.element;
  }
  style(styles) {
    this.progressBarBackground = styles.progressBarBackground;
    this.applyStyles();
  }
  applyStyles() {
    if (this.bit) {
      const background = this.progressBarBackground ? this.progressBarBackground.toString() : "";
      this.bit.style.backgroundColor = background;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.js
import "C:/Users/Admin/prodigy-code/node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.css";
var defaultOptions2 = {
  buttonBackground: Color.fromHex("#0E639C"),
  buttonHoverBackground: Color.fromHex("#006BB3"),
  buttonForeground: Color.white
};
var Button = class extends Disposable {
  constructor(container, options) {
    super();
    this._onDidClick = this._register(new Emitter());
    this.options = options || Object.create(null);
    mixin(this.options, defaultOptions2, false);
    this.buttonForeground = this.options.buttonForeground;
    this.buttonBackground = this.options.buttonBackground;
    this.buttonHoverBackground = this.options.buttonHoverBackground;
    this.buttonSecondaryForeground = this.options.buttonSecondaryForeground;
    this.buttonSecondaryBackground = this.options.buttonSecondaryBackground;
    this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground;
    this.buttonBorder = this.options.buttonBorder;
    this._element = document.createElement("a");
    this._element.classList.add("monaco-button");
    this._element.tabIndex = 0;
    this._element.setAttribute("role", "button");
    container.appendChild(this._element);
    this._register(Gesture.addTarget(this._element));
    [EventType.CLICK, EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this._element, eventType, (e) => {
        if (!this.enabled) {
          EventHelper.stop(e);
          return;
        }
        this._onDidClick.fire(e);
      }));
    });
    this._register(addDisposableListener(this._element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = false;
      if (this.enabled && (event.equals(3) || event.equals(10))) {
        this._onDidClick.fire(e);
        eventHandled = true;
      } else if (event.equals(9)) {
        this._element.blur();
        eventHandled = true;
      }
      if (eventHandled) {
        EventHelper.stop(event, true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, (e) => {
      if (!this._element.classList.contains("disabled")) {
        this.setHoverBackground();
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, (e) => {
      this.applyStyles();
    }));
    this.focusTracker = this._register(trackFocus(this._element));
    this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground()));
    this._register(this.focusTracker.onDidBlur(() => this.applyStyles()));
    this.applyStyles();
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  setHoverBackground() {
    let hoverBackground;
    if (this.options.secondary) {
      hoverBackground = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null;
    } else {
      hoverBackground = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null;
    }
    if (hoverBackground) {
      this._element.style.backgroundColor = hoverBackground;
    }
  }
  style(styles) {
    this.buttonForeground = styles.buttonForeground;
    this.buttonBackground = styles.buttonBackground;
    this.buttonHoverBackground = styles.buttonHoverBackground;
    this.buttonSecondaryForeground = styles.buttonSecondaryForeground;
    this.buttonSecondaryBackground = styles.buttonSecondaryBackground;
    this.buttonSecondaryHoverBackground = styles.buttonSecondaryHoverBackground;
    this.buttonBorder = styles.buttonBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this._element) {
      let background, foreground;
      if (this.options.secondary) {
        foreground = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "";
        background = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "";
      } else {
        foreground = this.buttonForeground ? this.buttonForeground.toString() : "";
        background = this.buttonBackground ? this.buttonBackground.toString() : "";
      }
      const border = this.buttonBorder ? this.buttonBorder.toString() : "";
      this._element.style.color = foreground;
      this._element.style.backgroundColor = background;
      this._element.style.borderWidth = border ? "1px" : "";
      this._element.style.borderStyle = border ? "solid" : "";
      this._element.style.borderColor = border;
    }
  }
  get element() {
    return this._element;
  }
  set label(value) {
    this._element.classList.add("monaco-text-button");
    if (this.options.supportIcons) {
      reset(this._element, ...renderLabelWithIcons(value));
    } else {
      this._element.textContent = value;
    }
    if (typeof this.options.title === "string") {
      this._element.title = this.options.title;
    } else if (this.options.title) {
      this._element.title = value;
    }
  }
  set enabled(value) {
    if (value) {
      this._element.classList.remove("disabled");
      this._element.setAttribute("aria-disabled", String(false));
      this._element.tabIndex = 0;
    } else {
      this._element.classList.add("disabled");
      this._element.setAttribute("aria-disabled", String(true));
    }
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
};

// node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInput.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $6 = $;
var backButtonIcon = registerCodicon("quick-input-back", Codicon.arrowLeft);
var backButton = {
  iconClass: backButtonIcon.classNames,
  tooltip: localize("quickInput.back", "Back"),
  handle: -1
};
var QuickInput = class extends Disposable {
  constructor(ui) {
    super();
    this.ui = ui;
    this.visible = false;
    this._enabled = true;
    this._busy = false;
    this._ignoreFocusOut = false;
    this._buttons = [];
    this.noValidationMessage = QuickInput.noPromptMessage;
    this._severity = severity_default.Ignore;
    this.buttonsUpdated = false;
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.onDidHideEmitter = this._register(new Emitter());
    this.onDisposeEmitter = this._register(new Emitter());
    this.visibleDisposables = this._register(new DisposableStore());
    this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this.update();
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this.update();
  }
  get step() {
    return this._steps;
  }
  set step(step) {
    this._steps = step;
    this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(totalSteps) {
    this._totalSteps = totalSteps;
    this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(contextKey) {
    this._contextKey = contextKey;
    this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(busy) {
    this._busy = busy;
    this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(ignoreFocusOut) {
    const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;
    this._ignoreFocusOut = ignoreFocusOut && !isIOS;
    if (shouldUpdate) {
      this.update();
    }
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(buttons) {
    this._buttons = buttons;
    this.buttonsUpdated = true;
    this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(validationMessage) {
    this._validationMessage = validationMessage;
    this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(severity) {
    this._severity = severity;
    this.update();
  }
  show() {
    if (this.visible) {
      return;
    }
    this.visibleDisposables.add(this.ui.onDidTriggerButton((button) => {
      if (this.buttons.indexOf(button) !== -1) {
        this.onDidTriggerButtonEmitter.fire(button);
      }
    }));
    this.ui.show(this);
    this.visible = true;
    this.update();
  }
  hide() {
    if (!this.visible) {
      return;
    }
    this.ui.hide();
  }
  didHide(reason = QuickInputHideReason.Other) {
    this.visible = false;
    this.visibleDisposables.clear();
    this.onDidHideEmitter.fire({ reason });
  }
  update() {
    if (!this.visible) {
      return;
    }
    const title = this.getTitle();
    if (title && this.ui.title.textContent !== title) {
      this.ui.title.textContent = title;
    } else if (!title && this.ui.title.innerHTML !== "&nbsp;") {
      this.ui.title.innerText = "\xA0;";
    }
    const description = this.getDescription();
    if (this.ui.description1.textContent !== description) {
      this.ui.description1.textContent = description;
    }
    if (this.ui.description2.textContent !== description) {
      this.ui.description2.textContent = description;
    }
    if (this.busy && !this.busyDelay) {
      this.busyDelay = new TimeoutTimer();
      this.busyDelay.setIfNotSet(() => {
        if (this.visible) {
          this.ui.progressBar.infinite();
        }
      }, 800);
    }
    if (!this.busy && this.busyDelay) {
      this.ui.progressBar.stop();
      this.busyDelay.cancel();
      this.busyDelay = void 0;
    }
    if (this.buttonsUpdated) {
      this.buttonsUpdated = false;
      this.ui.leftActionBar.clear();
      const leftButtons = this.buttons.filter((button) => button === backButton);
      this.ui.leftActionBar.push(leftButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, () => __awaiter12(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(button);
        }));
        action.tooltip = button.tooltip || "";
        return action;
      }), { icon: true, label: false });
      this.ui.rightActionBar.clear();
      const rightButtons = this.buttons.filter((button) => button !== backButton);
      this.ui.rightActionBar.push(rightButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, () => __awaiter12(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(button);
        }));
        action.tooltip = button.tooltip || "";
        return action;
      }), { icon: true, label: false });
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut;
    this.ui.setEnabled(this.enabled);
    this.ui.setContextKey(this.contextKey);
    const validationMessage = this.validationMessage || this.noValidationMessage;
    if (this._lastValidationMessage !== validationMessage) {
      this._lastValidationMessage = validationMessage;
      reset(this.ui.message, ...renderLabelWithIcons(validationMessage));
    }
    if (this._lastSeverity !== this.severity) {
      this._lastSeverity = this.severity;
      this.showMessageDecoration(this.severity);
    }
  }
  getTitle() {
    if (this.title && this.step) {
      return `${this.title} (${this.getSteps()})`;
    }
    if (this.title) {
      return this.title;
    }
    if (this.step) {
      return this.getSteps();
    }
    return "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    if (this.step && this.totalSteps) {
      return localize("quickInput.steps", "{0}/{1}", this.step, this.totalSteps);
    }
    if (this.step) {
      return String(this.step);
    }
    return "";
  }
  showMessageDecoration(severity) {
    this.ui.inputBox.showDecoration(severity);
    if (severity !== severity_default.Ignore) {
      const styles = this.ui.inputBox.stylesForType(severity);
      this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : "";
      this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : "";
      this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : "";
      this.ui.message.style.paddingBottom = "4px";
    } else {
      this.ui.message.style.color = "";
      this.ui.message.style.backgroundColor = "";
      this.ui.message.style.border = "";
      this.ui.message.style.paddingBottom = "";
    }
  }
  dispose() {
    this.hide();
    this.onDisposeEmitter.fire();
    super.dispose();
  }
};
QuickInput.noPromptMessage = localize("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
var QuickPick = class extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.onDidChangeValueEmitter = this._register(new Emitter());
    this.onWillAcceptEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this._items = [];
    this.itemsUpdated = false;
    this._canSelectMany = false;
    this._canAcceptInBackground = false;
    this._matchOnDescription = false;
    this._matchOnDetail = false;
    this._matchOnLabel = true;
    this._sortByLabel = true;
    this._autoFocusOnList = true;
    this._itemActivation = this.ui.isScreenReaderOptimized() ? ItemActivation.NONE : ItemActivation.FIRST;
    this._activeItems = [];
    this.activeItemsUpdated = false;
    this.activeItemsToConfirm = [];
    this.onDidChangeActiveEmitter = this._register(new Emitter());
    this._selectedItems = [];
    this.selectedItemsUpdated = false;
    this.selectedItemsToConfirm = [];
    this.onDidChangeSelectionEmitter = this._register(new Emitter());
    this.onDidTriggerItemButtonEmitter = this._register(new Emitter());
    this.valueSelectionUpdated = true;
    this._ok = "default";
    this._customButton = false;
    this.filterValue = (value) => value;
    this.onDidChangeValue = this.onDidChangeValueEmitter.event;
    this.onWillAccept = this.onWillAcceptEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
    this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
    this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
    this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(quickNavigate) {
    this._quickNavigate = quickNavigate;
    this.update();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value || "";
      this.update();
      this.onDidChangeValueEmitter.fire(this._value);
    }
  }
  set ariaLabel(ariaLabel) {
    this._ariaLabel = ariaLabel;
    this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    this.itemsUpdated = true;
    this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(canSelectMany) {
    this._canSelectMany = canSelectMany;
    this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(canAcceptInBackground) {
    this._canAcceptInBackground = canAcceptInBackground;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(matchOnDescription) {
    this._matchOnDescription = matchOnDescription;
    this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(matchOnDetail) {
    this._matchOnDetail = matchOnDetail;
    this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(matchOnLabel) {
    this._matchOnLabel = matchOnLabel;
    this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(sortByLabel) {
    this._sortByLabel = sortByLabel;
    this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(autoFocusOnList) {
    this._autoFocusOnList = autoFocusOnList;
    this.update();
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(itemActivation) {
    this._itemActivation = itemActivation;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(activeItems) {
    this._activeItems = activeItems;
    this.activeItemsUpdated = true;
    this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(selectedItems) {
    this._selectedItems = selectedItems;
    this.selectedItemsUpdated = true;
    this.update();
  }
  get keyMods() {
    if (this._quickNavigate) {
      return NO_KEY_MODS;
    }
    return this.ui.keyMods;
  }
  set valueSelection(valueSelection) {
    this._valueSelection = valueSelection;
    this.valueSelectionUpdated = true;
    this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(showCustomButton) {
    this._customButton = showCustomButton;
    this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(label) {
    this._customButtonLabel = label;
    this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(hover) {
    this._customButtonHover = hover;
    this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(showOkButton) {
    this._ok = showOkButton;
    this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(hideInput) {
    this._hideInput = hideInput;
    this.update();
  }
  trySelectFirst() {
    if (this.autoFocusOnList) {
      if (!this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        if (value === this.value) {
          return;
        }
        this._value = value;
        const didFilter = this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
        if (didFilter) {
          this.trySelectFirst();
        }
        this.onDidChangeValueEmitter.fire(value);
      }));
      this.visibleDisposables.add(this.ui.inputBox.onMouseDown((event) => {
        if (!this.autoFocusOnList) {
          this.ui.list.clearFocus();
        }
      }));
      this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {
        switch (event.keyCode) {
          case 18:
            this.ui.list.focus(QuickInputListFocus.Next);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 16:
            if (this.ui.list.getFocusedElements().length) {
              this.ui.list.focus(QuickInputListFocus.Previous);
            } else {
              this.ui.list.focus(QuickInputListFocus.Last);
            }
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 12:
            this.ui.list.focus(QuickInputListFocus.NextPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 11:
            this.ui.list.focus(QuickInputListFocus.PreviousPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 17:
            if (!this._canAcceptInBackground) {
              return;
            }
            if (!this.ui.inputBox.isSelectionAtEnd()) {
              return;
            }
            if (this.activeItems[0]) {
              this._selectedItems = [this.activeItems[0]];
              this.onDidChangeSelectionEmitter.fire(this.selectedItems);
              this.handleAccept(true);
            }
            break;
          case 14:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.First);
              EventHelper.stop(event, true);
            }
            break;
          case 13:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.Last);
              EventHelper.stop(event, true);
            }
            break;
        }
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => {
        if (!this.canSelectMany && this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
        }
        this.handleAccept(false);
      }));
      this.visibleDisposables.add(this.ui.onDidCustom(() => {
        this.onDidCustomEmitter.fire();
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeFocus((focusedItems) => {
        if (this.activeItemsUpdated) {
          return;
        }
        if (this.activeItemsToConfirm !== this._activeItems && equals2(focusedItems, this._activeItems, (a, b) => a === b)) {
          return;
        }
        this._activeItems = focusedItems;
        this.onDidChangeActiveEmitter.fire(focusedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {
        if (this.canSelectMany) {
          if (selectedItems.length) {
            this.ui.list.setSelectedElements([]);
          }
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals2(selectedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = selectedItems;
        this.onDidChangeSelectionEmitter.fire(selectedItems);
        if (selectedItems.length) {
          this.handleAccept(event instanceof MouseEvent && event.button === 1);
        }
      }));
      this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((checkedItems) => {
        if (!this.canSelectMany) {
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals2(checkedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = checkedItems;
        this.onDidChangeSelectionEmitter.fire(checkedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onButtonTriggered((event) => this.onDidTriggerItemButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.registerQuickNavigation());
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  handleAccept(inBackground) {
    let veto = false;
    this.onWillAcceptEmitter.fire({ veto: () => veto = true });
    if (!veto) {
      this.onDidAcceptEmitter.fire({ inBackground });
    }
  }
  registerQuickNavigation() {
    return addDisposableListener(this.ui.container, EventType.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate) {
        return;
      }
      const keyboardEvent = new StandardKeyboardEvent(e);
      const keyCode = keyboardEvent.keyCode;
      const quickNavKeys = this._quickNavigate.keybindings;
      const wasTriggerKeyPressed = quickNavKeys.some((k) => {
        const [firstPart, chordPart] = k.getParts();
        if (chordPart) {
          return false;
        }
        if (firstPart.shiftKey && keyCode === 4) {
          if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
            return false;
          }
          return true;
        }
        if (firstPart.altKey && keyCode === 6) {
          return true;
        }
        if (firstPart.ctrlKey && keyCode === 5) {
          return true;
        }
        if (firstPart.metaKey && keyCode === 57) {
          return true;
        }
        return false;
      });
      if (wasTriggerKeyPressed) {
        if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          this.handleAccept(false);
        }
        this._quickNavigate = void 0;
      }
    });
  }
  update() {
    if (!this.visible) {
      return;
    }
    const hideInput = !!this._hideInput && this._items.length > 0;
    this.ui.container.classList.toggle("hidden-input", hideInput && !this.description);
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !hideInput,
      progressBar: !hideInput,
      visibleCount: true,
      count: this.canSelectMany,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: true,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    const ariaLabel = this.ariaLabel || this.placeholder || QuickPick.DEFAULT_ARIA_LABEL;
    if (this.ui.inputBox.ariaLabel !== ariaLabel) {
      this.ui.inputBox.ariaLabel = ariaLabel;
    }
    this.ui.list.matchOnDescription = this.matchOnDescription;
    this.ui.list.matchOnDetail = this.matchOnDetail;
    this.ui.list.matchOnLabel = this.matchOnLabel;
    this.ui.list.sortByLabel = this.sortByLabel;
    if (this.itemsUpdated) {
      this.itemsUpdated = false;
      this.ui.list.setElements(this.items);
      this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
      this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();
      this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());
      this.ui.count.setCount(this.ui.list.getCheckedCount());
      switch (this._itemActivation) {
        case ItemActivation.NONE:
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.SECOND:
          this.ui.list.focus(QuickInputListFocus.Second);
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.LAST:
          this.ui.list.focus(QuickInputListFocus.Last);
          this._itemActivation = ItemActivation.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    }
    if (this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany) {
      if (this.canSelectMany) {
        this.ui.list.clearFocus();
      } else {
        this.trySelectFirst();
      }
    }
    if (this.activeItemsUpdated) {
      this.activeItemsUpdated = false;
      this.activeItemsToConfirm = this._activeItems;
      this.ui.list.setFocusedElements(this.activeItems);
      if (this.activeItemsToConfirm === this._activeItems) {
        this.activeItemsToConfirm = null;
      }
    }
    if (this.selectedItemsUpdated) {
      this.selectedItemsUpdated = false;
      this.selectedItemsToConfirm = this._selectedItems;
      if (this.canSelectMany) {
        this.ui.list.setCheckedElements(this.selectedItems);
      } else {
        this.ui.list.setSelectedElements(this.selectedItems);
      }
      if (this.selectedItemsToConfirm === this._selectedItems) {
        this.selectedItemsToConfirm = null;
      }
    }
    this.ui.customButton.label = this.customLabel || "";
    this.ui.customButton.element.title = this.customHover || "";
    this.ui.setComboboxAccessibility(true);
    if (!visibilities.inputBox) {
      this.ui.list.domFocus();
      if (this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
  }
};
QuickPick.DEFAULT_ARIA_LABEL = localize("quickInputBox.ariaLabel", "Type to narrow down results.");
var QuickInputController = class extends Disposable {
  constructor(options) {
    super();
    this.options = options;
    this.comboboxAccessibility = false;
    this.enabled = true;
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.keyMods = { ctrlCmd: false, alt: false };
    this.controller = null;
    this.onShowEmitter = this._register(new Emitter());
    this.onShow = this.onShowEmitter.event;
    this.onHideEmitter = this._register(new Emitter());
    this.onHide = this.onHideEmitter.event;
    this.idPrefix = options.idPrefix;
    this.parentElement = options.container;
    this.styles = options.styles;
    this.registerKeyModsListeners();
  }
  registerKeyModsListeners() {
    const listener = (e) => {
      this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;
      this.keyMods.alt = e.altKey;
    };
    this._register(addDisposableListener(window, EventType.KEY_DOWN, listener, true));
    this._register(addDisposableListener(window, EventType.KEY_UP, listener, true));
    this._register(addDisposableListener(window, EventType.MOUSE_DOWN, listener, true));
  }
  getUI() {
    if (this.ui) {
      return this.ui;
    }
    const container = append(this.parentElement, $6(".quick-input-widget.show-file-icons"));
    container.tabIndex = -1;
    container.style.display = "none";
    const styleSheet = createStyleSheet(container);
    const titleBar = append(container, $6(".quick-input-titlebar"));
    const leftActionBar = this._register(new ActionBar(titleBar));
    leftActionBar.domNode.classList.add("quick-input-left-action-bar");
    const title = append(titleBar, $6(".quick-input-title"));
    const rightActionBar = this._register(new ActionBar(titleBar));
    rightActionBar.domNode.classList.add("quick-input-right-action-bar");
    const description1 = append(container, $6(".quick-input-description"));
    const headerContainer = append(container, $6(".quick-input-header"));
    const checkAll = append(headerContainer, $6("input.quick-input-check-all"));
    checkAll.type = "checkbox";
    this._register(addStandardDisposableListener(checkAll, EventType.CHANGE, (e) => {
      const checked = checkAll.checked;
      list.setAllVisibleChecked(checked);
    }));
    this._register(addDisposableListener(checkAll, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        inputBox.setFocus();
      }
    }));
    const description2 = append(headerContainer, $6(".quick-input-description"));
    const extraContainer = append(headerContainer, $6(".quick-input-and-message"));
    const filterContainer = append(extraContainer, $6(".quick-input-filter"));
    const inputBox = this._register(new QuickInputBox(filterContainer));
    inputBox.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const visibleCountContainer = append(filterContainer, $6(".quick-input-visible-count"));
    visibleCountContainer.setAttribute("aria-live", "polite");
    visibleCountContainer.setAttribute("aria-atomic", "true");
    const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") });
    const countContainer = append(filterContainer, $6(".quick-input-count"));
    countContainer.setAttribute("aria-live", "polite");
    const count = new CountBadge(countContainer, { countFormat: localize({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") });
    const okContainer = append(headerContainer, $6(".quick-input-action"));
    const ok2 = new Button(okContainer);
    ok2.label = localize("ok", "OK");
    this._register(ok2.onDidClick((e) => {
      this.onDidAcceptEmitter.fire();
    }));
    const customButtonContainer = append(headerContainer, $6(".quick-input-action"));
    const customButton = new Button(customButtonContainer);
    customButton.label = localize("custom", "Custom");
    this._register(customButton.onDidClick((e) => {
      this.onDidCustomEmitter.fire();
    }));
    const message = append(extraContainer, $6(`#${this.idPrefix}message.quick-input-message`));
    const list = this._register(new QuickInputList(container, this.idPrefix + "list", this.options));
    this._register(list.onChangedAllVisibleChecked((checked) => {
      checkAll.checked = checked;
    }));
    this._register(list.onChangedVisibleCount((c) => {
      visibleCount.setCount(c);
    }));
    this._register(list.onChangedCheckedCount((c) => {
      count.setCount(c);
    }));
    this._register(list.onLeave(() => {
      setTimeout(() => {
        inputBox.setFocus();
        if (this.controller instanceof QuickPick && this.controller.canSelectMany) {
          list.clearFocus();
        }
      }, 0);
    }));
    this._register(list.onDidChangeFocus(() => {
      if (this.comboboxAccessibility) {
        this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
      }
    }));
    const progressBar = new ProgressBar(container);
    progressBar.getContainer().classList.add("quick-input-progress");
    const focusTracker = trackFocus(container);
    this._register(focusTracker);
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : void 0;
    }, true));
    this._register(focusTracker.onDidBlur(() => {
      if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {
        this.hide(QuickInputHideReason.Blur);
      }
      this.previousFocusElement = void 0;
    }));
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      inputBox.setFocus();
    }));
    this._register(addDisposableListener(container, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 3:
          EventHelper.stop(e, true);
          this.onDidAcceptEmitter.fire();
          break;
        case 9:
          EventHelper.stop(e, true);
          this.hide(QuickInputHideReason.Gesture);
          break;
        case 2:
          if (!event.altKey && !event.ctrlKey && !event.metaKey) {
            const selectors = [".action-label.codicon"];
            if (container.classList.contains("show-checkboxes")) {
              selectors.push("input");
            } else {
              selectors.push("input[type=text]");
            }
            if (this.getUI().list.isDisplayed()) {
              selectors.push(".monaco-list");
            }
            const stops = container.querySelectorAll(selectors.join(", "));
            if (event.shiftKey && event.target === stops[0]) {
              EventHelper.stop(e, true);
              stops[stops.length - 1].focus();
            } else if (!event.shiftKey && event.target === stops[stops.length - 1]) {
              EventHelper.stop(e, true);
              stops[0].focus();
            }
          }
          break;
      }
    }));
    this.ui = {
      container,
      styleSheet,
      leftActionBar,
      titleBar,
      title,
      description1,
      description2,
      rightActionBar,
      checkAll,
      filterContainer,
      inputBox,
      visibleCountContainer,
      visibleCount,
      countContainer,
      count,
      okContainer,
      ok: ok2,
      message,
      customButtonContainer,
      customButton,
      list,
      progressBar,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: false,
      keyMods: this.keyMods,
      isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
      show: (controller) => this.show(controller),
      hide: () => this.hide(),
      setVisibilities: (visibilities) => this.setVisibilities(visibilities),
      setComboboxAccessibility: (enabled) => this.setComboboxAccessibility(enabled),
      setEnabled: (enabled) => this.setEnabled(enabled),
      setContextKey: (contextKey) => this.options.setContextKey(contextKey)
    };
    this.updateStyles();
    return this.ui;
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return new Promise((doResolve, reject) => {
      let resolve = (result) => {
        resolve = doResolve;
        if (options.onKeyMods) {
          options.onKeyMods(input.keyMods);
        }
        doResolve(result);
      };
      if (token.isCancellationRequested) {
        resolve(void 0);
        return;
      }
      const input = this.createQuickPick();
      let activeItem;
      const disposables = [
        input,
        input.onDidAccept(() => {
          if (input.canSelectMany) {
            resolve(input.selectedItems.slice());
            input.hide();
          } else {
            const result = input.activeItems[0];
            if (result) {
              resolve(result);
              input.hide();
            }
          }
        }),
        input.onDidChangeActive((items) => {
          const focused = items[0];
          if (focused && options.onDidFocus) {
            options.onDidFocus(focused);
          }
        }),
        input.onDidChangeSelection((items) => {
          if (!input.canSelectMany) {
            const result = items[0];
            if (result) {
              resolve(result);
              input.hide();
            }
          }
        }),
        input.onDidTriggerItemButton((event) => options.onDidTriggerItemButton && options.onDidTriggerItemButton(Object.assign(Object.assign({}, event), { removeItem: () => {
          const index = input.items.indexOf(event.item);
          if (index !== -1) {
            const items = input.items.slice();
            const removed = items.splice(index, 1);
            const activeItems = input.activeItems.filter((ai) => ai !== removed[0]);
            input.items = items;
            if (activeItems) {
              input.activeItems = activeItems;
            }
          }
        } }))),
        input.onDidChangeValue((value) => {
          if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
            input.activeItems = [activeItem];
          }
        }),
        token.onCancellationRequested(() => {
          input.hide();
        }),
        input.onDidHide(() => {
          dispose(disposables);
          resolve(void 0);
        })
      ];
      input.title = options.title;
      input.canSelectMany = !!options.canPickMany;
      input.placeholder = options.placeHolder;
      input.ignoreFocusOut = !!options.ignoreFocusLost;
      input.matchOnDescription = !!options.matchOnDescription;
      input.matchOnDetail = !!options.matchOnDetail;
      input.matchOnLabel = options.matchOnLabel === void 0 || options.matchOnLabel;
      input.autoFocusOnList = options.autoFocusOnList === void 0 || options.autoFocusOnList;
      input.quickNavigate = options.quickNavigate;
      input.contextKey = options.contextKey;
      input.busy = true;
      Promise.all([picks, options.activeItem]).then(([items, _activeItem]) => {
        activeItem = _activeItem;
        input.busy = false;
        input.items = items;
        if (input.canSelectMany) {
          input.selectedItems = items.filter((item) => item.type !== "separator" && item.picked);
        }
        if (activeItem) {
          input.activeItems = [activeItem];
        }
      });
      input.show();
      Promise.resolve(picks).then(void 0, (err) => {
        reject(err);
        input.hide();
      });
    });
  }
  createQuickPick() {
    const ui = this.getUI();
    return new QuickPick(ui);
  }
  show(controller) {
    const ui = this.getUI();
    this.onShowEmitter.fire();
    const oldController = this.controller;
    this.controller = controller;
    if (oldController) {
      oldController.didHide();
    }
    this.setEnabled(true);
    ui.leftActionBar.clear();
    ui.title.textContent = "";
    ui.description1.textContent = "";
    ui.description2.textContent = "";
    ui.rightActionBar.clear();
    ui.checkAll.checked = false;
    ui.inputBox.placeholder = "";
    ui.inputBox.password = false;
    ui.inputBox.showDecoration(severity_default.Ignore);
    ui.visibleCount.setCount(0);
    ui.count.setCount(0);
    reset(ui.message);
    ui.progressBar.stop();
    ui.list.setElements([]);
    ui.list.matchOnDescription = false;
    ui.list.matchOnDetail = false;
    ui.list.matchOnLabel = true;
    ui.list.sortByLabel = true;
    ui.ignoreFocusOut = false;
    this.setComboboxAccessibility(false);
    ui.inputBox.ariaLabel = "";
    const backKeybindingLabel = this.options.backKeybindingLabel();
    backButton.tooltip = backKeybindingLabel ? localize("quickInput.backWithKeybinding", "Back ({0})", backKeybindingLabel) : localize("quickInput.back", "Back");
    ui.container.style.display = "";
    this.updateLayout();
    ui.inputBox.setFocus();
  }
  setVisibilities(visibilities) {
    const ui = this.getUI();
    ui.title.style.display = visibilities.title ? "" : "none";
    ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.checkAll.style.display = visibilities.checkAll ? "" : "none";
    ui.filterContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.visibleCountContainer.style.display = visibilities.visibleCount ? "" : "none";
    ui.countContainer.style.display = visibilities.count ? "" : "none";
    ui.okContainer.style.display = visibilities.ok ? "" : "none";
    ui.customButtonContainer.style.display = visibilities.customButton ? "" : "none";
    ui.message.style.display = visibilities.message ? "" : "none";
    ui.progressBar.getContainer().style.display = visibilities.progressBar ? "" : "none";
    ui.list.display(!!visibilities.list);
    ui.container.classList[visibilities.checkBox ? "add" : "remove"]("show-checkboxes");
    this.updateLayout();
  }
  setComboboxAccessibility(enabled) {
    if (enabled !== this.comboboxAccessibility) {
      const ui = this.getUI();
      this.comboboxAccessibility = enabled;
      if (this.comboboxAccessibility) {
        ui.inputBox.setAttribute("role", "combobox");
        ui.inputBox.setAttribute("aria-haspopup", "true");
        ui.inputBox.setAttribute("aria-autocomplete", "list");
        ui.inputBox.setAttribute("aria-activedescendant", ui.list.getActiveDescendant() || "");
      } else {
        ui.inputBox.removeAttribute("role");
        ui.inputBox.removeAttribute("aria-haspopup");
        ui.inputBox.removeAttribute("aria-autocomplete");
        ui.inputBox.removeAttribute("aria-activedescendant");
      }
    }
  }
  setEnabled(enabled) {
    if (enabled !== this.enabled) {
      this.enabled = enabled;
      for (const item of this.getUI().leftActionBar.viewItems) {
        item.getAction().enabled = enabled;
      }
      for (const item of this.getUI().rightActionBar.viewItems) {
        item.getAction().enabled = enabled;
      }
      this.getUI().checkAll.disabled = !enabled;
      this.getUI().ok.enabled = enabled;
      this.getUI().list.enabled = enabled;
    }
  }
  hide(reason) {
    var _a6;
    const controller = this.controller;
    if (controller) {
      const focusChanged = !((_a6 = this.ui) === null || _a6 === void 0 ? void 0 : _a6.container.contains(document.activeElement));
      this.controller = null;
      this.onHideEmitter.fire();
      this.getUI().container.style.display = "none";
      if (!focusChanged) {
        if (this.previousFocusElement && this.previousFocusElement.offsetParent) {
          this.previousFocusElement.focus();
          this.previousFocusElement = void 0;
        } else {
          this.options.returnFocus();
        }
      }
      controller.didHide(reason);
    }
  }
  layout(dimension, titleBarOffset) {
    this.dimension = dimension;
    this.titleBarOffset = titleBarOffset;
    this.updateLayout();
  }
  updateLayout() {
    if (this.ui) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const style = this.ui.container.style;
      const width = Math.min(this.dimension.width * 0.62, QuickInputController.MAX_WIDTH);
      style.width = width + "px";
      style.marginLeft = "-" + width / 2 + "px";
      this.ui.inputBox.layout();
      this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(styles) {
    this.styles = styles;
    this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: quickInputTitleBackground2, quickInputBackground: quickInputBackground2, quickInputForeground: quickInputForeground2, contrastBorder: contrastBorder2, widgetShadow: widgetShadow2 } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = quickInputTitleBackground2 ? quickInputTitleBackground2.toString() : "";
      this.ui.container.style.backgroundColor = quickInputBackground2 ? quickInputBackground2.toString() : "";
      this.ui.container.style.color = quickInputForeground2 ? quickInputForeground2.toString() : "";
      this.ui.container.style.border = contrastBorder2 ? `1px solid ${contrastBorder2}` : "";
      this.ui.container.style.boxShadow = widgetShadow2 ? `0 0 8px 2px ${widgetShadow2}` : "";
      this.ui.inputBox.style(this.styles.inputBox);
      this.ui.count.style(this.styles.countBadge);
      this.ui.ok.style(this.styles.button);
      this.ui.customButton.style(this.styles.button);
      this.ui.progressBar.style(this.styles.progressBar);
      this.ui.list.style(this.styles.list);
      const content = [];
      if (this.styles.list.pickerGroupBorder) {
        content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`);
      }
      if (this.styles.list.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`);
      }
      if (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) {
        content.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {");
        if (this.styles.keybindingLabel.keybindingLabelBackground) {
          content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBorder) {
          content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {
          content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelShadow) {
          content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelForeground) {
          content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);
        }
        content.push("}");
      }
      const newStyles = content.join("\n");
      if (newStyles !== this.ui.styleSheet.textContent) {
        this.ui.styleSheet.textContent = newStyles;
      }
    }
  }
};
QuickInputController.MAX_WIDTH = 600;

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickInput.js
var IQuickInputService = createDecorator("quickInputService");

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js
var DefaultQuickAccessFilterValue;
(function(DefaultQuickAccessFilterValue2) {
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["PRESERVE"] = 0] = "PRESERVE";
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["LAST"] = 1] = "LAST";
})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));
var Extensions4 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
var QuickAccessRegistry = class {
  constructor() {
    this.providers = [];
    this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(provider) {
    if (provider.prefix.length === 0) {
      this.defaultProvider = provider;
    } else {
      this.providers.push(provider);
    }
    this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);
    return toDisposable(() => {
      this.providers.splice(this.providers.indexOf(provider), 1);
      if (this.defaultProvider === provider) {
        this.defaultProvider = void 0;
      }
    });
  }
  getQuickAccessProviders() {
    return coalesce([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(prefix) {
    const result = prefix ? this.providers.find((provider) => prefix.startsWith(provider.prefix)) || void 0 : void 0;
    return result || this.defaultProvider;
  }
};
Registry.add(Extensions4.Quickaccess, new QuickAccessRegistry());

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickAccess.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickAccessController = class QuickAccessController2 extends Disposable {
  constructor(quickInputService, instantiationService) {
    super();
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.registry = Registry.as(Extensions4.Quickaccess);
    this.mapProviderToDescriptor = new Map();
    this.lastAcceptedPickerValues = new Map();
    this.visibleQuickAccess = void 0;
  }
  show(value = "", options) {
    this.doShowOrPick(value, false, options);
  }
  doShowOrPick(value, pick, options) {
    var _a6;
    const [provider, descriptor] = this.getOrInstantiateProvider(value);
    const visibleQuickAccess = this.visibleQuickAccess;
    const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;
    if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {
      if (value !== descriptor.prefix && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
        visibleQuickAccess.picker.value = value;
      }
      this.adjustValueSelection(visibleQuickAccess.picker, descriptor, options);
      return;
    }
    if (descriptor && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
      let newValue = void 0;
      if (visibleQuickAccess && visibleDescriptor && visibleDescriptor !== descriptor) {
        const newValueCandidateWithoutPrefix = visibleQuickAccess.value.substr(visibleDescriptor.prefix.length);
        if (newValueCandidateWithoutPrefix) {
          newValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;
        }
      }
      if (!newValue) {
        const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;
        if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {
          newValue = this.lastAcceptedPickerValues.get(descriptor);
        } else if (typeof defaultFilterValue === "string") {
          newValue = `${descriptor.prefix}${defaultFilterValue}`;
        }
      }
      if (typeof newValue === "string") {
        value = newValue;
      }
    }
    const disposables = new DisposableStore();
    const picker = disposables.add(this.quickInputService.createQuickPick());
    picker.value = value;
    this.adjustValueSelection(picker, descriptor, options);
    picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    picker.quickNavigate = options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration;
    picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess;
    if (typeof (options === null || options === void 0 ? void 0 : options.itemActivation) === "number" || (options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration)) {
      picker.itemActivation = (_a6 = options === null || options === void 0 ? void 0 : options.itemActivation) !== null && _a6 !== void 0 ? _a6 : ItemActivation.SECOND;
    }
    picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;
    picker.filterValue = (value2) => value2.substring(descriptor ? descriptor.prefix.length : 0);
    if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder) {
      picker.ariaLabel = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    }
    let pickPromise = void 0;
    let pickResolve = void 0;
    if (pick) {
      pickPromise = new Promise((resolve) => pickResolve = resolve);
      disposables.add(once(picker.onWillAccept)((e) => {
        e.veto();
        picker.hide();
      }));
    }
    disposables.add(this.registerPickerListeners(picker, provider, descriptor, value));
    const cts = disposables.add(new CancellationTokenSource());
    if (provider) {
      disposables.add(provider.provide(picker, cts.token));
    }
    once(picker.onDidHide)(() => {
      if (picker.selectedItems.length === 0) {
        cts.cancel();
      }
      disposables.dispose();
      pickResolve === null || pickResolve === void 0 ? void 0 : pickResolve(picker.selectedItems);
    });
    picker.show();
    if (pick) {
      return pickPromise;
    }
  }
  adjustValueSelection(picker, descriptor, options) {
    var _a6;
    let valueSelection;
    if (options === null || options === void 0 ? void 0 : options.preserveValue) {
      valueSelection = [picker.value.length, picker.value.length];
    } else {
      valueSelection = [(_a6 = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a6 !== void 0 ? _a6 : 0, picker.value.length];
    }
    picker.valueSelection = valueSelection;
  }
  registerPickerListeners(picker, provider, descriptor, value) {
    const disposables = new DisposableStore();
    const visibleQuickAccess = this.visibleQuickAccess = { picker, descriptor, value };
    disposables.add(toDisposable(() => {
      if (visibleQuickAccess === this.visibleQuickAccess) {
        this.visibleQuickAccess = void 0;
      }
    }));
    disposables.add(picker.onDidChangeValue((value2) => {
      const [providerForValue] = this.getOrInstantiateProvider(value2);
      if (providerForValue !== provider) {
        this.show(value2, { preserveValue: true });
      } else {
        visibleQuickAccess.value = value2;
      }
    }));
    if (descriptor) {
      disposables.add(picker.onDidAccept(() => {
        this.lastAcceptedPickerValues.set(descriptor, picker.value);
      }));
    }
    return disposables;
  }
  getOrInstantiateProvider(value) {
    const providerDescriptor = this.registry.getQuickAccessProvider(value);
    if (!providerDescriptor) {
      return [void 0, void 0];
    }
    let provider = this.mapProviderToDescriptor.get(providerDescriptor);
    if (!provider) {
      provider = this.instantiationService.createInstance(providerDescriptor.ctor);
      this.mapProviderToDescriptor.set(providerDescriptor, provider);
    }
    return [provider, providerDescriptor];
  }
};
QuickAccessController = __decorate19([
  __param17(0, IQuickInputService),
  __param17(1, IInstantiationService)
], QuickAccessController);

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickInputService = class QuickInputService2 extends Themable {
  constructor(instantiationService, contextKeyService, themeService, accessibilityService, layoutService) {
    super(themeService);
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.accessibilityService = accessibilityService;
    this.layoutService = layoutService;
    this.contexts = new Map();
  }
  get controller() {
    if (!this._controller) {
      this._controller = this._register(this.createController());
    }
    return this._controller;
  }
  get quickAccess() {
    if (!this._quickAccess) {
      this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));
    }
    return this._quickAccess;
  }
  createController(host = this.layoutService, options) {
    var _a6, _b;
    const defaultOptions3 = {
      idPrefix: "quickInput_",
      container: host.container,
      ignoreFocusOut: () => false,
      isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
      backKeybindingLabel: () => void 0,
      setContextKey: (id) => this.setContextKey(id),
      returnFocus: () => host.focus(),
      createList: (user, container, delegate, renderers, options2) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options2),
      styles: this.computeStyles()
    };
    const controller = this._register(new QuickInputController(Object.assign(Object.assign({}, defaultOptions3), options)));
    controller.layout(host.dimension, (_b = (_a6 = host.offset) === null || _a6 === void 0 ? void 0 : _a6.top) !== null && _b !== void 0 ? _b : 0);
    this._register(host.onDidLayout((dimension) => {
      var _a7, _b2;
      return controller.layout(dimension, (_b2 = (_a7 = host.offset) === null || _a7 === void 0 ? void 0 : _a7.top) !== null && _b2 !== void 0 ? _b2 : 0);
    }));
    this._register(controller.onShow(() => this.resetContextKeys()));
    this._register(controller.onHide(() => this.resetContextKeys()));
    return controller;
  }
  setContextKey(id) {
    let key;
    if (id) {
      key = this.contexts.get(id);
      if (!key) {
        key = new RawContextKey(id, false).bindTo(this.contextKeyService);
        this.contexts.set(id, key);
      }
    }
    if (key && key.get()) {
      return;
    }
    this.resetContextKeys();
    if (key) {
      key.set(true);
    }
  }
  resetContextKeys() {
    this.contexts.forEach((context) => {
      if (context.get()) {
        context.reset();
      }
    });
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.controller.pick(picks, options, token);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  updateStyles() {
    this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: Object.assign({}, computeStyles(this.theme, {
        quickInputBackground,
        quickInputForeground,
        quickInputTitleBackground,
        contrastBorder,
        widgetShadow
      })),
      inputBox: computeStyles(this.theme, {
        inputForeground,
        inputBackground,
        inputBorder,
        inputValidationInfoBackground,
        inputValidationInfoForeground,
        inputValidationInfoBorder,
        inputValidationWarningBackground,
        inputValidationWarningForeground,
        inputValidationWarningBorder,
        inputValidationErrorBackground,
        inputValidationErrorForeground,
        inputValidationErrorBorder
      }),
      countBadge: computeStyles(this.theme, {
        badgeBackground,
        badgeForeground,
        badgeBorder: contrastBorder
      }),
      button: computeStyles(this.theme, {
        buttonForeground,
        buttonBackground,
        buttonHoverBackground,
        buttonBorder: contrastBorder
      }),
      progressBar: computeStyles(this.theme, {
        progressBarBackground
      }),
      keybindingLabel: computeStyles(this.theme, {
        keybindingLabelBackground,
        keybindingLabelForeground,
        keybindingLabelBorder,
        keybindingLabelBottomBorder,
        keybindingLabelShadow: widgetShadow
      }),
      list: computeStyles(this.theme, {
        listBackground: quickInputBackground,
        listInactiveFocusForeground: quickInputListFocusForeground,
        listInactiveSelectionIconForeground: quickInputListFocusIconForeground,
        listInactiveFocusBackground: quickInputListFocusBackground,
        listFocusOutline: activeContrastBorder,
        listInactiveFocusOutline: activeContrastBorder,
        pickerGroupBorder,
        pickerGroupForeground
      })
    };
  }
};
QuickInputService = __decorate20([
  __param18(0, IInstantiationService),
  __param18(1, IContextKeyService),
  __param18(2, IThemeService),
  __param18(3, IAccessibilityService),
  __param18(4, ILayoutService)
], QuickInputService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputServiceImpl.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EditorScopedQuickInputServiceImpl = class EditorScopedQuickInputServiceImpl2 extends QuickInputService {
  constructor(editor2, instantiationService, contextKeyService, themeService, accessibilityService, layoutService) {
    super(instantiationService, contextKeyService, themeService, accessibilityService, layoutService);
    this.host = void 0;
    const contribution = QuickInputEditorContribution.get(editor2);
    this.host = {
      _serviceBrand: void 0,
      get container() {
        return contribution.widget.getDomNode();
      },
      get dimension() {
        return editor2.getLayoutInfo();
      },
      get onDidLayout() {
        return editor2.onDidLayoutChange;
      },
      focus: () => editor2.focus()
    };
  }
  createController() {
    return super.createController(this.host);
  }
};
EditorScopedQuickInputServiceImpl = __decorate21([
  __param19(1, IInstantiationService),
  __param19(2, IContextKeyService),
  __param19(3, IThemeService),
  __param19(4, IAccessibilityService),
  __param19(5, ILayoutService)
], EditorScopedQuickInputServiceImpl);
var StandaloneQuickInputServiceImpl = class StandaloneQuickInputServiceImpl2 {
  constructor(instantiationService, codeEditorService) {
    this.instantiationService = instantiationService;
    this.codeEditorService = codeEditorService;
    this.mapEditorToService = new Map();
  }
  get activeService() {
    const editor2 = this.codeEditorService.getFocusedCodeEditor();
    if (!editor2) {
      throw new Error("Quick input service needs a focused editor to work.");
    }
    let quickInputService = this.mapEditorToService.get(editor2);
    if (!quickInputService) {
      const newQuickInputService = quickInputService = this.instantiationService.createInstance(EditorScopedQuickInputServiceImpl, editor2);
      this.mapEditorToService.set(editor2, quickInputService);
      once(editor2.onDidDispose)(() => {
        newQuickInputService.dispose();
        this.mapEditorToService.delete(editor2);
      });
    }
    return quickInputService;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.activeService.pick(picks, options, token);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
};
StandaloneQuickInputServiceImpl = __decorate21([
  __param19(0, IInstantiationService),
  __param19(1, ICodeEditorService)
], StandaloneQuickInputServiceImpl);
var QuickInputEditorContribution = class {
  constructor(editor2) {
    this.editor = editor2;
    this.widget = new QuickInputEditorWidget(this.editor);
  }
  static get(editor2) {
    return editor2.getContribution(QuickInputEditorContribution.ID);
  }
  dispose() {
    this.widget.dispose();
  }
};
QuickInputEditorContribution.ID = "editor.controller.quickInput";
var QuickInputEditorWidget = class {
  constructor(codeEditor) {
    this.codeEditor = codeEditor;
    this.domNode = document.createElement("div");
    this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return QuickInputEditorWidget.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return { preference: 2 };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
QuickInputEditorWidget.ID = "editor.contrib.quickInputWidget";
registerEditorContribution(QuickInputEditorContribution.ID, QuickInputEditorContribution);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
var StaticServices;
(function(StaticServices2) {
  const _serviceCollection = new ServiceCollection();
  class LazyStaticService {
    constructor(serviceId, factory) {
      this._serviceId = serviceId;
      this._factory = factory;
      this._value = null;
    }
    get id() {
      return this._serviceId;
    }
    get(overrides) {
      if (!this._value) {
        if (overrides) {
          this._value = overrides[this._serviceId.toString()];
        }
        if (!this._value) {
          this._value = this._factory(overrides);
        }
        if (!this._value) {
          throw new Error("Service " + this._serviceId + " is missing!");
        }
        _serviceCollection.set(this._serviceId, this._value);
      }
      return this._value;
    }
  }
  StaticServices2.LazyStaticService = LazyStaticService;
  let _all = [];
  function define2(serviceId, factory) {
    let r = new LazyStaticService(serviceId, factory);
    _all.push(r);
    return r;
  }
  function init(overrides) {
    let result = new ServiceCollection();
    for (const [id, descriptor] of getSingletonServiceDescriptors()) {
      result.set(id, descriptor);
    }
    for (let serviceId in overrides) {
      if (overrides.hasOwnProperty(serviceId)) {
        result.set(createDecorator(serviceId), overrides[serviceId]);
      }
    }
    _all.forEach((service) => result.set(service.id, service.get(overrides)));
    let instantiationService = new InstantiationService(result, true);
    result.set(IInstantiationService, instantiationService);
    return [result, instantiationService];
  }
  StaticServices2.init = init;
  StaticServices2.instantiationService = define2(IInstantiationService, () => new InstantiationService(_serviceCollection, true));
  const configurationServiceImpl = new SimpleConfigurationService();
  StaticServices2.configurationService = define2(IConfigurationService, () => configurationServiceImpl);
  StaticServices2.resourceConfigurationService = define2(ITextResourceConfigurationService, () => new SimpleResourceConfigurationService(configurationServiceImpl));
  StaticServices2.resourcePropertiesService = define2(ITextResourcePropertiesService, () => new SimpleResourcePropertiesService(configurationServiceImpl));
  StaticServices2.contextService = define2(IWorkspaceContextService, () => new SimpleWorkspaceContextService());
  StaticServices2.labelService = define2(ILabelService, () => new SimpleUriLabelService());
  StaticServices2.telemetryService = define2(ITelemetryService, () => new StandaloneTelemetryService());
  StaticServices2.dialogService = define2(IDialogService, () => new SimpleDialogService());
  StaticServices2.notificationService = define2(INotificationService, () => new SimpleNotificationService());
  StaticServices2.markerService = define2(IMarkerService, () => new MarkerService());
  StaticServices2.modeService = define2(IModeService, (o) => new ModeServiceImpl());
  StaticServices2.standaloneThemeService = define2(IStandaloneThemeService, () => new StandaloneThemeServiceImpl());
  StaticServices2.logService = define2(ILogService, () => new LogService(new ConsoleLogger()));
  StaticServices2.undoRedoService = define2(IUndoRedoService, (o) => new UndoRedoService(StaticServices2.dialogService.get(o), StaticServices2.notificationService.get(o)));
  StaticServices2.modelService = define2(IModelService, (o) => new ModelServiceImpl(StaticServices2.configurationService.get(o), StaticServices2.resourcePropertiesService.get(o), StaticServices2.standaloneThemeService.get(o), StaticServices2.logService.get(o), StaticServices2.undoRedoService.get(o)));
  StaticServices2.markerDecorationsService = define2(IMarkerDecorationsService, (o) => new MarkerDecorationsService(StaticServices2.modelService.get(o), StaticServices2.markerService.get(o)));
  StaticServices2.contextKeyService = define2(IContextKeyService, (o) => new ContextKeyService(StaticServices2.configurationService.get(o)));
  StaticServices2.codeEditorService = define2(ICodeEditorService, (o) => new StandaloneCodeEditorServiceImpl(null, StaticServices2.contextKeyService.get(o), StaticServices2.standaloneThemeService.get(o)));
  StaticServices2.editorProgressService = define2(IEditorProgressService, () => new SimpleEditorProgressService());
  StaticServices2.storageService = define2(IStorageService, () => new InMemoryStorageService());
  StaticServices2.editorWorkerService = define2(IEditorWorkerService, (o) => new EditorWorkerServiceImpl(StaticServices2.modelService.get(o), StaticServices2.resourceConfigurationService.get(o), StaticServices2.logService.get(o)));
})(StaticServices || (StaticServices = {}));
var DynamicStandaloneServices = class extends Disposable {
  constructor(domElement, overrides) {
    super();
    const [_serviceCollection, _instantiationService] = StaticServices.init(overrides);
    this._serviceCollection = _serviceCollection;
    this._instantiationService = _instantiationService;
    const configurationService = this.get(IConfigurationService);
    const notificationService = this.get(INotificationService);
    const telemetryService = this.get(ITelemetryService);
    const themeService = this.get(IThemeService);
    const logService = this.get(ILogService);
    const contextKeyService = this.get(IContextKeyService);
    let ensure = (serviceId, factory) => {
      let value = null;
      if (overrides) {
        value = overrides[serviceId.toString()];
      }
      if (!value) {
        value = factory();
      }
      this._serviceCollection.set(serviceId, value);
      return value;
    };
    ensure(IAccessibilityService, () => new AccessibilityService(contextKeyService, configurationService));
    ensure(IListService, () => new ListService(themeService));
    let commandService = ensure(ICommandService, () => new StandaloneCommandService(this._instantiationService));
    let keybindingService = ensure(IKeybindingService, () => this._register(new StandaloneKeybindingService(contextKeyService, commandService, telemetryService, notificationService, logService, domElement)));
    let layoutService = ensure(ILayoutService, () => new SimpleLayoutService(StaticServices.codeEditorService.get(ICodeEditorService), domElement));
    ensure(IQuickInputService, () => new StandaloneQuickInputServiceImpl(_instantiationService, StaticServices.codeEditorService.get(ICodeEditorService)));
    let contextViewService = ensure(IContextViewService, () => this._register(new ContextViewService(layoutService)));
    ensure(IClipboardService, () => new BrowserClipboardService());
    ensure(IContextMenuService, () => {
      const contextMenuService = new ContextMenuService(telemetryService, notificationService, contextViewService, keybindingService, themeService);
      contextMenuService.configure({ blockMouse: false });
      return this._register(contextMenuService);
    });
    ensure(IMenuService, () => new MenuService(commandService));
    ensure(IBulkEditService, () => new SimpleBulkEditService(StaticServices.modelService.get(IModelService)));
  }
  get(serviceId) {
    let r = this._serviceCollection.get(serviceId);
    if (!r) {
      throw new Error("Missing service " + serviceId);
    }
    return r;
  }
  set(serviceId, instance) {
    this._serviceCollection.set(serviceId, instance);
  }
  has(serviceId) {
    return this._serviceCollection.has(serviceId);
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
function withAllStandaloneServices(domElement, override, callback) {
  let services = new DynamicStandaloneServices(domElement, override);
  let simpleEditorModelResolverService = null;
  if (!services.has(ITextModelService)) {
    simpleEditorModelResolverService = new SimpleEditorModelResolverService(StaticServices.modelService.get());
    services.set(ITextModelService, simpleEditorModelResolverService);
  }
  if (!services.has(IOpenerService)) {
    services.set(IOpenerService, new OpenerService(services.get(ICodeEditorService), services.get(ICommandService)));
  }
  let result = callback(services);
  if (simpleEditorModelResolverService) {
    simpleEditorModelResolverService.setEditor(result);
  }
  return result;
}
function create(domElement, options, override) {
  return withAllStandaloneServices(domElement, override || {}, (services) => {
    return new StandaloneEditor(domElement, options, services, services.get(IInstantiationService), services.get(ICodeEditorService), services.get(ICommandService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IStandaloneThemeService), services.get(INotificationService), services.get(IConfigurationService), services.get(IAccessibilityService), services.get(IModelService), services.get(IModeService));
  });
}
function onDidCreateEditor(listener) {
  return StaticServices.codeEditorService.get().onCodeEditorAdd((editor2) => {
    listener(editor2);
  });
}
function createDiffEditor(domElement, options, override) {
  return withAllStandaloneServices(domElement, override || {}, (services) => {
    return new StandaloneDiffEditor(domElement, options, services, services.get(IInstantiationService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IEditorWorkerService), services.get(ICodeEditorService), services.get(IStandaloneThemeService), services.get(INotificationService), services.get(IConfigurationService), services.get(IContextMenuService), services.get(IEditorProgressService), services.get(IClipboardService));
  });
}
function createDiffNavigator(diffEditor, opts) {
  return new DiffNavigator(diffEditor, opts);
}
function createModel(value, language, uri) {
  return createTextModel(StaticServices.modelService.get(), StaticServices.modeService.get(), value, language, uri);
}
function setModelLanguage(model, languageId) {
  StaticServices.modelService.get().setMode(model, StaticServices.modeService.get().create(languageId));
}
function setModelMarkers(model, owner, markers) {
  if (model) {
    StaticServices.markerService.get().changeOne(owner, model.uri, markers);
  }
}
function getModelMarkers(filter) {
  return StaticServices.markerService.get().read(filter);
}
function onDidChangeMarkers(listener) {
  return StaticServices.markerService.get().onMarkerChanged(listener);
}
function getModel(uri) {
  return StaticServices.modelService.get().getModel(uri);
}
function getModels() {
  return StaticServices.modelService.get().getModels();
}
function onDidCreateModel(listener) {
  return StaticServices.modelService.get().onModelAdded(listener);
}
function onWillDisposeModel(listener) {
  return StaticServices.modelService.get().onModelRemoved(listener);
}
function onDidChangeModelLanguage(listener) {
  return StaticServices.modelService.get().onModelModeChanged((e) => {
    listener({
      model: e.model,
      oldLanguage: e.oldModeId
    });
  });
}
function createWebWorker2(opts) {
  return createWebWorker(StaticServices.modelService.get(), opts);
}
function colorizeElement(domNode, options) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(domNode);
  return Colorizer.colorizeElement(themeService, StaticServices.modeService.get(), domNode, options);
}
function colorize(text, languageId, options) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorize(StaticServices.modeService.get(), text, languageId, options);
}
function colorizeModelLine(model, lineNumber, tabSize = 4) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
function getSafeTokenizationSupport(language) {
  let tokenizationSupport = TokenizationRegistry.get(language);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  return {
    getInitialState: () => NULL_STATE,
    tokenize: (line, hasEOL, state, deltaOffset) => nullTokenize(language, line, state, deltaOffset)
  };
}
function tokenize(text, languageId) {
  let modeService = StaticServices.modeService.get();
  modeService.triggerMode(languageId);
  let tokenizationSupport = getSafeTokenizationSupport(languageId);
  let lines = splitLines(text);
  let result = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    let line = lines[i];
    let tokenizationResult = tokenizationSupport.tokenize(line, true, state, 0);
    result[i] = tokenizationResult.tokens;
    state = tokenizationResult.endState;
  }
  return result;
}
function defineTheme(themeName, themeData) {
  StaticServices.standaloneThemeService.get().defineTheme(themeName, themeData);
}
function setTheme(themeName) {
  StaticServices.standaloneThemeService.get().setTheme(themeName);
}
function remeasureFonts() {
  clearAllFontInfos();
}
function registerCommand(id, handler) {
  return CommandsRegistry.registerCommand({ id, handler });
}
function createMonacoEditorAPI() {
  return {
    create,
    onDidCreateEditor,
    createDiffEditor,
    createDiffNavigator,
    createModel,
    setModelLanguage,
    setModelMarkers,
    getModelMarkers,
    onDidChangeMarkers,
    getModels,
    getModel,
    onDidCreateModel,
    onWillDisposeModel,
    onDidChangeModelLanguage,
    createWebWorker: createWebWorker2,
    colorizeElement,
    colorize,
    colorizeModelLine,
    tokenize,
    defineTheme,
    setTheme,
    remeasureFonts,
    registerCommand,
    AccessibilitySupport,
    ContentWidgetPositionPreference,
    CursorChangeReason,
    DefaultEndOfLine,
    EditorAutoIndentStrategy,
    EditorOption,
    EndOfLinePreference,
    EndOfLineSequence,
    MinimapPosition: MinimapPosition2,
    MouseTargetType,
    OverlayWidgetPositionPreference,
    OverviewRulerLane: OverviewRulerLane2,
    RenderLineNumbersType,
    RenderMinimap,
    ScrollbarVisibility,
    ScrollType,
    TextEditorCursorBlinkingStyle,
    TextEditorCursorStyle,
    TrackedRangeStickiness,
    WrappingIndent,
    ConfigurationChangedEvent,
    BareFontInfo,
    FontInfo,
    TextModelResolvedOptions,
    FindMatch,
    EditorType,
    EditorOptions
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js
function isArrayOf(elemType, obj) {
  if (!obj) {
    return false;
  }
  if (!Array.isArray(obj)) {
    return false;
  }
  for (const el of obj) {
    if (!elemType(el)) {
      return false;
    }
  }
  return true;
}
function bool(prop, defValue) {
  if (typeof prop === "boolean") {
    return prop;
  }
  return defValue;
}
function string(prop, defValue) {
  if (typeof prop === "string") {
    return prop;
  }
  return defValue;
}
function arrayToHash(array) {
  const result = {};
  for (const e of array) {
    result[e] = true;
  }
  return result;
}
function createKeywordMatcher(arr, caseInsensitive = false) {
  if (caseInsensitive) {
    arr = arr.map(function(x) {
      return x.toLowerCase();
    });
  }
  const hash = arrayToHash(arr);
  if (caseInsensitive) {
    return function(word) {
      return hash[word.toLowerCase()] !== void 0 && hash.hasOwnProperty(word.toLowerCase());
    };
  } else {
    return function(word) {
      return hash[word] !== void 0 && hash.hasOwnProperty(word);
    };
  }
}
function compileRegExp(lexer, str) {
  str = str.replace(/@@/g, ``);
  let n = 0;
  let hadExpansion;
  do {
    hadExpansion = false;
    str = str.replace(/@(\w+)/g, function(s, attr) {
      hadExpansion = true;
      let sub = "";
      if (typeof lexer[attr] === "string") {
        sub = lexer[attr];
      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {
        sub = lexer[attr].source;
      } else {
        if (lexer[attr] === void 0) {
          throw createError(lexer, "language definition does not contain attribute '" + attr + "', used at: " + str);
        } else {
          throw createError(lexer, "attribute reference '" + attr + "' must be a string, used at: " + str);
        }
      }
      return empty(sub) ? "" : "(?:" + sub + ")";
    });
    n++;
  } while (hadExpansion && n < 5);
  str = str.replace(/\x01/g, "@");
  let flags = (lexer.ignoreCase ? "i" : "") + (lexer.unicode ? "u" : "");
  return new RegExp(str, flags);
}
function selectScrutinee(id, matches, state, num) {
  if (num < 0) {
    return id;
  }
  if (num < matches.length) {
    return matches[num];
  }
  if (num >= 100) {
    num = num - 100;
    let parts = state.split(".");
    parts.unshift(state);
    if (num < parts.length) {
      return parts[num];
    }
  }
  return null;
}
function createGuard(lexer, ruleName, tkey, val) {
  let scrut = -1;
  let oppat = tkey;
  let matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  if (matches) {
    if (matches[3]) {
      scrut = parseInt(matches[3]);
      if (matches[2]) {
        scrut = scrut + 100;
      }
    }
    oppat = matches[4];
  }
  let op = "~";
  let pat = oppat;
  if (!oppat || oppat.length === 0) {
    op = "!=";
    pat = "";
  } else if (/^\w*$/.test(pat)) {
    op = "==";
  } else {
    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
    if (matches) {
      op = matches[1];
      pat = matches[2];
    }
  }
  let tester;
  if ((op === "~" || op === "!~") && /^(\w|\|)*$/.test(pat)) {
    let inWords = createKeywordMatcher(pat.split("|"), lexer.ignoreCase);
    tester = function(s) {
      return op === "~" ? inWords(s) : !inWords(s);
    };
  } else if (op === "@" || op === "!@") {
    let words = lexer[pat];
    if (!words) {
      throw createError(lexer, "the @ match target '" + pat + "' is not defined, in rule: " + ruleName);
    }
    if (!isArrayOf(function(elem) {
      return typeof elem === "string";
    }, words)) {
      throw createError(lexer, "the @ match target '" + pat + "' must be an array of strings, in rule: " + ruleName);
    }
    let inWords = createKeywordMatcher(words, lexer.ignoreCase);
    tester = function(s) {
      return op === "@" ? inWords(s) : !inWords(s);
    };
  } else if (op === "~" || op === "!~") {
    if (pat.indexOf("$") < 0) {
      let re = compileRegExp(lexer, "^" + pat + "$");
      tester = function(s) {
        return op === "~" ? re.test(s) : !re.test(s);
      };
    } else {
      tester = function(s, id, matches2, state) {
        let re = compileRegExp(lexer, "^" + substituteMatches(lexer, pat, id, matches2, state) + "$");
        return re.test(s);
      };
    }
  } else {
    if (pat.indexOf("$") < 0) {
      let patx = fixCase(lexer, pat);
      tester = function(s) {
        return op === "==" ? s === patx : s !== patx;
      };
    } else {
      let patx = fixCase(lexer, pat);
      tester = function(s, id, matches2, state, eos) {
        let patexp = substituteMatches(lexer, patx, id, matches2, state);
        return op === "==" ? s === patexp : s !== patexp;
      };
    }
  }
  if (scrut === -1) {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        return tester(id, id, matches2, state, eos);
      }
    };
  } else {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        let scrutinee = selectScrutinee(id, matches2, state, scrut);
        return tester(!scrutinee ? "" : scrutinee, id, matches2, state, eos);
      }
    };
  }
}
function compileAction(lexer, ruleName, action) {
  if (!action) {
    return { token: "" };
  } else if (typeof action === "string") {
    return action;
  } else if (action.token || action.token === "") {
    if (typeof action.token !== "string") {
      throw createError(lexer, "a 'token' attribute must be of type string, in rule: " + ruleName);
    } else {
      let newAction = { token: action.token };
      if (action.token.indexOf("$") >= 0) {
        newAction.tokenSubst = true;
      }
      if (typeof action.bracket === "string") {
        if (action.bracket === "@open") {
          newAction.bracket = 1;
        } else if (action.bracket === "@close") {
          newAction.bracket = -1;
        } else {
          throw createError(lexer, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + ruleName);
        }
      }
      if (action.next) {
        if (typeof action.next !== "string") {
          throw createError(lexer, "the next state must be a string value in rule: " + ruleName);
        } else {
          let next = action.next;
          if (!/^(@pop|@push|@popall)$/.test(next)) {
            if (next[0] === "@") {
              next = next.substr(1);
            }
            if (next.indexOf("$") < 0) {
              if (!stateExists(lexer, substituteMatches(lexer, next, "", [], ""))) {
                throw createError(lexer, "the next state '" + action.next + "' is not defined in rule: " + ruleName);
              }
            }
          }
          newAction.next = next;
        }
      }
      if (typeof action.goBack === "number") {
        newAction.goBack = action.goBack;
      }
      if (typeof action.switchTo === "string") {
        newAction.switchTo = action.switchTo;
      }
      if (typeof action.log === "string") {
        newAction.log = action.log;
      }
      if (typeof action.nextEmbedded === "string") {
        newAction.nextEmbedded = action.nextEmbedded;
        lexer.usesEmbedded = true;
      }
      return newAction;
    }
  } else if (Array.isArray(action)) {
    let results = [];
    for (let i = 0, len = action.length; i < len; i++) {
      results[i] = compileAction(lexer, ruleName, action[i]);
    }
    return { group: results };
  } else if (action.cases) {
    let cases = [];
    for (let tkey in action.cases) {
      if (action.cases.hasOwnProperty(tkey)) {
        const val = compileAction(lexer, ruleName, action.cases[tkey]);
        if (tkey === "@default" || tkey === "@" || tkey === "") {
          cases.push({ test: void 0, value: val, name: tkey });
        } else if (tkey === "@eos") {
          cases.push({ test: function(id, matches, state, eos) {
            return eos;
          }, value: val, name: tkey });
        } else {
          cases.push(createGuard(lexer, ruleName, tkey, val));
        }
      }
    }
    const def = lexer.defaultToken;
    return {
      test: function(id, matches, state, eos) {
        for (const _case of cases) {
          const didmatch = !_case.test || _case.test(id, matches, state, eos);
          if (didmatch) {
            return _case.value;
          }
        }
        return def;
      }
    };
  } else {
    throw createError(lexer, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + ruleName);
  }
}
var Rule = class {
  constructor(name) {
    this.regex = new RegExp("");
    this.action = { token: "" };
    this.matchOnlyAtLineStart = false;
    this.name = "";
    this.name = name;
  }
  setRegex(lexer, re) {
    let sregex;
    if (typeof re === "string") {
      sregex = re;
    } else if (re instanceof RegExp) {
      sregex = re.source;
    } else {
      throw createError(lexer, "rules must start with a match string or regular expression: " + this.name);
    }
    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === "^";
    this.name = this.name + ": " + sregex;
    this.regex = compileRegExp(lexer, "^(?:" + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ")");
  }
  setAction(lexer, act) {
    this.action = compileAction(lexer, this.name, act);
  }
};
function compile(languageId, json) {
  if (!json || typeof json !== "object") {
    throw new Error("Monarch: expecting a language definition object");
  }
  let lexer = {};
  lexer.languageId = languageId;
  lexer.includeLF = bool(json.includeLF, false);
  lexer.noThrow = false;
  lexer.maxStack = 100;
  lexer.start = typeof json.start === "string" ? json.start : null;
  lexer.ignoreCase = bool(json.ignoreCase, false);
  lexer.unicode = bool(json.unicode, false);
  lexer.tokenPostfix = string(json.tokenPostfix, "." + lexer.languageId);
  lexer.defaultToken = string(json.defaultToken, "source");
  lexer.usesEmbedded = false;
  let lexerMin = json;
  lexerMin.languageId = languageId;
  lexerMin.includeLF = lexer.includeLF;
  lexerMin.ignoreCase = lexer.ignoreCase;
  lexerMin.unicode = lexer.unicode;
  lexerMin.noThrow = lexer.noThrow;
  lexerMin.usesEmbedded = lexer.usesEmbedded;
  lexerMin.stateNames = json.tokenizer;
  lexerMin.defaultToken = lexer.defaultToken;
  function addRules(state, newrules, rules) {
    for (const rule of rules) {
      let include = rule.include;
      if (include) {
        if (typeof include !== "string") {
          throw createError(lexer, "an 'include' attribute must be a string at: " + state);
        }
        if (include[0] === "@") {
          include = include.substr(1);
        }
        if (!json.tokenizer[include]) {
          throw createError(lexer, "include target '" + include + "' is not defined at: " + state);
        }
        addRules(state + "." + include, newrules, json.tokenizer[include]);
      } else {
        const newrule = new Rule(state);
        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
          newrule.setRegex(lexerMin, rule[0]);
          if (rule.length >= 3) {
            if (typeof rule[1] === "string") {
              newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
            } else if (typeof rule[1] === "object") {
              const rule1 = rule[1];
              rule1.next = rule[2];
              newrule.setAction(lexerMin, rule1);
            } else {
              throw createError(lexer, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + state);
            }
          } else {
            newrule.setAction(lexerMin, rule[1]);
          }
        } else {
          if (!rule.regex) {
            throw createError(lexer, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + state);
          }
          if (rule.name) {
            if (typeof rule.name === "string") {
              newrule.name = rule.name;
            }
          }
          if (rule.matchOnlyAtStart) {
            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);
          }
          newrule.setRegex(lexerMin, rule.regex);
          newrule.setAction(lexerMin, rule.action);
        }
        newrules.push(newrule);
      }
    }
  }
  if (!json.tokenizer || typeof json.tokenizer !== "object") {
    throw createError(lexer, "a language definition must define the 'tokenizer' attribute as an object");
  }
  lexer.tokenizer = [];
  for (let key in json.tokenizer) {
    if (json.tokenizer.hasOwnProperty(key)) {
      if (!lexer.start) {
        lexer.start = key;
      }
      const rules = json.tokenizer[key];
      lexer.tokenizer[key] = new Array();
      addRules("tokenizer." + key, lexer.tokenizer[key], rules);
    }
  }
  lexer.usesEmbedded = lexerMin.usesEmbedded;
  if (json.brackets) {
    if (!Array.isArray(json.brackets)) {
      throw createError(lexer, "the 'brackets' attribute must be defined as an array");
    }
  } else {
    json.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  }
  let brackets = [];
  for (let el of json.brackets) {
    let desc = el;
    if (desc && Array.isArray(desc) && desc.length === 3) {
      desc = { token: desc[2], open: desc[0], close: desc[1] };
    }
    if (desc.open === desc.close) {
      throw createError(lexer, "open and close brackets in a 'brackets' attribute must be different: " + desc.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required.");
    }
    if (typeof desc.open === "string" && typeof desc.token === "string" && typeof desc.close === "string") {
      brackets.push({
        token: desc.token + lexer.tokenPostfix,
        open: fixCase(lexer, desc.open),
        close: fixCase(lexer, desc.close)
      });
    } else {
      throw createError(lexer, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
    }
  }
  lexer.brackets = brackets;
  lexer.noThrow = true;
  return lexer;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js
function register(language) {
  ModesRegistry.registerLanguage(language);
}
function getLanguages() {
  let result = [];
  result = result.concat(ModesRegistry.getLanguages());
  return result;
}
function getEncodedLanguageId(languageId) {
  let lid = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  return lid ? lid.id : 0;
}
function onLanguage(languageId, callback) {
  let disposable = StaticServices.modeService.get().onDidCreateMode((mode) => {
    if (mode.getId() === languageId) {
      disposable.dispose();
      callback();
    }
  });
  return disposable;
}
function setLanguageConfiguration(languageId, configuration) {
  let languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  if (!languageIdentifier) {
    throw new Error(`Cannot set configuration for unknown language ${languageId}`);
  }
  return LanguageConfigurationRegistry.register(languageIdentifier, configuration, 100);
}
var EncodedTokenizationSupport2Adapter = class {
  constructor(languageIdentifier, actual) {
    this._languageIdentifier = languageIdentifier;
    this._actual = actual;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(line, hasEOL, state, offsetDelta) {
    if (typeof this._actual.tokenize === "function") {
      return TokenizationSupport2Adapter.adaptTokenize(this._languageIdentifier.language, this._actual, line, state, offsetDelta);
    }
    throw new Error("Not supported!");
  }
  tokenize2(line, hasEOL, state) {
    let result = this._actual.tokenizeEncoded(line, state);
    return new TokenizationResult2(result.tokens, result.endState);
  }
};
var TokenizationSupport2Adapter = class {
  constructor(standaloneThemeService, languageIdentifier, actual) {
    this._standaloneThemeService = standaloneThemeService;
    this._languageIdentifier = languageIdentifier;
    this._actual = actual;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(tokens, language, offsetDelta) {
    let result = [];
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[i] = new Token(startIndex + offsetDelta, t.scopes, language);
      previousStartIndex = startIndex;
    }
    return result;
  }
  static adaptTokenize(language, actual, line, state, offsetDelta) {
    let actualResult = actual.tokenize(line, state);
    let tokens = TokenizationSupport2Adapter._toClassicTokens(actualResult.tokens, language, offsetDelta);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult(tokens, endState);
  }
  tokenize(line, hasEOL, state, offsetDelta) {
    return TokenizationSupport2Adapter.adaptTokenize(this._languageIdentifier.language, this._actual, line, state, offsetDelta);
  }
  _toBinaryTokens(tokens, offsetDelta) {
    const languageId = this._languageIdentifier.id;
    const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;
    let result = [], resultLen = 0;
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      const metadata = tokenTheme.match(languageId, t.scopes);
      if (resultLen > 0 && result[resultLen - 1] === metadata) {
        continue;
      }
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[resultLen++] = startIndex + offsetDelta;
      result[resultLen++] = metadata;
      previousStartIndex = startIndex;
    }
    let actualResult = new Uint32Array(resultLen);
    for (let i = 0; i < resultLen; i++) {
      actualResult[i] = result[i];
    }
    return actualResult;
  }
  tokenize2(line, hasEOL, state, offsetDelta) {
    let actualResult = this._actual.tokenize(line, state);
    let tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult2(tokens, endState);
  }
};
function isEncodedTokensProvider(provider) {
  return "tokenizeEncoded" in provider;
}
function isThenable(obj) {
  return obj && typeof obj.then === "function";
}
function setColorMap(colorMap) {
  if (colorMap) {
    const result = [null];
    for (let i = 1, len = colorMap.length; i < len; i++) {
      result[i] = Color.fromHex(colorMap[i]);
    }
    StaticServices.standaloneThemeService.get().setColorMapOverride(result);
  } else {
    StaticServices.standaloneThemeService.get().setColorMapOverride(null);
  }
}
function setTokensProvider(languageId, provider) {
  let languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  if (!languageIdentifier) {
    throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);
  }
  const create2 = (provider2) => {
    if (isEncodedTokensProvider(provider2)) {
      return new EncodedTokenizationSupport2Adapter(languageIdentifier, provider2);
    } else {
      return new TokenizationSupport2Adapter(StaticServices.standaloneThemeService.get(), languageIdentifier, provider2);
    }
  };
  if (isThenable(provider)) {
    return TokenizationRegistry.registerPromise(languageId, provider.then((provider2) => create2(provider2)));
  }
  return TokenizationRegistry.register(languageId, create2(provider));
}
function setMonarchTokensProvider(languageId, languageDef) {
  const create2 = (languageDef2) => {
    return createTokenizationSupport(StaticServices.modeService.get(), StaticServices.standaloneThemeService.get(), languageId, compile(languageId, languageDef2));
  };
  if (isThenable(languageDef)) {
    return TokenizationRegistry.registerPromise(languageId, languageDef.then((languageDef2) => create2(languageDef2)));
  }
  return TokenizationRegistry.register(languageId, create2(languageDef));
}
function registerReferenceProvider(languageId, provider) {
  return ReferenceProviderRegistry.register(languageId, provider);
}
function registerRenameProvider(languageId, provider) {
  return RenameProviderRegistry.register(languageId, provider);
}
function registerSignatureHelpProvider(languageId, provider) {
  return SignatureHelpProviderRegistry.register(languageId, provider);
}
function registerHoverProvider(languageId, provider) {
  return HoverProviderRegistry.register(languageId, {
    provideHover: (model, position, token) => {
      let word = model.getWordAtPosition(position);
      return Promise.resolve(provider.provideHover(model, position, token)).then((value) => {
        if (!value) {
          return void 0;
        }
        if (!value.range && word) {
          value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
        }
        if (!value.range) {
          value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        return value;
      });
    }
  });
}
function registerDocumentSymbolProvider(languageId, provider) {
  return DocumentSymbolProviderRegistry.register(languageId, provider);
}
function registerDocumentHighlightProvider(languageId, provider) {
  return DocumentHighlightProviderRegistry.register(languageId, provider);
}
function registerLinkedEditingRangeProvider(languageId, provider) {
  return LinkedEditingRangeProviderRegistry.register(languageId, provider);
}
function registerDefinitionProvider(languageId, provider) {
  return DefinitionProviderRegistry.register(languageId, provider);
}
function registerImplementationProvider(languageId, provider) {
  return ImplementationProviderRegistry.register(languageId, provider);
}
function registerTypeDefinitionProvider(languageId, provider) {
  return TypeDefinitionProviderRegistry.register(languageId, provider);
}
function registerCodeLensProvider(languageId, provider) {
  return CodeLensProviderRegistry.register(languageId, provider);
}
function registerCodeActionProvider(languageId, provider) {
  return CodeActionProviderRegistry.register(languageId, {
    provideCodeActions: (model, range2, context, token) => {
      let markers = StaticServices.markerService.get().read({ resource: model.uri }).filter((m) => {
        return Range.areIntersectingOrTouching(m, range2);
      });
      return provider.provideCodeActions(model, range2, { markers, only: context.only }, token);
    }
  });
}
function registerDocumentFormattingEditProvider(languageId, provider) {
  return DocumentFormattingEditProviderRegistry.register(languageId, provider);
}
function registerDocumentRangeFormattingEditProvider(languageId, provider) {
  return DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
}
function registerOnTypeFormattingEditProvider(languageId, provider) {
  return OnTypeFormattingEditProviderRegistry.register(languageId, provider);
}
function registerLinkProvider(languageId, provider) {
  return LinkProviderRegistry.register(languageId, provider);
}
function registerCompletionItemProvider(languageId, provider) {
  return CompletionProviderRegistry.register(languageId, provider);
}
function registerColorProvider(languageId, provider) {
  return ColorProviderRegistry.register(languageId, provider);
}
function registerFoldingRangeProvider(languageId, provider) {
  return FoldingRangeProviderRegistry.register(languageId, provider);
}
function registerDeclarationProvider(languageId, provider) {
  return DeclarationProviderRegistry.register(languageId, provider);
}
function registerSelectionRangeProvider(languageId, provider) {
  return SelectionRangeRegistry.register(languageId, provider);
}
function registerDocumentSemanticTokensProvider(languageId, provider) {
  return DocumentSemanticTokensProviderRegistry.register(languageId, provider);
}
function registerDocumentRangeSemanticTokensProvider(languageId, provider) {
  return DocumentRangeSemanticTokensProviderRegistry.register(languageId, provider);
}
function registerInlineCompletionsProvider(languageId, provider) {
  return InlineCompletionsProviderRegistry.register(languageId, provider);
}
function registerInlayHintsProvider(languageId, provider) {
  return InlayHintsProviderRegistry.register(languageId, provider);
}
function createMonacoLanguagesAPI() {
  return {
    register,
    getLanguages,
    onLanguage,
    getEncodedLanguageId,
    setLanguageConfiguration,
    setColorMap,
    setTokensProvider,
    setMonarchTokensProvider,
    registerReferenceProvider,
    registerRenameProvider,
    registerCompletionItemProvider,
    registerSignatureHelpProvider,
    registerHoverProvider,
    registerDocumentSymbolProvider,
    registerDocumentHighlightProvider,
    registerLinkedEditingRangeProvider,
    registerDefinitionProvider,
    registerImplementationProvider,
    registerTypeDefinitionProvider,
    registerCodeLensProvider,
    registerCodeActionProvider,
    registerDocumentFormattingEditProvider,
    registerDocumentRangeFormattingEditProvider,
    registerOnTypeFormattingEditProvider,
    registerLinkProvider,
    registerColorProvider,
    registerFoldingRangeProvider,
    registerDeclarationProvider,
    registerSelectionRangeProvider,
    registerDocumentSemanticTokensProvider,
    registerDocumentRangeSemanticTokensProvider,
    registerInlineCompletionsProvider,
    registerInlayHintsProvider,
    DocumentHighlightKind,
    CompletionItemKind,
    CompletionItemTag,
    CompletionItemInsertTextRule,
    SymbolKind,
    SymbolTag,
    IndentAction,
    CompletionTriggerKind,
    SignatureHelpTriggerKind,
    InlayHintKind,
    InlineCompletionTriggerKind,
    FoldingRangeKind
  };
}

// node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js
var ExtensionIdentifier = class {
  constructor(value) {
    this.value = value;
    this._lower = value.toLowerCase();
  }
  static toKey(id) {
    if (typeof id === "string") {
      return id.toLowerCase();
    }
    return id._lower;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/format/format.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getRealAndSyntheticDocumentFormattersOrdered(model) {
  const result = [];
  const seen = new Set();
  const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);
  for (const formatter of docFormatter) {
    result.push(formatter);
    if (formatter.extensionId) {
      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));
    }
  }
  const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);
  for (const formatter of rangeFormatter) {
    if (formatter.extensionId) {
      if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {
        continue;
      }
      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));
    }
    result.push({
      displayName: formatter.displayName,
      extensionId: formatter.extensionId,
      provideDocumentFormattingEdits(model2, options, token) {
        return formatter.provideDocumentRangeFormattingEdits(model2, model2.getFullModelRange(), options, token);
      }
    });
  }
  return result;
}
var FormattingConflicts = class {
  static setFormatterSelector(selector) {
    const remove = FormattingConflicts._selectors.unshift(selector);
    return { dispose: remove };
  }
  static select(formatter, document2, mode) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (formatter.length === 0) {
        return void 0;
      }
      const selector = Iterable.first(FormattingConflicts._selectors);
      if (selector) {
        return yield selector(formatter, document2, mode);
      }
      return void 0;
    });
  }
};
FormattingConflicts._selectors = new LinkedList();
function getDocumentRangeFormattingEditsUntilResult(workerService, model, range2, options, token) {
  return __awaiter13(this, void 0, void 0, function* () {
    const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);
    for (const provider of providers) {
      let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range2, options, token)).catch(onUnexpectedExternalError);
      if (isNonEmptyArray(rawEdits)) {
        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      }
    }
    return void 0;
  });
}
function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {
  return __awaiter13(this, void 0, void 0, function* () {
    const providers = getRealAndSyntheticDocumentFormattersOrdered(model);
    for (const provider of providers) {
      let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);
      if (isNonEmptyArray(rawEdits)) {
        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      }
    }
    return void 0;
  });
}
function getOnTypeFormattingEdits(workerService, model, position, ch, options) {
  const providers = OnTypeFormattingEditProviderRegistry.ordered(model);
  if (providers.length === 0) {
    return Promise.resolve(void 0);
  }
  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {
    return Promise.resolve(void 0);
  }
  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then((edits) => {
    return workerService.computeMoreMinimalEdits(model.uri, edits);
  });
}
CommandsRegistry.registerCommand("_executeFormatRangeProvider", function(accessor, ...args) {
  const [resource, range2, options] = args;
  assertType(URI.isUri(resource));
  assertType(Range.isIRange(range2));
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range2), options, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeFormatDocumentProvider", function(accessor, ...args) {
  const [resource, options] = args;
  assertType(URI.isUri(resource));
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeFormatOnTypeProvider", function(accessor, ...args) {
  const [resource, position, ch, options] = args;
  assertType(URI.isUri(resource));
  assertType(Position.isIPosition(position));
  assertType(typeof ch === "string");
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);
});

// node_modules/monaco-editor/esm/vs/editor/editor.api.js
var _a5;
EditorOptions.wrappingIndent.defaultValue = 0;
EditorOptions.glyphMargin.defaultValue = false;
EditorOptions.autoIndent.defaultValue = 3;
EditorOptions.overviewRulerLanes.defaultValue = 2;
FormattingConflicts.setFormatterSelector((formatter, document2, mode) => Promise.resolve(formatter[0]));
var api = createMonacoBaseAPI();
api.editor = createMonacoEditorAPI();
api.languages = createMonacoLanguagesAPI();
var CancellationTokenSource2 = api.CancellationTokenSource;
var Emitter2 = api.Emitter;
var KeyCode2 = api.KeyCode;
var KeyMod2 = api.KeyMod;
var Position2 = api.Position;
var Range3 = api.Range;
var Selection2 = api.Selection;
var SelectionDirection2 = api.SelectionDirection;
var MarkerSeverity3 = api.MarkerSeverity;
var MarkerTag2 = api.MarkerTag;
var Uri = api.Uri;
var Token2 = api.Token;
var editor = api.editor;
var languages = api.languages;
if (((_a5 = globals.MonacoEnvironment) === null || _a5 === void 0 ? void 0 : _a5.globalAPI) || typeof define === "function" && define.amd) {
  self.monaco = api;
}
if (typeof self.require !== "undefined" && typeof self.require.config === "function") {
  self.require.config({
    ignoreDuplicateModules: [
      "vscode-languageserver-types",
      "vscode-languageserver-types/main",
      "vscode-languageserver-textdocument",
      "vscode-languageserver-textdocument/main",
      "vscode-nls",
      "vscode-nls/vscode-nls",
      "jsonc-parser",
      "jsonc-parser/main",
      "vscode-uri",
      "vscode-uri/index",
      "vs/basic-languages/typescript/typescript"
    ]
  });
}

export {
  CancellationTokenSource2 as CancellationTokenSource,
  Emitter2 as Emitter,
  KeyCode2 as KeyCode,
  KeyMod2 as KeyMod,
  Position2 as Position,
  Range3 as Range,
  Selection2 as Selection,
  SelectionDirection2 as SelectionDirection,
  MarkerSeverity3 as MarkerSeverity,
  MarkerTag2 as MarkerTag,
  Uri,
  Token2 as Token,
  editor,
  languages
};
//# sourceMappingURL=chunk-6YCQGRU7.js.map
